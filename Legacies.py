import sys
import random
import json
import os
import time
import math
import textwrap
import re
from typing import List, Dict, Optional, Tuple, Any
from datetime import datetime
from colorama import Fore, Back, Style, init

# Legendary Pets System
LEGENDARY_PETS = {
    "Phoenix": {
        "rarity": "Legendary",
        "element": "Fire",
        "abilities": ["Rebirth", "Flame Aura"],
        "stats_bonus": {"attack": 25, "speed": 15},
        "appearance": "A majestic fire bird with brilliant red and gold plumage that emits sparks when it moves.",
        "lore": "Born from the eternal flames, the Phoenix can be reborn from its ashes once per day.",
        "obtain_method": "Defeat the ancient Fire Titan in the Volcanic Depths"
    },
    "Cerberus": {
        "rarity": "Legendary",
        "element": "Dark",
        "abilities": ["Triple Threat", "Guardian's Warning"],
        "stats_bonus": {"defense": 30, "max_health": 50},
        "appearance": "A three-headed hound with obsidian fur that seems to absorb light around it.",
        "lore": "Once a guardian of the underworld, this loyal hound will protect its master with all three of its fierce heads.",
        "obtain_method": "Complete the 'Descent into Darkness' quest chain"
    },
    "Kraken": {
        "rarity": "Legendary",
        "element": "Water",
        "abilities": ["Tentacle Strike", "Abyssal Protection"],
        "stats_bonus": {"attack": 20, "defense": 20, "water_breathing": True},
        "appearance": "A miniature but powerful sea monster with iridescent blue tentacles and intelligent eyes.",
        "lore": "A young Kraken that bonded with you after you saved it from hunters. Grants the ability to breathe underwater.",
        "obtain_method": "Rare chance when fishing in the Deep Ocean"
    },
    "Pegasus": {
        "rarity": "Legendary",
        "element": "Air",
        "abilities": ["Skyward Bound", "Wind Rush"],
        "stats_bonus": {"speed": 35, "reduced_fall_damage": True},
        "appearance": "A magnificent winged horse with a pearlescent coat that shimmers with the colors of the sky.",
        "lore": "The offspring of celestial winds and earthly steeds, a Pegasus can grant temporary flight to its rider.",
        "obtain_method": "Find and nurture a rare Pegasus egg from the Floating Islands"
    },
    "Legendary Dragon Wyrmling": {
        "rarity": "Legendary",
        "element": "Earth",
        "abilities": ["Dragon Breath", "Ancient Wisdom"],
        "stats_bonus": {"attack": 15, "defense": 15, "intelligence": 20},
        "appearance": "A baby dragon with emerald scales that shimmer like precious stones in the light.",
        "lore": "Even young dragons possess incredible magical potential. This earth wyrmling has chosen you as its parent figure.",
        "obtain_method": "Complete the Dragon Tamer questline and earn the trust of the Dragon Queen"
    }
}

# Ship Types
SHIPS = {
    "Basic Raft": {
        "capacity": 1,
        "speed": 1,
        "durability": 20,
        "special_features": [],
        "description": "A simple raft made up of wood scraps and ropes, suitable for any kind of small journey.",
        "cost": 120,
        "required_level": 1,
        "required_materials": {"Wood": 10, "Rope": 5}
    },
    "Fishing Boat": {
        "capacity": 2,
        "speed": 1,
        "durability": 50,
        "special_features": [],
        "description": "A small boat suitable for fishing in calm waters and short coastal journeys.",
        "cost": 500,
        "required_level": 1,
        "required_materials": {"Wood": 30, "Rope": 15}
    },
    "Merchant Vessel": {
        "capacity": 5,
        "speed": 2,
        "durability": 120,
        "special_features": ["Cargo Hold"],
        "description": "A sturdy ship with ample storage for goods and passengers.",
        "cost": 2000,
        "required_level": 10,
        "required_materials": {"Wood": 100, "Iron": 30, "Cloth": 50, "Rope": 40}
    },
    "Explorer's Caravel": {
        "capacity": 4,
        "speed": 3,
        "durability": 150,
        "special_features": ["Navigation Charts", "Weather Resistance"],
        "description": "A versatile ship designed for exploring unknown waters and withstanding harsh conditions.",
        "cost": 5000,
        "required_level": 20,
        "required_materials": {"Hardwood": 120, "Iron": 60, "Fine Cloth": 70, "Enchanted Rope": 30}
    },
    "War Galleon": {
        "capacity": 8,
        "speed": 2,
        "durability": 250,
        "special_features": ["Cannons", "Reinforced Hull", "Intimidating Flag"],
        "description": "A powerful warship equipped for naval combat and showing force.",
        "cost": 10000,
        "required_level": 30,
        "required_materials": {"Reinforced Wood": 200, "Steel": 100, "Fine Cloth": 100, "Enchanted Rope": 50}
    },
    "Arcane Schooner": {
        "capacity": 6,
        "speed": 4,
        "durability": 200,
        "special_features": ["Magic Sails", "Elemental Protection", "Enchanted Hull"],
        "description": "A magical vessel infused with arcane energies, capable of traveling through mystical waters and storms.",
        "cost": 25000,
        "required_level": 40,
        "required_materials": {"Enchanted Wood": 150, "Mithril": 80, "Ethereal Cloth": 100, "Dragon Heartstring": 10},
        "realm": "Sea"
    },
    "Ethereal Skyship": {
        "capacity": 4,
        "speed": 5,
        "durability": 120,
        "special_features": ["Celestial Navigation", "Cloud Walking", "Dimensional Anchor"],
        "description": "A magnificent vessel that sails through the skies and can breach the barrier between realms to access the Ethereal Plane.",
        "cost": 35000,
        "required_level": 45,
        "required_materials": {"Ethereal Wood": 150, "Star Metal": 100, "Cloud Silk": 80, "Astral Essence": 50},
        "realm": "Ethereal"
    },
    "Divine Galleon": {
        "capacity": 10,
        "speed": 6,
        "durability": 300,
        "special_features": ["Divine Protection", "Celestial Navigation", "Realm Phasing", "Godly Essence"],
        "description": "A legendary vessel blessed by the gods themselves, capable of traversing any realm and withstanding even divine wrath.",
        "cost": 80000,
        "required_level": 60,
        "required_materials": {"God-touched Wood": 200, "Divine Metal": 150, "Blessing Cloth": 100, "Fate Thread": 70},
        "realm": "All"
    }
}

# World Regions
WORLD_REGIONS = {
    "Sealtea": {
        "description": "The main continent, home to diverse landscapes from dense forests to towering mountains.",
        "climate": "Temperate",
        "dangers": "Varies by area",
        "areas": ["Greenwood Village", "Dark Forest", "Mountain Path", "Farmlands", "Crystal Cave", "Arcane Academy"],
        "required_level": 1
    },
    "The Dead Sea": {
        "description": "A vast, lifeless expanse of unchanging stone stretching to the horizon. The edge of the known world.",
        "climate": "None",
        "dangers": "Absolute emptiness, disorientation",
        "areas": ["Stone's Edge"],
        "required_level": 50,
        "special_notes": "Contains no living beings or materials. A plain, unchanging stone surface that marks the border of the world."
    },
    "Ethereal Realm": {
        "description": "A mystical plane of existence where the gods reside. Reality bends to divine will, and time flows differently.",
        "climate": "Divine",
        "dangers": "Reality shifts, divine judgment, celestial monsters",
        "areas": ["Gateway of Stars", "Divine Court", "Celestial Gardens", "Hall of Heroes", "The Great Forge"],
        "required_level": 45,
        "required_ship": "Ethereal Skyship",
        "required_skill": "celestial_navigation"
    },
    "Mystic Archipelago": {
        "description": "A chain of magical islands, each with unique properties and environments.",
        "climate": "Tropical",
        "dangers": "Magical storms, sea monsters, island guardians",
        "areas": ["Navigator's Port", "Siren's Isle", "Volcano Island", "Whispering Reefs"],
        "required_level": 25,
        "required_item": "Seaworthy vessel"
    },
    "Frozen Wastes": {
        "description": "A harsh, snow-covered land where only the hardiest creatures survive.",
        "climate": "Arctic",
        "dangers": "Frostbite, ice elementals, avalanches, winter wolves",
        "areas": ["Frost Harbor", "Glacial Peaks", "Frozen Forest", "Ice Caverns"],
        "required_level": 30,
        "required_item": "Warm clothing"
    }
}

# New areas for the expanded world
NEW_AREAS = {
    "Stone's Edge": {
        "description": "The final outpost before the vast emptiness of The Dead Sea. A lonely watchtower stands vigil over the unchanging expanse.",
        "region": "The Dead Sea",
        "connections": ["Mountain Path"],
        "monsters": ["Stone Elemental", "Void Walker"],
        "npcs": ["The Watcher", "Lost Explorer"],
        "quests": ["Edge of the World", "Void Whispers"],
        "shops": False,
        "safe": False,
        "level_range": (45, 50)
    },
    "Gateway of Stars": {
        "description": "A magnificent floating platform surrounded by cosmic energy, marking the entrance to the Ethereal Realm. Countless stars form shifting constellations overhead.",
        "region": "Ethereal Realm",
        "connections": ["Divine Court"],
        "monsters": ["Star Elemental", "Celestial Guardian", "Cosmic Aberration"],
        "npcs": ["Gateway Keeper", "Lost Soul", "Star Cartographer"],
        "quests": ["Charting the Heavens", "Star Mapping", "Ascension Path"],
        "shops": True,
        "safe": True,
        "level_range": (45, 55)
    },
    "Divine Court": {
        "description": "A vast, open chamber where the gods hold audience with worthy mortals. The architecture seems to shift and change depending on the observer.",
        "region": "Ethereal Realm",
        "connections": ["Gateway of Stars", "Celestial Gardens", "Hall of Heroes"],
        "monsters": ["Divine Sentinel", "Law Enforcer", "Judgment Seeker"],
        "npcs": ["Divine Herald", "Court Scribe", "The Judge"],
    },
    "Celestial Gardens": {
        "description": "Breathtaking gardens where flora from all realms and times grow together. Plants react to emotions and thoughts, creating an ever-changing landscape.",
        "region": "Ethereal Realm",
        "connections": ["Divine Court", "The Great Forge"],
        "monsters": ["Garden Keeper", "Corrupt Growth", "Living Bloom"],
        "npcs": ["Eternal Gardener", "Garden Visitor", "Whisperleaf"],
    },
    "Hall of Heroes": {
        "description": "A majestic hall where the greatest heroes of all time are honored. Their essences remain to provide guidance and wisdom to worthy visitors.",
        "region": "Ethereal Realm",
        "connections": ["Divine Court", "The Great Forge"],
        "monsters": ["Echo of Battle", "Corrupted Hero", "Legacy Guardian"],
        "npcs": ["Hero's Echo", "Memory Keeper", "The Challenger"],
    },
    "The Great Forge": {
        "description": "The divine workshop where the most powerful artifacts were crafted. Eternal fires burn, ready to forge items of incredible power for those deemed worthy.",
        "region": "Ethereal Realm",
        "connections": ["Celestial Gardens", "Hall of Heroes"],
        "monsters": ["Forge Guardian", "Living Metal", "Flame Sentinel"],
        "npcs": ["Divine Smith", "Apprentice of Creation", "Master of Elements"],
        "quests": ["Divine Crafting", "Celestial Materials", "Forge of Destiny"],
        "shops": True,
        "safe": False,
        "level_range": (50, 60)
    },
    "Navigator's Port": {
        "description": "A bustling harbor town where sailors, merchants, and adventurers gather before setting sail to the Mystic Archipelago.",
        "region": "Mystic Archipelago",
        "connections": ["Farmlands", "Siren's Isle"],
        "monsters": ["Drunken Pirate", "Harbor Rat"],
        "npcs": ["Harbormaster", "Ship Builder", "Sea Sage"],
        "quests": ["Sea Legs", "Chart the Course"],
        "shops": True,
        "safe": True,
        "level_range": (20, 25)
    },
    "Siren's Isle": {
        "description": "A beautiful but dangerous island where enchanting melodies drift through the mist.",
        "region": "Mystic Archipelago",
        "connections": ["Navigator's Port", "Volcano Island"],
        "monsters": ["Siren", "Enchanted Coral", "Bewitched Sailor"],
        "npcs": ["Deaf Hermit", "Former Siren"],
        "quests": ["Resist the Call", "Broken Melody"],
        "shops": False,
        "safe": False,
        "level_range": (25, 30)
    },
    "Volcano Island": {
        "description": "An island dominated by an active volcano, where the ground smolders and rare minerals form in the heat.",
        "region": "Mystic Archipelago",
        "connections": ["Siren's Isle", "Whispering Reefs"],
        "monsters": ["Magma Elemental", "Ash Wraith", "Fire Lizard"],
        "npcs": ["Volcano Priestess", "Mineral Hunter"],
        "quests": ["Heart of Fire", "Precious Metals"],
        "shops": True,
        "safe": False,
        "level_range": (27, 32)
    },
    "Whispering Reefs": {
        "description": "Mysterious coral formations that seem to whisper ancient secrets. The waters teem with both beauty and danger.",
        "region": "Mystic Archipelago",
        "connections": ["Volcano Island"],
        "monsters": ["Reef Guardian", "Depth Hunter", "Living Coral"],
        "npcs": ["Reef Listener", "Treasure Hunter"],
        "quests": ["Secrets of the Deep", "Lost Expedition"],
        "shops": False,
        "safe": False,
        "level_range": (30, 35)
    },
    "Frost Harbor": {
        "description": "A port carved from ice where hardy traders and explorers prepare for journeys into the Frozen Wastes.",
        "region": "Frozen Wastes",
        "connections": ["Dark Forest", "Glacial Peaks"],
        "monsters": ["Frost Wolf", "Ice Golem"],
        "npcs": ["Winter Trader", "Arctic Explorer", "Ice Sculptor"],
        "quests": ["Frostbitten", "Supplies Run"],
        "shops": True,
        "safe": True,
        "level_range": (30, 35)
    }
}

# Flag for new features being available
MODULES_LOADED = True

# Ocean Events for sailing
OCEAN_EVENTS = {
    "calm": {
        "name": "Calm Seas",
        "description": "The waters are peaceful and the journey smooth.",
        "effect": "Restores some of your HP and mana during travel.",
        "probability": 0.3
    },
    "storm": {
        "name": "Raging Storm",
        "description": "Violent winds and massive waves threaten to capsize your ship!",
        "effect": "Ship takes damage. You must make sailing checks to avoid capsizing.",
        "probability": 0.15
    },
    "pirates": {
        "name": "Pirate Attack",
        "description": "A ship flying the black flag approaches with hostile intent!",
        "effect": "Combat encounter with pirates. Ship may take damage.",
        "probability": 0.1
    },
    "sea_monster": {
        "name": "Sea Monster",
        "description": "A massive creature rises from the depths, its tentacles reaching for your ship!",
        "effect": "Combat encounter with a powerful sea monster.",
        "probability": 0.05
    },
    "shipwreck": {
        "name": "Discovered Shipwreck",
        "description": "You spot the remains of a ship, half-submerged in the water.",
        "effect": "Chance to salvage valuable items and materials.",
        "probability": 0.1
    },
    "merchants": {
        "name": "Merchant Ship",
        "description": "You encounter a friendly merchant vessel willing to trade goods.",
        "effect": "Opportunity to purchase rare items at sea.",
        "probability": 0.15
    },
    "treasure": {
        "name": "Floating Treasure",
        "description": "A small chest bobs in the water, seemingly abandoned.",
        "effect": "Gain gold, items, or potentially a map to hidden treasure.",
        "probability": 0.05
    },
    "whirlpool": {
        "name": "Whirlpool",
        "description": "A massive vortex forms in the ocean, threatening to pull your ship down!",
        "effect": "Must successfully navigate or risk major damage to ship and crew.",
        "probability": 0.1
    }
}

# Initialize colorama
init(autoreset=True)

# Legendary Pets Function
def manage_pets(user_data: Dict[str, Any]) -> None:
    """Main pet management interface for both regular and legendary pets"""
    # Initialize pet data structures if not present
    if "pets" not in user_data:
        user_data["pets"] = {}
    if "legendary_pets" not in user_data:
        user_data["legendary_pets"] = {}

    # Default pet abilities and stats for new regular pets
    default_pets = {
        "Cat": {
            "type": "Domestic", 
            "level": 1, 
            "loyalty": 20,
            "stats": {"attack": 5, "defense": 3, "speed": 12},
            "abilities": ["Night Vision", "Agility"]
        },
        "Dog": {
            "type": "Domestic", 
            "level": 1, 
            "loyalty": 30,
            "stats": {"attack": 8, "defense": 7, "speed": 10},
            "abilities": ["Loyalty", "Danger Sense"]
        }, 
        "Wolf": {
            "type": "Wild", 
            "level": 3, 
            "loyalty": 10,
            "stats": {"attack": 15, "defense": 8, "speed": 12},
            "abilities": ["Pack Tactics"]
        }
    }

    # Pet evolution paths and requirements - global so it can be accessed by pet functions
    global PET_EVOLUTIONS
    PET_EVOLUTIONS = {
        "Cat": {
            "evolves_to": "Shadow Cat",
            "level_required": 10,
            "loyalty_required": 75,
            "materials_required": ["Shadow Essence", "Feline Spirit"]
        },
        "Dog": {
            "evolves_to": "War Hound",
            "level_required": 10,
            "loyalty_required": 80,
            "materials_required": ["Beast Fang", "Loyal Heart"]
        },
        "Wolf": {
            "evolves_to": "Dire Wolf",
            "level_required": 12,
            "loyalty_required": 65,
            "materials_required": ["Moon Crystal", "Wild Spirit"]
        },
        "Dragon Hatchling": {
            "evolves_to": "Young Drake",
            "level_required": 15,
            "loyalty_required": 70,
            "materials_required": ["Dragon Scale", "Fire Essence"]
        },
        "Shadow Cat": {
            "evolves_to": "Void Stalker",
            "level_required": 17,
            "loyalty_required": 80,
            "materials_required": ["Void Fragment", "Shadow Crystal", "Midnight Essence"]
        },
        "War Hound": {
            "evolves_to": "Battle Mastiff",
            "level_required": 20,
            "loyalty_required": 90,
            "materials_required": ["War Banner", "Hero's Medal", "Ancient Collar"]
        }
    }

    # Add some starter pets if user has none
    if not user_data["pets"] and not user_data.get("has_starter_pet", False):
        print(f"\n{GREEN}You've been given a pet Cat to start your adventure!{ENDC}")
        user_data["pets"]["Cat"] = default_pets["Cat"].copy()
        user_data["has_starter_pet"] = True

    while True:
        print(f"\n{BOLD}{CYAN}=== PET MANAGEMENT ==={ENDC}")
        print(f"\n{WHITE}Manage your animal companions, from loyal regular pets to rare legendary creatures.{ENDC}")

        # Display options
        print(f"\n{YELLOW}1. Regular Pets{ENDC}")
        print(f"{YELLOW}2. Legendary Pets{ENDC}")
        print(f"{YELLOW}3. Pet Encyclopedia{ENDC}")
        print(f"{YELLOW}4. Evolution Center{ENDC}")
        print(f"{RED}0. Back to Main Menu{ENDC}")

        choice = input("\nEnter your choice: ")

        if choice == "1":
            manage_regular_pets(user_data)
        elif choice == "2":
            manage_legendary_pets_menu(user_data)
        elif choice == "3":
            combined_pet_encyclopedia(user_data)
        elif choice == "4":
            pet_evolution_center(user_data)
        elif choice == "0":
            break
        else:
            print(f"{RED}Invalid option. Please try again.{ENDC}")

def manage_regular_pets(user_data: Dict[str, Any]) -> None:
    """Regular pets management interface"""
    while True:
        print(f"\n{BOLD}{CYAN}=== REGULAR PETS ==={ENDC}")
        print(f"\n{WHITE}Manage your regular animal companions.{ENDC}")

        # Display options
        print(f"\n{YELLOW}1. View Your Pets{ENDC}")
        print(f"{YELLOW}2. Feed Pet{ENDC}")
        print(f"{YELLOW}3. Train Pet{ENDC}")
        print(f"{YELLOW}4. Set Active Pet{ENDC}")
        print(f"{RED}0. Back{ENDC}")

        choice = input("\nEnter your choice: ")

        if choice == "1":
            view_regular_pets(user_data)
        elif choice == "2":
            feed_regular_pet(user_data)
        elif choice == "3":
            train_regular_pet(user_data)
        elif choice == "4":
            set_active_regular_pet(user_data)
        elif choice == "0":
            break
        else:
            print(f"{RED}Invalid option. Please try again.{ENDC}")

def manage_legendary_pets_menu(user_data: Dict[str, Any]) -> None:
    """Legendary pets management interface"""
    # Initialize legendary_pets if not present in user_data
    if "legendary_pets" not in user_data:
        user_data["legendary_pets"] = {}

    while True:
        print(f"\n{BOLD}{CYAN}=== LEGENDARY PETS ==={ENDC}")
        print(f"\n{WHITE}Legendary pets are rare and powerful companions that provide unique abilities and significant stat bonuses.{ENDC}")

        # Display options
        print(f"\n{YELLOW}1. View Your Legendary Pets{ENDC}")
        print(f"{YELLOW}2. Legendary Pet Encyclopedia{ENDC}")
        print(f"{YELLOW}3. Interact with Legendary Pet{ENDC}")
        print(f"{YELLOW}4. Set Active Legendary Pet{ENDC}")
        print(f"{RED}0. Back{ENDC}")

        choice = input("\nEnter your choice: ")

        if choice == "1":
            view_owned_pets(user_data)
        elif choice == "2":
            pet_encyclopedia()
        elif choice == "3":
            interact_with_pet(user_data)
        elif choice == "4":
            set_active_pet(user_data)
        elif choice == "0":
            break
        else:
            print(f"{RED}Invalid option. Please try again.{ENDC}")

def view_regular_pets(user_data: Dict[str, Any]) -> None:
    """Display all regular pets owned by the player"""
    print(f"\n{BOLD}{CYAN}=== YOUR PETS ==={ENDC}")

    # Check if user has any pets
    if not user_data.get("pets", {}):
        print(f"\n{YELLOW}You don't have any pets yet. Visit a pet vendor or complete quests to find animal companions!{ENDC}")
        return

    # Get active pet
    active_pet = user_data.get("active_pet", None)

    # Display each owned pet
    for pet_name, pet_data in user_data["pets"].items():
        # Mark active pet
        active_marker = f"{GREEN}[ACTIVE]{ENDC}" if pet_name == active_pet else ""

        # Display pet details
        print(f"\n{BLUE}{BOLD}{pet_name} {active_marker}{ENDC}")
        print(f"{WHITE}Level: {pet_data.get('level', 1)}{ENDC}")
        print(f"Type: {pet_data.get('type', 'Unknown')}")
        print(f"Loyalty: {pet_data.get('loyalty', 0)}/100")

        # Calculate experience to next level
        current_level = pet_data.get("level", 1)
        current_exp = pet_data.get("exp", 0)
        exp_needed = current_level * 100
        print(f"Experience: {current_exp}/{exp_needed}")

        # Check if the pet can evolve
        if pet_name in PET_EVOLUTIONS:
            evolution_data = PET_EVOLUTIONS[pet_name]
            print(f"\n{MAGENTA}Can evolve to: {evolution_data['evolves_to']} (at level {evolution_data['level_required']} and loyalty {evolution_data['loyalty_required']}){ENDC}")

        # Display stats
        if "stats" in pet_data:
            print(f"\n{GREEN}Stats:{ENDC}")
            for stat, value in pet_data["stats"].items():
                print(f"- {stat.title()}: {value}")

        # Display abilities
        if "abilities" in pet_data:
            print(f"\n{YELLOW}Abilities:{ENDC}")
            for ability in pet_data["abilities"]:
                print(f"- {ability}")

        print(f"\n{LIGHTRED}{'-' * 40}{ENDC}")

def view_owned_pets(user_data: Dict[str, Any]) -> None:
    """Display all legendary pets owned by the player"""
    print(f"\n{BOLD}{CYAN}=== YOUR LEGENDARY PETS ==={ENDC}")

    # Check if user has any legendary pets
    if not user_data["legendary_pets"]:
        print(f"\n{YELLOW}You don't have any legendary pets yet. Embark on special quests to find these rare companions!{ENDC}")
        return

    # Get active pet
    active_pet = user_data.get("active_legendary_pet", None)

    # Display each owned pet
    for pet_name, pet_data in user_data["legendary_pets"].items():
        # Mark active pet
        active_marker = f"{GREEN}[ACTIVE]{ENDC}" if pet_name == active_pet else ""

        # Display pet details
        print(f"\n{BLUE}{BOLD}{pet_name} {active_marker}{ENDC}")
        print(f"{WHITE}Level: {pet_data.get('level', 1)}{ENDC}")
        print(f"Element: {pet_data.get('element', 'Unknown')}")
        print(f"Bond Level: {pet_data.get('bond', 1)}/10")

        # Display abilities
        print(f"\n{YELLOW}Abilities:{ENDC}")
        for ability in LEGENDARY_PETS[pet_name]["abilities"]:
            print(f"- {ability}")

        # Display bonuses
        print(f"\n{GREEN}Stat Bonuses:{ENDC}")
        for stat, bonus in LEGENDARY_PETS[pet_name]["stats_bonus"].items():
            if isinstance(bonus, bool):
                print(f"- {stat.replace('_', ' ').title()}: {'Enabled' if bonus else 'Disabled'}")
            else:
                print(f"- {stat.title()}: +{bonus}")

        print(f"\n{LIGHTRED}{'-' * 40}{ENDC}")

def legendary_pet_encyclopedia() -> None:
    """Display information about all legendary pets"""
    print(f"\n{BOLD}{CYAN}=== LEGENDARY PET ENCYCLOPEDIA ==={ENDC}")
    print(f"{WHITE}Learn about the legendary pets you can discover in your journey.{ENDC}")

    # Create a numbered list of pets
    pet_list = list(LEGENDARY_PETS.keys())
    for i, pet_name in enumerate(pet_list, 1):
        print(f"{i}. {pet_name}")

    print("0. Back")

    choice = input("\nSelect a pet to learn more about (or 0 to go back): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(pet_list):
            pet_name = pet_list[index]
            pet = LEGENDARY_PETS[pet_name]

            print(f"\n{BOLD}{BLUE}=== {pet_name} ==={ENDC}")
            print(f"{MAGENTA}Rarity: {pet['rarity']}{ENDC}")
            print(f"{MAGENTA}Element: {pet['element']}{ENDC}")
            print(f"\n{WHITE}{pet['appearance']}{ENDC}")
            print(f"\n{YELLOW}Lore: {pet['lore']}{ENDC}")

            print(f"\n{GREEN}Abilities:{ENDC}")
            for ability in pet['abilities']:
                print(f"- {ability}")

            print(f"\n{CYAN}Stat Bonuses:{ENDC}")
            for stat, bonus in pet['stats_bonus'].items():
                if isinstance(bonus, bool):
                    print(f"- {stat.replace('_', ' ').title()}: {'Enabled' if bonus else 'Disabled'}")
                else:
                    print(f"- {stat.title()}: +{bonus}")

            print(f"\n{RED}How to obtain: {pet['obtain_method']}{ENDC}")
            input("\nPress Enter to continue...")
        else:
            print(f"{RED}Invalid selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def combined_pet_encyclopedia(user_data: Dict[str, Any]) -> None:
    """Display a combined encyclopedia of both regular and legendary pets"""
    while True:
        print(f"\n{BOLD}{CYAN}=== PET ENCYCLOPEDIA ==={ENDC}")
        print(f"{WHITE}Learn about the various pets you can discover and collect.{ENDC}")

        print(f"\n{YELLOW}1. Regular Pets Encyclopedia{ENDC}")
        print(f"{YELLOW}2. Legendary Pets Encyclopedia{ENDC}")
        print(f"{RED}0. Back{ENDC}")

        choice = input("\nEnter your choice: ")

        if choice == "1":
            regular_pet_encyclopedia()
        elif choice == "2":
            legendary_pet_encyclopedia()
        elif choice == "0":
            return
        else:
            print(f"{RED}Invalid option. Please try again.{ENDC}")

def regular_pet_encyclopedia() -> None:
    """Display information about all regular pets"""
    print(f"\n{BOLD}{CYAN}=== REGULAR PET ENCYCLOPEDIA ==={ENDC}")
    print(f"{WHITE}Learn about the common and uncommon pets you can find in your journey.{ENDC}")

    # Define pet types/categories
    pet_categories = {
        "Domestic": ["Cat", "Dog", "Rabbit", "Bird"],
        "Wild": ["Wolf", "Bear", "Fox", "Raccoon"],
        "Exotic": ["Dragon Hatchling", "Griffin Cub", "Baby Chimera", "Shadow Panther"],
        "Aquatic": ["Fish", "Turtle", "Frog", "Abyssal Kraken Hatchling"]
    }

    # Display categories
    print(f"\n{YELLOW}Pet Categories:{ENDC}")
    for i, category in enumerate(pet_categories.keys(), 1):
        print(f"{i}. {category}")

    print("0. Back")

    category_choice = input("\nSelect a category to browse (or 0 to go back): ")

    if category_choice == "0":
        return

    try:
        category_index = int(category_choice) - 1
        if 0 <= category_index < len(pet_categories):
            category = list(pet_categories.keys())[category_index]
            pet_list = pet_categories[category]

            print(f"\n{BOLD}{BLUE}=== {category} PETS ==={ENDC}")

            for i, pet_name in enumerate(pet_list, 1):
                print(f"{i}. {pet_name}")

            print("0. Back")

            pet_choice = input("\nSelect a pet to learn more about (or 0 to go back): ")

            if pet_choice == "0":
                return

            try:
                pet_index = int(pet_choice) - 1
                if 0 <= pet_index < len(pet_list):
                    pet_name = pet_list[pet_index]

                    # Display pet details
                    print(f"\n{BOLD}{BLUE}=== {pet_name} ==={ENDC}")

                    # Show evolution path if available
                    if pet_name in PET_EVOLUTIONS:
                        evolution = PET_EVOLUTIONS[pet_name]
                        print(f"{MAGENTA}Evolution: Can evolve into {evolution['evolves_to']}{ENDC}")
                        print(f"{MAGENTA}Requirements: Level {evolution['level_required']}, Loyalty {evolution['loyalty_required']}{ENDC}")

                        materials = ", ".join(evolution['materials_required'])
                        print(f"{MAGENTA}Materials needed: {materials}{ENDC}")

                    # Add more pet details - this is placeholder data since actual details would come from a pet database
                    if pet_name == "Cat":
                        print(f"\n{WHITE}A small, agile domestic pet known for its independence and hunting skills.{ENDC}")
                        print(f"\n{YELLOW}Abilities:{ENDC}")
                        print("- Night Vision: Can see clearly in dark areas")
                        print("- Agility: +10% dodge chance")
                    elif pet_name == "Dog":
                        print(f"\n{WHITE}A loyal companion that will help you in combat and alert you to dangers.{ENDC}")
                        print(f"\n{YELLOW}Abilities:{ENDC}")
                        print("- Loyalty: +5% to all stats when health is low")
                        print("- Danger Sense: Early warning of approaching enemies")
                    elif pet_name == "Dragon Hatchling":
                        print(f"\n{WHITE}A rare baby dragon that will grow into a powerful ally with proper care.{ENDC}")
                        print(f"\n{YELLOW}Abilities:{ENDC}")
                        print("- Fire Breath: Small fire attack with growing power")
                        print("- Scales: Natural armor reduces damage by 5%")
                    else:
                        print(f"\n{WHITE}A wonderful companion on your journey. Raise it well!{ENDC}")
                        print(f"\n{YELLOW}Abilities:{ENDC}")
                        print("- Various abilities based on pet type and level")

                    print(f"\n{CYAN}How to obtain: Complete quests, explore specific regions, or purchase from pet vendors.{ENDC}")
                    input("\nPress Enter to continue...")
                else:
                    print(f"{RED}Invalid selection.{ENDC}")
            except ValueError:
                print(f"{RED}Please enter a number.{ENDC}")
        else:
            print(f"{RED}Invalid category selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def pet_evolution_center(user_data: Dict[str, Any]) -> None:
    """Interface for evolving pets to their higher forms"""
    print(f"\n{BOLD}{CYAN}=== PET EVOLUTION CENTER ==={ENDC}")
    print(f"{WHITE}Evolve your pets into more powerful forms when they meet the requirements.{ENDC}")

    # Check if user has any pets that can evolve
    evolvable_pets = []

    if "pets" in user_data:
        for pet_name, pet_data in user_data["pets"].items():
            if pet_name in PET_EVOLUTIONS:
                evolution = PET_EVOLUTIONS[pet_name]
                level_req = evolution["level_required"]
                loyalty_req = evolution["loyalty_required"]

                # Check if pet meets level and loyalty requirements
                if pet_data.get("level", 1) >= level_req and pet_data.get("loyalty", 0) >= loyalty_req:
                    # Check if user has required materials
                    has_materials = True
                    for material in evolution["materials_required"]:
                        if user_data.get("materials", {}).get(material, 0) < 1:
                            has_materials = False
                            break

                    if has_materials:
                        evolvable_pets.append((pet_name, evolution["evolves_to"]))

    if not evolvable_pets:
        print(f"\n{YELLOW}You don't have any pets ready to evolve. Raise their level and loyalty, and collect the required materials.{ENDC}")
        print(f"\n{CYAN}Tip: Check the Pet Encyclopedia to see evolution requirements for each pet.{ENDC}")
        input("\nPress Enter to continue...")
        return

    print(f"\n{GREEN}The following pets are ready to evolve:{ENDC}")

    for i, (pet_name, evolves_to) in enumerate(evolvable_pets, 1):
        print(f"{i}. {BLUE}{pet_name}{ENDC} → {MAGENTA}{evolves_to}{ENDC}")

    print("0. Cancel")

    choice = input("\nSelect a pet to evolve (or 0 to cancel): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(evolvable_pets):
            pet_name, evolves_to = evolvable_pets[index]

            # Confirmation
            confirm = input(f"\n{YELLOW}Are you sure you want to evolve your {pet_name} into a {evolves_to}? This process cannot be reversed. (y/n): {ENDC}")

            if confirm.lower() == "y":
                # Get pet data
                pet_data = user_data["pets"][pet_name]
                evolution = PET_EVOLUTIONS[pet_name]

                # Consume materials
                for material in evolution["materials_required"]:
                    user_data["materials"][material] -= 1

                # Create evolved pet with upgraded stats
                user_data["pets"][evolves_to] = {
                    "level": pet_data["level"],
                    "loyalty": pet_data["loyalty"],
                    "type": "Evolved",
                    "evolved_from": pet_name,
                    "stats": {
                        "attack": pet_data.get("stats", {}).get("attack", 10) + 15,
                        "defense": pet_data.get("stats", {}).get("defense", 10) + 15,
                        "speed": pet_data.get("stats", {}).get("speed", 10) + 10
                    },
                    "abilities": pet_data.get("abilities", []) + [f"{evolves_to} Special Ability"]
                }

                # Remove original pet
                del user_data["pets"][pet_name]

                # Update active pet if needed
                if user_data.get("active_pet") == pet_name:
                    user_data["active_pet"] = evolves_to

                print(f"\n{BOLD}{CYAN}*** EVOLUTION SUCCESSFUL ***{ENDC}")
                print(f"\n{GREEN}Your {pet_name} has evolved into a powerful {evolves_to}!")
                print(f"The new form has increased stats and new abilities!{ENDC}")
            else:
                print(f"\n{YELLOW}Evolution cancelled.{ENDC}")
        else:
            print(f"{RED}Invalid selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

    input("\nPress Enter to continue...")

# Functions to manage regular pets
def feed_regular_pet(user_data: Dict[str, Any]) -> None:
    """Interface for feeding regular pets to increase loyalty"""
    print(f"\n{BOLD}{CYAN}=== FEED PET ==={ENDC}")

    # Check if user has any pets
    if not user_data.get("pets", {}):
        print(f"\n{YELLOW}You don't have any pets to feed.{ENDC}")
        return

    # List user's pets
    print(f"\n{WHITE}Select a pet to feed:{ENDC}")

    pets = list(user_data["pets"].keys())
    for i, pet_name in enumerate(pets, 1):
        loyalty = user_data["pets"][pet_name].get("loyalty", 0)
        print(f"{i}. {pet_name} - Loyalty: {loyalty}/100")

    print("0. Cancel")

    choice = input("\nSelect a pet (or 0 to cancel): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(pets):
            pet_name = pets[index]

            # Check if player has food items
            food_items = {
                "1": {"name": "Basic Pet Food", "loyalty": 5, "cost": 10},
                "2": {"name": "Premium Pet Treats", "loyalty": 15, "cost": 30},
                "3": {"name": "Gourmet Pet Meal", "loyalty": 25, "cost": 50}
            }

            print(f"\n{WHITE}Select food to give to {pet_name}:{ENDC}")

            for key, food in food_items.items():
                print(f"{key}. {food['name']} - +{food['loyalty']} Loyalty - {food['cost']} gold")

            print("0. Cancel")

            food_choice = input("\nSelect food (or 0 to cancel): ")

            if food_choice == "0":
                return

            if food_choice in food_items:
                food = food_items[food_choice]

                # Check if player can afford the food
                if user_data.get("gold", 0) >= food["cost"]:
                    # Deduct gold
                    user_data["gold"] -= food["cost"]

                    # Increase loyalty
                    current_loyalty = user_data["pets"][pet_name].get("loyalty", 0)
                    new_loyalty = min(100, current_loyalty + food["loyalty"])
                    user_data["pets"][pet_name]["loyalty"] = new_loyalty

                    loyalty_gained = new_loyalty - current_loyalty

                    print(f"\n{GREEN}You fed {food['name']} to your {pet_name}.")
                    print(f"Loyalty increased by {loyalty_gained} points to {new_loyalty}/100!{ENDC}")

                    # Check for loyalty milestones
                    if current_loyalty < 25 and new_loyalty >= 25:
                        print(f"\n{CYAN}Your {pet_name} is starting to trust you more.{ENDC}")
                    elif current_loyalty < 50 and new_loyalty >= 50:
                        print(f"\n{CYAN}Your {pet_name} has become quite attached to you.{ENDC}")
                    elif current_loyalty < 75 and new_loyalty >= 75:
                        print(f"\n{CYAN}Your {pet_name} is very loyal and may learn new abilities.{ENDC}")
                    elif current_loyalty < 100 and new_loyalty >= 100:
                        print(f"\n{CYAN}Your {pet_name} has reached maximum loyalty! It's now ready for evolution if other requirements are met.{ENDC}")
                else:
                    print(f"\n{RED}You don't have enough gold for this food. You need {food['cost']} gold.{ENDC}")
            else:
                print(f"\n{RED}Invalid food selection.{ENDC}")
        else:
            print(f"\n{RED}Invalid pet selection.{ENDC}")
    except ValueError:
        print(f"\n{RED}Please enter a number.{ENDC}")

def train_regular_pet(user_data: Dict[str, Any]) -> None:
    """Interface for training regular pets to increase level"""
    print(f"\n{BOLD}{CYAN}=== TRAIN PET ==={ENDC}")

    # Check if user has any pets
    if not user_data.get("pets", {}):
        print(f"\n{YELLOW}You don't have any pets to train.{ENDC}")
        return

    # List user's pets
    print(f"\n{WHITE}Select a pet to train:{ENDC}")

    pets = list(user_data["pets"].keys())
    for i, pet_name in enumerate(pets, 1):
        level = user_data["pets"][pet_name].get("level", 1)
        print(f"{i}. {pet_name} - Level: {level}")

    print("0. Cancel")

    choice = input("\nSelect a pet (or 0 to cancel): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(pets):
            pet_name = pets[index]

            # Training options
            training_options = {
                "1": {"name": "Basic Training", "exp": 50, "cost": 20, "time": 1},
                "2": {"name": "Advanced Training", "exp": 150, "cost": 50, "time": 2},
                "3": {"name": "Intensive Training", "exp": 300, "cost": 100, "time": 4}
            }

            print(f"\n{WHITE}Select training for {pet_name}:{ENDC}")

            for key, training in training_options.items():
                print(f"{key}. {training['name']} - {training['exp']} EXP - {training['cost']} gold - {training['time']} days")

            print("0. Cancel")

            training_choice = input("\nSelect training (or 0 to cancel): ")

            if training_choice == "0":
                return

            if training_choice in training_options:
                training = training_options[training_choice]

                # Check if player can afford the training
                if user_data.get("gold", 0) >= training["cost"]:
                    # Deduct gold
                    user_data["gold"] -= training["cost"]

                    # Simulate time passing
                    if "game_days" in user_data:
                        user_data["game_days"] += training["time"]

                    # Initialize pet exp if not present
                    if "exp" not in user_data["pets"][pet_name]:
                        user_data["pets"][pet_name]["exp"] = 0

                    # Add experience
                    current_exp = user_data["pets"][pet_name]["exp"]
                    user_data["pets"][pet_name]["exp"] = current_exp + training["exp"]

                    # Check for level up
                    current_level = user_data["pets"][pet_name].get("level", 1)
                    exp_needed = current_level * 100  # Simple formula: level * 100 exp needed for next level

                    level_ups = 0
                    while user_data["pets"][pet_name]["exp"] >= exp_needed:
                        user_data["pets"][pet_name]["exp"] -= exp_needed
                        current_level += 1
                        level_ups += 1
                        exp_needed = current_level * 100

                    user_data["pets"][pet_name]["level"] = current_level

                    print(f"\n{GREEN}Your {pet_name} completed {training['name']}.")

                    if level_ups > 0:
                        print(f"{pet_name} gained {level_ups} level(s) and is now level {current_level}!")

                        # Initialize or upgrade pet stats
                        if "stats" not in user_data["pets"][pet_name]:
                            user_data["pets"][pet_name]["stats"] = {
                                "attack": 5,
                                "defense": 5,
                                "speed": 5
                            }

                        # Increase stats on level up
                        user_data["pets"][pet_name]["stats"]["attack"] += level_ups * 2
                        user_data["pets"][pet_name]["stats"]["defense"] += level_ups * 2
                        user_data["pets"][pet_name]["stats"]["speed"] += level_ups

                        print("Stats increased! New stats:")
                        for stat, value in user_data["pets"][pet_name]["stats"].items():
                            print(f"- {stat.title()}: {value}")

                        # Check if pet can learn new abilities
                        if current_level % 5 == 0:  # New ability every 5 levels
                            if "abilities" not in user_data["pets"][pet_name]:
                                user_data["pets"][pet_name]["abilities"] = []

                            # Example ability based on pet type
                            new_ability = f"Level {current_level} Ability"
                            user_data["pets"][pet_name]["abilities"].append(new_ability)
                            print(f"{CYAN}{pet_name} learned a new ability: {new_ability}!{ENDC}")
                    else:
                        remaining_exp = exp_needed - user_data["pets"][pet_name]["exp"]
                        print(f"{pet_name} gained experience. {remaining_exp} more EXP needed for next level.{ENDC}")

                    # Check for evolution eligibility
                    if pet_name in PET_EVOLUTIONS:
                        evolution = PET_EVOLUTIONS[pet_name]
                        if current_level >= evolution["level_required"] and user_data["pets"][pet_name].get("loyalty", 0) >= evolution["loyalty_required"]:
                            print(f"\n{MAGENTA}{pet_name} now meets the level and loyalty requirements for evolution!")
                            print(f"Visit the Pet Evolution Center to evolve it into a {evolution['evolves_to']}.{ENDC}")
                else:
                    print(f"\n{RED}You don't have enough gold for this training. You need {training['cost']} gold.{ENDC}")
            else:
                print(f"\n{RED}Invalid training selection.{ENDC}")
        else:
            print(f"\n{RED}Invalid pet selection.{ENDC}")
    except ValueError:
        print(f"\n{RED}Please enter a number.{ENDC}")

def set_active_regular_pet(user_data: Dict[str, Any]) -> None:
    """Set a regular pet as the active companion"""
    print(f"\n{BOLD}{CYAN}=== SET ACTIVE PET ==={ENDC}")

    # Check if user has any pets
    if not user_data.get("pets", {}):
        print(f"\n{YELLOW}You don't have any pets to set as active.{ENDC}")
        return

    # Display current active pet
    active_pet = user_data.get("active_pet", None)
    if active_pet:
        print(f"\n{GREEN}Current active pet: {active_pet}{ENDC}")
    else:
        print(f"\n{YELLOW}You don't have an active pet set.{ENDC}")

    # List user's pets
    print(f"\n{WHITE}Select a pet to make active:{ENDC}")

    pets = list(user_data["pets"].keys())
    for i, pet_name in enumerate(pets, 1):
        level = user_data["pets"][pet_name].get("level", 1)
        print(f"{i}. {pet_name} - Level: {level}")

    print("0. Cancel")

    choice = input("\nSelect a pet to set as active (or 0 to cancel): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(pets):
            pet_name = pets[index]
            user_data["active_pet"] = pet_name
            print(f"\n{GREEN}{pet_name} is now your active pet! It will follow you on your adventures.{ENDC}")

            # Apply pet bonuses based on level and stats
            pet_level = user_data["pets"][pet_name].get("level", 1)

            if "stats" in user_data["pets"][pet_name]:
                pet_stats = user_data["pets"][pet_name]["stats"]
                print(f"\n{CYAN}Your level {pet_level} pet provides the following bonuses:{ENDC}")

                # Calculate bonuses - these are adjusted by pet level
                level_multiplier = 1.0 + (pet_level * 0.05)  # 5% bonus per level
                attack_bonus = int(pet_stats.get("attack", 0) * 0.1 * level_multiplier)
                defense_bonus = int(pet_stats.get("defense", 0) * 0.1 * level_multiplier)
                speed_bonus = int(pet_stats.get("speed", 0) * 0.05)  # 5% of pet's speed adds to player

                if attack_bonus > 0:
                    print(f"Attack: +{attack_bonus}")
                if defense_bonus > 0:
                    print(f"Defense: +{defense_bonus}")
                if speed_bonus > 0:
                    print(f"Speed: +{speed_bonus}")

                # Apply special bonuses based on pet type
                if "Dragon" in pet_name:
                    print("Fire Resistance: +10%")
                elif "Wolf" in pet_name or "Dog" in pet_name:
                    print("Increased item find chance: +5%")
                elif "Cat" in pet_name or "Panther" in pet_name:
                    print("Night Vision: Can see in dark areas")
            else:
                print(f"\n{CYAN}Your pet provides company and occasional assistance in your journey.{ENDC}")
        else:
            print(f"\n{RED}Invalid pet selection.{ENDC}")
    except ValueError:
        print(f"\n{RED}Please enter a number.{ENDC}")

def pet_encyclopedia() -> None:
    """Redirects to the legendary pet encyclopedia for backwards compatibility"""
    legendary_pet_encyclopedia()

# Add this function to handle pet command in the main game
def handle_pet_command(user_data: Dict[str, Any], args: List[str]) -> None:
    """Handle the pet command and route to the proper pet management function"""
    manage_pets(user_data)

def interact_with_pet(user_data: Dict[str, Any]) -> None:
    """Interact with a legendary pet to increase bond and unlock new abilities"""
    # Check if user has any legendary pets
    if not user_data["legendary_pets"]:
        print(f"\n{YELLOW}You don't have any legendary pets to interact with yet.{ENDC}")
        return

    print(f"\n{BOLD}{CYAN}=== INTERACT WITH YOUR LEGENDARY PET ==={ENDC}")

    # Create a numbered list of owned pets
    owned_pets = list(user_data["legendary_pets"].keys())
    for i, pet_name in enumerate(owned_pets, 1):
        print(f"{i}. {pet_name}")

    print("0. Back")

    choice = input("\nSelect a pet to interact with (or 0 to go back): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(owned_pets):
            pet_name = owned_pets[index]
            pet_data = user_data["legendary_pets"][pet_name]

            # Get current bond level
            bond = pet_data.get("bond", 1)

            print(f"\n{BOLD}{BLUE}=== Interacting with {pet_name} ==={ENDC}")
            print(f"{WHITE}Current Bond Level: {bond}/10{ENDC}")

            # Interaction options
            print(f"\n{YELLOW}1. Feed{ENDC}")
            print(f"{YELLOW}2. Play{ENDC}")
            print(f"{YELLOW}3. Train{ENDC}")
            print(f"{YELLOW}4. Groom{ENDC}")
            print(f"{RED}0. Back{ENDC}")

            interaction = input("\nChoose how to interact: ")

            if interaction == "0":
                return

            if interaction in ["1", "2", "3", "4"]:
                # Check if can increase bond
                if bond < 10:
                    # 70% chance to increase bond
                    if random.random() < 0.7:
                        pet_data["bond"] = bond + 1
                        print(f"\n{GREEN}Your bond with {pet_name} has increased to {pet_data['bond']}/10!{ENDC}")

                        # Check for bond level milestones
                        if pet_data["bond"] == 3:
                            print(f"\n{CYAN}Your {pet_name} now trusts you more and will be more effective in battle.{ENDC}")
                        elif pet_data["bond"] == 5:
                            print(f"\n{CYAN}Your {pet_name} has learned to coordinate with you perfectly, increasing your combat effectiveness.{ENDC}")
                        elif pet_data["bond"] == 8:
                            print(f"\n{CYAN}Your {pet_name} has developed a special connection with you, unlocking a unique ability!{ENDC}")
                        elif pet_data["bond"] == 10:
                            print(f"\n{CYAN}You've reached maximum bond with your {pet_name}! All of its abilities are now fully powered.{ENDC}")
                    else:
                        print(f"\n{YELLOW}{pet_name} enjoyed your attention, but your bond remains at {bond}/10.{ENDC}")
                else:
                    print(f"\n{CYAN}Your bond with {pet_name} is already at maximum (10/10)!{ENDC}")

                # Display interaction result based on choice
                if interaction == "1":  # Feed
                    print(f"\n{WHITE}You offered {pet_name} its favorite food. It happily devoured it all!{ENDC}")
                elif interaction == "2":  # Play
                    print(f"\n{WHITE}You spent time playing with {pet_name}. It seems to really enjoy your company!{ENDC}")
                elif interaction == "3":  # Train
                    print(f"\n{WHITE}You trained with {pet_name}, helping it become stronger and more skilled.{ENDC}")
                elif interaction == "4":  # Groom
                    print(f"\n{WHITE}You carefully groomed {pet_name}. It looks magnificent now!{ENDC}")
            else:
                print(f"{RED}Invalid option. Please try again.{ENDC}")
        else:
            print(f"{RED}Invalid selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def set_active_pet(user_data: Dict[str, Any]) -> None:
    """Set a legendary pet as the active companion"""
    # Check if user has any legendary pets
    if not user_data["legendary_pets"]:
        print(f"\n{YELLOW}You don't have any legendary pets to set as active.{ENDC}")
        return

    print(f"\n{BOLD}{CYAN}=== SET ACTIVE LEGENDARY PET ==={ENDC}")
    print(f"{WHITE}Your active pet will provide its bonuses and accompany you on your adventures.{ENDC}")

    # Display current active pet
    active_pet = user_data.get("active_legendary_pet", None)
    if active_pet:
        print(f"\n{GREEN}Current active pet: {active_pet}{ENDC}")
    else:
        print(f"\n{YELLOW}You don't have an active legendary pet set.{ENDC}")

    # Create a numbered list of owned pets
    owned_pets = list(user_data["legendary_pets"].keys())
    for i, pet_name in enumerate(owned_pets, 1):
        print(f"{i}. {pet_name}")

    print("0. Back")

    choice = input("\nSelect a pet to set as active (or 0 to go back): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(owned_pets):
            pet_name = owned_pets[index]
            user_data["active_legendary_pet"] = pet_name
            print(f"\n{GREEN}{pet_name} is now your active legendary pet!{ENDC}")
        else:
            print(f"{RED}Invalid selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def obtain_legendary_pet(user_data: Dict[str, Any], pet_name: str) -> None:
    """Add a legendary pet to the player's collection"""
    # Check if pet exists in the legendary pets database
    if pet_name not in LEGENDARY_PETS:
        return

    # Check if player already has this pet
    if pet_name in user_data["legendary_pets"]:
        return

    # Initialize the pet in player's collection
    user_data["legendary_pets"][pet_name] = {
        "level": 1,
        "bond": 1,
        "element": LEGENDARY_PETS[pet_name]["element"],
        "acquired_date": "Day " + str(user_data.get("game_days", 1))
    }

    # Display acquisition message
    print(f"\n{BOLD}{CYAN}*** LEGENDARY PET ACQUIRED ***{ENDC}")
    print(f"\n{GREEN}You have obtained {pet_name}, a legendary pet!{ENDC}")
    print(f"\n{BLUE}{LEGENDARY_PETS[pet_name]['appearance']}{ENDC}")

    # Offer to set as active pet
    if not user_data.get("active_legendary_pet"):
        user_data["active_legendary_pet"] = pet_name
        print(f"\n{GREEN}{pet_name} has been automatically set as your active legendary pet!{ENDC}")

# Sailing and Ship Functions
def manage_sailing(user_data: Dict[str, Any]) -> None:
    """Main sailing interface"""
    # Initialize ships and navigation if not present
    if "ships" not in user_data:
        user_data["ships"] = {}
    if "navigation" not in user_data:
        user_data["navigation"] = {
            "maps": ["Sealtea Map"],
            "discovered_regions": ["Sealtea"],
            "ocean_routes": []
        }

    while True:
        print(f"\n{BOLD}{CYAN}=== SAILING & NAVIGATION ===")
        print(f"\n{WHITE}Explore the vast oceans and discover new lands with your ships.")

        # Display options
        print(f"\n{YELLOW}1. View Your Ships")
        print(f"{YELLOW}2. Purchase a Ship")
        print(f"{YELLOW}3. Repair Ship")
        print(f"{YELLOW}4. Set Sail")
        print(f"{YELLOW}5. View Maps")
        print(f"{YELLOW}6. Ship Encyclopedia")
        print(f"{RED}0. Back to Main Menu")

        choice = input("\nEnter your choice: ")

        if choice == "1":
            view_owned_ships(user_data)
        elif choice == "2":
            purchase_ship(user_data)
        elif choice == "3":
            repair_ship(user_data)
        elif choice == "4":
            sail(user_data)
        elif choice == "5":
            view_maps(user_data)
        elif choice == "6":
            ship_encyclopedia()
        elif choice == "0":
            break
        else:
            print(f"{RED}Invalid option. Please try again.{ENDC}")

def view_owned_ships(user_data: Dict[str, Any]) -> None:
    """Display all ships owned by the player"""
    print(f"\n{BOLD}{CYAN}=== YOUR SHIPS ===")

    # Check if user has any ships
    if not user_data["ships"]:
        print(f"\n{YELLOW}You don't own any ships yet. Visit Navigator's Port to purchase your first vessel!")
        return

    # Display each owned ship
    for ship_key, ship_data in user_data["ships"].items():
        ship_type = ship_data["type"]
        ship_name = ship_data.get("name", ship_type)
        # Display ship key/id for reference when selecting ships
        print(f"\nShip ID: {ship_key}")

        # Get color based on ship condition
        condition_percent = ship_data["durability"] / SHIPS[ship_type]["durability"] * 100
        if condition_percent > 75:
            condition_color = GREEN
        elif condition_percent > 40:
            condition_color = YELLOW
        else:
            condition_color = RED

        # Display ship details
        print(f"\n{BLUE}{BOLD}{ship_name} ({ship_type})")
        print(f"{WHITE}Condition: {condition_color}{ship_data['durability']}/{SHIPS[ship_type]['durability']} ({int(condition_percent)}%){ENDC}")
        print(f"{WHITE}Speed: {ship_data.get('speed', SHIPS[ship_type]['speed'])}")
        print(f"{WHITE}Capacity: {ship_data.get('capacity', SHIPS[ship_type]['capacity'])} crew")

        # Display special features
        features = ship_data.get("special_features", SHIPS[ship_type]["special_features"])
        if features:
            print(f"{YELLOW}Special Features:")
            for feature in features:
                print(f"- {feature}")

        # Upgrades
        upgrades = ship_data.get("upgrades", [])
        if upgrades:
            print(f"{GREEN}Upgrades:")
            for upgrade in upgrades:
                print(f"- {upgrade}")

        print(f"\n{'-' * 40}")

def purchase_ship(user_data: Dict[str, Any]) -> None:
    """Interface for purchasing new ships"""
    print(f"\n{BOLD}{CYAN}=== PURCHASE A SHIP ===")
    print(f"{WHITE}Available ships for purchase:")

    # Check if player is in Navigator's Port
    if user_data.get("current_area") != "Navigator's Port":
        print(f"\n{RED}You must be at Navigator's Port to purchase a ship.{ENDC}")
        return

    # Display available ships
    available_ships = []
    for i, (ship_type, ship_data) in enumerate(SHIPS.items(), 1):
        # Check level requirement
        if user_data["level"] >= ship_data["required_level"]:
            available_ships.append(ship_type)

            # Determine if player can afford it
            can_afford = user_data["gold"] >= ship_data["cost"]
            price_color = GREEN if can_afford else RED

            print(f"\n{i}. {BLUE}{ship_type} - {price_color}{ship_data['cost']} gold{ENDC}")
            print(f"   {WHITE}{ship_data['description']}")
            print(f"   Speed: {ship_data['speed']} | Durability: {ship_data['durability']} | Capacity: {ship_data['capacity']}")

            # Special features
            if ship_data["special_features"]:
                features_text = ", ".join(ship_data["special_features"])
                print(f"   {YELLOW}Features: {features_text}")

            # Required materials
            print(f"   {CYAN}Required Materials:")
            for material, amount in ship_data["required_materials"].items():
                has_enough = user_data.get("materials", {}).get(material, 0) >= amount
                material_color = GREEN if has_enough else RED
                print(f"   - {material}: {material_color}{amount}{ENDC}")

    if not available_ships:
        print(f"\n{RED}There are no ships available at your current level. Return when you've gained more experience.{ENDC}")
        return

    print(f"\n{RED}0. Cancel Purchase{ENDC}")

    choice = input("\nEnter the number of the ship you wish to purchase (or 0 to cancel): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(available_ships):
            ship_type = available_ships[index]
            ship_data = SHIPS[ship_type]

            # Check if player can afford the ship
            if user_data["gold"] < ship_data["cost"]:
                print(f"\n{RED}You don't have enough gold to purchase this ship.{ENDC}")
                return

            # Check if player has required materials
            for material, amount in ship_data["required_materials"].items():
                if user_data.get("materials", {}).get(material, 0) < amount:
                    print(f"\n{RED}You don't have enough {material} to build this ship.{ENDC}")
                    return

            # Generate unique ship ID
            ship_id = f"{ship_type.lower().replace(' ', '_')}_{len(user_data['ships']) + 1}"

            # Prompt for ship name
            ship_name = input(f"\n{YELLOW}What would you like to name your new {ship_type}? {ENDC}")
            if not ship_name.strip():
                ship_name = f"{ship_type} {len(user_data['ships']) + 1}"

            # Deduct gold and materials
            user_data["gold"] -= ship_data["cost"]
            for material, amount in ship_data["required_materials"].items():
                user_data["materials"][material] -= amount

            # Add ship to player's ships
            user_data["ships"][ship_id] = {
                "type": ship_type,
                "name": ship_name,
                "durability": ship_data["durability"],
                "speed": ship_data["speed"],
                "capacity": ship_data["capacity"],
                "special_features": ship_data["special_features"].copy(),
                "upgrades": [],
                "purchase_date": f"Day {user_data.get('game_days', 1)}"
            }

            print(f"\n{GREEN}Congratulations! You are now the proud owner of {ship_name}, a {ship_type}!")
            print(f"The Harbormaster hands you the deed and wishes you safe travels.{ENDC}")
        else:
            print(f"{RED}Invalid selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def repair_ship(user_data: Dict[str, Any]) -> None:
    """Interface for repairing ships"""
    print(f"\n{BOLD}{CYAN}=== REPAIR SHIP ===")

    # Check if player is at a port
    current_area = user_data.get("current_area", "")
    is_at_port = "Port" in current_area or "Harbor" in current_area

    if not is_at_port:
        print(f"\n{RED}You need to be at a port or harbor to repair your ships.{ENDC}")
        return

    # Check if user has any ships
    if not user_data["ships"]:
        print(f"\n{YELLOW}You don't own any ships to repair.{ENDC}")
        return

    # Display ships that need repair
    ships_to_repair = []
    for ship_id, ship_data in user_data["ships"].items():
        ship_type = ship_data["type"]
        max_durability = SHIPS[ship_type]["durability"]
        current_durability = ship_data["durability"]

        if current_durability < max_durability:
            ships_to_repair.append((ship_id, ship_data, max_durability - current_durability))

    if not ships_to_repair:
        print(f"\n{GREEN}All your ships are in perfect condition and don't need repairs.{ENDC}")
        return

    print(f"\n{WHITE}The following ships need repairs:")

    for i, (ship_id, ship_data, damage) in enumerate(ships_to_repair, 1):
        ship_type = ship_data["type"]
        ship_name = ship_data.get("name", ship_type)

        # Calculate repair cost - 5 gold per point of damage
        repair_cost = damage * 5

        # Determine if player can afford the repair
        can_afford = user_data["gold"] >= repair_cost
        price_color = GREEN if can_afford else RED

        print(f"\n{i}. {BLUE}{ship_name} ({ship_type})")
        print(f"   Condition: {ship_data['durability']}/{SHIPS[ship_type]['durability']}")
        print(f"   Repair Cost: {price_color}{repair_cost} gold{ENDC}")

    print(f"\n{RED}0. Cancel{ENDC}")

    choice = input("\nEnter the number of the ship you wish to repair (or 0 to cancel): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(ships_to_repair):
            ship_id, ship_data, damage = ships_to_repair[index]
            repair_cost = damage * 5

            # Check if player can afford the repair
            if user_data["gold"] < repair_cost:
                print(f"\n{RED}You don't have enough gold for these repairs.{ENDC}")
                return

            # Process the repair
            user_data["gold"] -= repair_cost
            user_data["ships"][ship_id]["durability"] = SHIPS[ship_data["type"]]["durability"]

            ship_name = ship_data.get("name", ship_data["type"])
            print(f"\n{GREEN}The {ship_name} has been fully repaired and is ready to sail!{ENDC}")
        else:
            print(f"{RED}Invalid selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def sail(user_data: Dict[str, Any]) -> None:
    """Main sailing function - allows player to travel between regions by sea or sky"""
    print(f"\n{BOLD}{CYAN}=== SET SAIL ===")

    # Check player's location type (coastal or celestial gateway)
    current_area = user_data.get("current_area", "")
    coastal_areas = ["Navigator's Port", "Siren's Isle", "Volcano Island", "Whispering Reefs", "Frost Harbor"]
    celestial_areas = ["Gateway of Stars", "Divine Court", "Celestial Gardens", "Hall of Heroes", "The Great Forge"]

    # Determine navigation type based on location
    if current_area in coastal_areas:
        navigation_type = "sea"
    elif current_area in celestial_areas:
        navigation_type = "ethereal"
    else:
        print(f"\n{RED}You need to be at a coastal location or celestial gateway to set sail.{ENDC}")
        return

    # Check if player has a ship/vessel
    if not user_data["ships"]:
        print(f"\n{RED}You need a ship to sail. Visit Navigator's Port to purchase one.{ENDC}")
        return

    # Check for celestial navigation skill if trying to navigate ethereal space
    if navigation_type == "ethereal":
        if "celestial_navigation" not in user_data.get("skills", {}):
            print(f"\n{YELLOW}You need the Celestial Navigation skill to traverse the Ethereal Realm.")
            print(f"Visit the Star Cartographer at Gateway of Stars to learn this skill.{ENDC}")
            return

    # Check if player has appropriate maps
    if not user_data["navigation"]["maps"]:
        print(f"\n{RED}You need a map to navigate. You can purchase maps at port settlements or from the Star Cartographer.{ENDC}")
        return

    # Check for ethereal map if navigating ethereal space
    if navigation_type == "ethereal" and "Ethereal Map" not in user_data["navigation"]["maps"]:
        print(f"\n{RED}You need an Ethereal Map to navigate the divine realms. Visit the Star Cartographer.{ENDC}")
        return

    # Select ship to sail with
    print(f"\n{WHITE}Select a ship for your journey:")

    available_ships = []
    for ship_id, ship_data in user_data["ships"].items():
        # Only show ships with durability > 0
        if ship_data["durability"] > 0:
            available_ships.append((ship_id, ship_data))

    if not available_ships:
        print(f"\n{RED}All your ships are too damaged to sail. Repair them first.{ENDC}")
        return

    for i, (ship_id, ship_data) in enumerate(available_ships, 1):
        ship_type = ship_data["type"]
        ship_name = ship_data.get("name", ship_type)

        # Show durability as a percentage
        durability_percent = int(ship_data["durability"] / SHIPS[ship_type]["durability"] * 100)

        # Color based on durability
        if durability_percent > 75:
            durability_color = GREEN
        elif durability_percent > 40:
            durability_color = YELLOW
        else:
            durability_color = RED

        # Show realm compatibility
        ship_type = ship_data["type"]
        ship_realm = SHIPS[ship_type].get("realm", "Sea")
        realm_text = ""

        if ship_realm == "Sea":
            realm_text = f"{CYAN}[Sea Vessel]{ENDC}"
        elif ship_realm == "Ethereal":
            realm_text = f"{MAGENTA}[Ethereal Skyship]{ENDC}"
        elif ship_realm == "All":
            realm_text = f"{YELLOW}[Divine Vessel]{ENDC}"

        print(f"{i}. {BLUE}{ship_name} - {durability_color}Condition: {durability_percent}%{ENDC} | Speed: {ship_data['speed']} {realm_text}")

    print(f"{RED}0. Cancel{ENDC}")

    ship_choice = input("\nChoose a ship (or 0 to cancel): ")

    if ship_choice == "0":
        return

    try:
        ship_index = int(ship_choice) - 1
        if 0 <= ship_index < len(available_ships):
            chosen_ship_id, chosen_ship = available_ships[ship_index]

            # Select destination
            print(f"\n{WHITE}Select your destination:")

            # Get ship realm capability
            chosen_ship_type = chosen_ship["type"]
            ship_realm = SHIPS[chosen_ship_type].get("realm", "Sea")

            # Find potential destinations based on maps and ship capabilities
            available_destinations = []

            if navigation_type == "sea":
                # Check all coastal areas except current area
                for area in coastal_areas:
                    if area != current_area:
                        region = next((r for r, data in WORLD_REGIONS.items() if area in data["areas"]), None)

                        # Check if player has map for this region
                        if region and f"{region} Map" in user_data["navigation"]["maps"]:
                            available_destinations.append((area, region))

                if not available_destinations:
                    print(f"\n{RED}You don't have maps for any other coastal destinations.{ENDC}")
                    return
            else:  # ethereal navigation
                # Check celestial navigation skill
                if "celestial_navigation" not in user_data.get("skills", {}):
                    print(f"\n{RED}You need the Celestial Navigation skill to travel to ethereal destinations.{ENDC}")
                    return

                # Check if ship can travel to ethereal realm
                if ship_realm not in ["Ethereal", "All"]:
                    print(f"\n{RED}Your vessel cannot travel to the Ethereal Realm. You need a ship with Ethereal capabilities.{ENDC}")
                    return

                # Check all ethereal areas except current area
                for area in celestial_areas:
                    if area != current_area:
                        region = "Ethereal Realm"

                        # Check if player has ethereal map
                        if "Ethereal Realm Map" in user_data["navigation"]["maps"]:
                            available_destinations.append((area, region))

                if not available_destinations:
                    print(f"\n{RED}You don't have maps for any other ethereal destinations.{ENDC}")
                    return

            for i, (area, region) in enumerate(available_destinations, 1):
                # Calculate journey difficulty (1-5)
                journey_length = random.randint(2, 5)  # Based on region distance
                journey_danger = random.randint(1, 5)  # Based on region dangers

                # Journey time based on ship speed
                journey_time = max(1, journey_length // chosen_ship["speed"])

                print(f"{i}. {GREEN}{area} ({region}){ENDC}")
                print(f"   Journey Length: {YELLOW}{'★' * journey_length}{ENDC}")
                print(f"   Danger Level: {RED}{'★' * journey_danger}{ENDC}")
                print(f"   Estimated Travel Time: {journey_time} days")

            print(f"{RED}0. Cancel{ENDC}")

            dest_choice = input("\nChoose your destination (or 0 to cancel): ")

            if dest_choice == "0":
                return

            try:
                dest_index = int(dest_choice) - 1
                if 0 <= dest_index < len(available_destinations):
                    destination, destination_region = available_destinations[dest_index]

                    # Journey time calculation
                    journey_length = random.randint(2, 5)
                    journey_time = max(1, journey_length // chosen_ship["speed"])

                    print(f"\n{BOLD}{CYAN}=== JOURNEY TO {destination.upper()} ===")
                    print(f"\n{WHITE}You set sail from {current_area} toward {destination}.")
                    print(f"The journey will take approximately {journey_time} days.")
                    print(f"Your {chosen_ship['name']} cuts through the waves as you leave the harbor...")

                    # Simulate journey with events
                    journey_success = True
                    for day in range(1, journey_time + 1):
                        print(f"\n{YELLOW}=== Day {day} of {journey_time} ===")

                        # Random ocean event (70% chance)
                        if random.random() < 0.7:
                            # Choose random event based on probability
                            event_roll = random.random()
                            cumulative_prob = 0
                            chosen_event = None

                            for event_id, event_data in OCEAN_EVENTS.items():
                                cumulative_prob += event_data["probability"]
                                if event_roll <= cumulative_prob:
                                    chosen_event = event_id
                                    break

                            if chosen_event:
                                event = OCEAN_EVENTS[chosen_event]
                                print(f"\n{BOLD}{CYAN}{event['name']}!")
                                print(f"{WHITE}{event['description']}")
                                print(f"{YELLOW}Effect: {event['effect']}")

                                # Handle event effects
                                if chosen_event == "calm":
                                    # Heal player slightly
                                    heal_amount = int(user_data["max_health"] * 0.1)
                                    user_data["health"] = min(user_data["max_health"], user_data["health"] + heal_amount)
                                    print(f"\n{GREEN}The calm seas allow you to rest. You recover {heal_amount} health.{ENDC}")

                                elif chosen_event == "storm":
                                    # Damage ship
                                    damage = random.randint(5, 15)
                                    user_data["ships"][chosen_ship_id]["durability"] = max(1, user_data["ships"][chosen_ship_id]["durability"] - damage)
                                    print(f"\n{RED}Your ship takes {damage} damage from the violent storm!{ENDC}")

                                elif chosen_event == "pirates":
                                    # Simple simulation of pirate encounter
                                    print(f"\n{RED}You engage in battle with the pirates!{ENDC}")
                                    if random.random() < 0.6:  # 60% chance to win
                                        print(f"{GREEN}You successfully fend off the pirates!{ENDC}")

                                        # Gain loot
                                        gold_found = random.randint(50, 200)
                                        user_data["gold"] += gold_found
                                        print(f"{YELLOW}You find {gold_found} gold from the defeated pirates.{ENDC}")
                                    else:
                                        # Take damage to ship and player
                                        ship_damage = random.randint(10, 25)
                                        user_data["ships"][chosen_ship_id]["durability"] = max(1, user_data["ships"][chosen_ship_id]["durability"] - ship_damage)

                                        player_damage = random.randint(5, 15)
                                        user_data["health"] = max(1, user_data["health"] - player_damage)

                                        print(f"{RED}The pirates damage your ship and crew before retreating!")
                                        print(f"Ship damage: {ship_damage} | Your health: -{player_damage}{ENDC}")

                                elif chosen_event == "sea_monster":
                                    # Simulate sea monster encounter
                                    print(f"\n{RED}A massive sea creature attacks your ship!{ENDC}")

                                    # Outcome depends on ship type and durability
                                    if "War Galleon" in chosen_ship["type"] or "Arcane Schooner" in chosen_ship["type"]:
                                        if random.random() < 0.7:  # 70% chance to defeat with powerful ships
                                            print(f"{GREEN}Your well-equipped ship allows you to defeat the monster!{ENDC}")

                                            # Add rare material as reward
                                            if "materials" not in user_data:
                                                user_data["materials"] = {}

                                            rare_materials = ["Sea Monster Hide", "Monster Tooth", "Abyssal Scale"]
                                            material = random.choice(rare_materials)
                                            amount = random.randint(1, 3)

                                            if material not in user_data["materials"]:
                                                user_data["materials"][material] = 0
                                            user_data["materials"][material] += amount

                                            print(f"{YELLOW}You collect {amount} {material} from the defeated monster.{ENDC}")
                                        else:
                                            # Major damage to ship
                                            ship_damage = random.randint(30, 50)
                                            user_data["ships"][chosen_ship_id]["durability"] = max(1, user_data["ships"][chosen_ship_id]["durability"] - ship_damage)
                                            print(f"{RED}The monster severely damages your ship before retreating to the depths!{ENDC}")
                                    else:
                                        # Weaker ships fare worse
                                        if random.random() < 0.3:  # 30% chance to escape unharmed
                                            print(f"{GREEN}Through skillful maneuvering, you manage to escape the monster!{ENDC}")
                                        else:
                                            # Major damage to ship
                                            ship_damage = random.randint(40, 70)
                                            user_data["ships"][chosen_ship_id]["durability"] = max(1, user_data["ships"][chosen_ship_id]["durability"] - ship_damage)

                                            # Player takes damage too
                                            player_damage = random.randint(10, 25)
                                            user_data["health"] = max(1, user_data["health"] - player_damage)

                                            print(f"{RED}The monster batters your ship and injures several crew members!")
                                            print(f"Ship damage: {ship_damage} | Your health: -{player_damage}{ENDC}")

                                # Handle more events as needed...
                        else:
                            print(f"{WHITE}You have an uneventful day of sailing.{ENDC}")

                        # Check if ship is severely damaged
                        if user_data["ships"][chosen_ship_id]["durability"] < SHIPS[chosen_ship["type"]]["durability"] * 0.2:
                            print(f"\n{RED}WARNING: {chosen_ship['name']} is severely damaged and at risk of sinking!{ENDC}")

                            # 10% chance of sinking if below 20% durability
                            if random.random() < 0.1:
                                print(f"\n{RED}DISASTER! Your ship has been torn apart by the harsh conditions!")
                                print(f"You and your crew barely make it to a lifeboat and drift for days...{ENDC}")

                                # Remove ship from inventory
                                del user_data["ships"][chosen_ship_id]

                                # 50% chance to lose the journey completely and wash up somewhere random
                                if random.random() < 0.5:
                                    random_locations = ["Greenwood Village", "Navigator's Port", "Frost Harbor"]
                                    random_destination = random.choice(random_locations)

                                    print(f"\n{YELLOW}After days adrift, you wash ashore near {random_destination}.{ENDC}")
                                    user_data["current_area"] = random_destination

                                    # Take damage
                                    damage = random.randint(20, 40)
                                    user_data["health"] = max(1, user_data["health"] - damage)

                                    print(f"{RED}You suffered {damage} damage from exposure and lack of supplies.{ENDC}")
                                    journey_success = False
                                    break

                        # Pause between days
                        input("\nPress Enter to continue...")

                    # Journey complete
                    if journey_success:
                        print(f"\n{BOLD}{GREEN}=== LAND HO! ===")
                        print(f"\n{WHITE}After {journey_time} days at sea, you arrive safely at {destination}.")

                        # Update player location
                        user_data["current_area"] = destination

                        # Add region to discovered regions if not already there
                        if destination_region not in user_data["navigation"]["discovered_regions"]:
                            user_data["navigation"]["discovered_regions"].append(destination_region)
                            print(f"\n{CYAN}You've discovered a new region: {destination_region}!{ENDC}")

                        # Add ocean route to known routes
                        route = f"{current_area} to {destination}"
                        reverse_route = f"{destination} to {current_area}"

                        if route not in user_data["navigation"]["ocean_routes"] and reverse_route not in user_data["navigation"]["ocean_routes"]:
                            user_data["navigation"]["ocean_routes"].append(route)
                            print(f"\n{YELLOW}You've charted a new ocean route: {route}{ENDC}")
                else:
                    print(f"{RED}Invalid destination selection.{ENDC}")
            except ValueError:
                print(f"{RED}Please enter a number.{ENDC}")
        else:
            print(f"{RED}Invalid ship selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def view_maps(user_data: Dict[str, Any]) -> None:
    """View maps and discovered regions"""
    print(f"\n{BOLD}{CYAN}=== MAPS & DISCOVERED REGIONS ===")

    # Show maps
    print(f"\n{YELLOW}Maps in your possession:")
    if user_data["navigation"]["maps"]:
        for map_name in user_data["navigation"]["maps"]:
            print(f"- {map_name}")
    else:
        print(f"{RED}You don't have any maps.{ENDC}")

    # Show discovered regions
    print(f"\n{GREEN}Regions you've discovered:")
    if user_data["navigation"]["discovered_regions"]:
        for region in user_data["navigation"]["discovered_regions"]:
            # Show description if available
            if region in WORLD_REGIONS:
                print(f"\n{BLUE}{region}: {WHITE}{WORLD_REGIONS[region]['description']}")

                # Show areas in this region
                areas = WORLD_REGIONS[region]["areas"]
                visited_areas = [area for area in areas if area in user_data.get("achievements", {}).get("progress", {}).get("areas_visited", set())]

                print(f"{YELLOW}Areas discovered: {len(visited_areas)}/{len(areas)}")
                for area in areas:
                    if area in visited_areas:
                        print(f"- {GREEN}{area} (Visited){ENDC}")
                    else:
                        print(f"- {RED}{area} (Undiscovered){ENDC}")
            else:
                print(f"- {region}")
    else:
        print(f"{RED}You haven't discovered any regions yet.{ENDC}")

    # Show charted routes
    print(f"\n{CYAN}Ocean routes you've charted:")
    if user_data["navigation"]["ocean_routes"]:
        for route in user_data["navigation"]["ocean_routes"]:
            print(f"- {route}")
    else:
        print(f"{RED}You haven't charted any ocean routes yet.{ENDC}")

def ship_encyclopedia() -> None:
    """Display information about all ship types"""
    print(f"\n{BOLD}{CYAN}=== SHIP ENCYCLOPEDIA ===")
    print(f"{WHITE}Learn about the various ship types available in the world.")

    # List all ship types
    print(f"\n{YELLOW}Available Ship Types:")

    for i, (ship_type, ship_data) in enumerate(SHIPS.items(), 1):
        print(f"{i}. {ship_type}")

    print(f"{RED}0. Back{ENDC}")

    choice = input("\nSelect a ship type to learn more about (or 0 to go back): ")

    if choice == "0":
        return

    try:
        index = int(choice) - 1
        if 0 <= index < len(SHIPS):
            ship_type = list(SHIPS.keys())[index]
            ship_data = SHIPS[ship_type]

            print(f"\n{BOLD}{BLUE}=== {ship_type} ===")
            print(f"\n{WHITE}{ship_data['description']}")

            print(f"\n{YELLOW}Statistics:")
            print(f"Speed: {ship_data['speed']}")
            print(f"Durability: {ship_data['durability']}")
            print(f"Capacity: {ship_data['capacity']} crew")

            print(f"\n{GREEN}Special Features:")
            if ship_data["special_features"]:
                for feature in ship_data["special_features"]:
                    print(f"- {feature}")
            else:
                print("None")

            print(f"\n{CYAN}Requirements:")
            print(f"Level: {ship_data['required_level']}+")
            print(f"Cost: {ship_data['cost']} gold")

            print(f"\n{RED}Required Materials:")
            for material, amount in ship_data["required_materials"].items():
                print(f"- {material}: {amount}")

            input("\nPress Enter to continue...")
        else:
            print(f"{RED}Invalid selection.{ENDC}")
    except ValueError:
        print(f"{RED}Please enter a number.{ENDC}")

def clear_screen() -> None:
    """Clear the terminal screen"""
    os.system('cls' if os.name == 'nt' else 'clear')

# Color constants - using colorama named colors for cross-platform compatibility
OKBLUE = Fore.BLUE
OKGREEN = Fore.GREEN
WARNING = Fore.YELLOW
FAIL = Fore.RED
ENDC = Style.RESET_ALL
BOLD = Style.BRIGHT
LIGHTGRAY = Fore.LIGHTWHITE_EX
LIGHTCYAN = Fore.LIGHTCYAN_EX
MAGENTA = Fore.MAGENTA
UNDERLINE = Style.BRIGHT  # Closest alternative in colorama (original was '\033[4m')
SUCCESS = Fore.LIGHTGREEN_EX  # Added for success messages
HEADER = Fore.MAGENTA + Style.BRIGHT  # Header formatting

# Aliases for consistency
BLUE = OKBLUE
GREEN = OKGREEN
RED = FAIL
YELLOW = WARNING
CYAN = LIGHTCYAN
WHITE = LIGHTGRAY
GREEN = Fore.GREEN
BLUE = Fore.BLUE
WHITE = Fore.WHITE
BLACK = Fore.BLACK
GREY = Fore.BLACK + Style.DIM
DARKGRAY = Fore.BLACK + Style.BRIGHT  # Using bright black for dark gray
PURPLE = Fore.MAGENTA  # Using MAGENTA for purple
# LIGHTCYAN already defined above
LIGHTYELLOW = Fore.YELLOW + Style.BRIGHT
LIGHTRED = Fore.RED + Style.BRIGHT
LIGHTGREEN = Fore.GREEN + Style.BRIGHT
LIGHTBLUE = Fore.BLUE + Style.BRIGHT
LIGHTMAGENTA = Fore.MAGENTA + Style.BRIGHT
BG_BLACK = Back.BLACK
BG_RED = Back.RED
BG_GREEN = Back.GREEN
BG_YELLOW = Back.YELLOW
BG_BLUE = Back.BLUE
BG_MAGENTA = Back.MAGENTA
BG_CYAN = Back.CYAN
BG_WHITE = Back.WHITE
BG_GREY = Back.BLACK + Style.DIM
BG_LIGHTRED = Back.RED + Style.BRIGHT
BG_LIGHTGREEN = Back.GREEN + Style.BRIGHT
BG_LIGHTYELLOW = Back.YELLOW + Style.BRIGHT
BG_LIGHTBLUE = Back.BLUE + Style.BRIGHT
BG_LIGHTMAGENTA = Back.MAGENTA + Style.BRIGHT
BG_LIGHTCYAN = Back.CYAN + Style.BRIGHT
BG_BRIGHTWHITE = Back.WHITE + Style.BRIGHT

# Special effects (some not available in colorama but included for compatibility)
DIM = Style.DIM  # Dim/faint text
ITALIC = ""  # Not available in colorama
REVERSE = Style.RESET_ALL  # Not directly available
BLINK = ""  # Not available in colorama 
HIDDEN = ""  # Not available in colorama
STRIKETHROUGH = ""  # Not available in colorama

# Constants
INITIAL_GOLD = 100
INITIAL_HEALTH = 100
EXP_TO_LEVEL = 100
CRITICAL_CHANCE = 0.15
DODGE_CHANCE = 0.1
TICKS_PER_DAY = 50
# Only action commands take time (ticks)
TICK_COMMANDS = {
    '/gather': (3, 5),
    '/farm': (2, 4),
    '/fight': (4, 8), 
    '/craft': (3, 6),
    '/dungeon': (8, 15),
    '/travel': (5, 10),
    '/search': (2, 4),
    '/find_key': (3, 6),
    '/excavate': (4, 7),
    '/dig': (3, 6),
    '/analyze': (2, 4)
}

# Commands that don't take time
NO_TICK_COMMANDS = {'/help', '/stats', '/h', '/s_t', '/inventory', '/i', '/materials', 
                   '/m', '/quests', '/q', '/save', '/load', '/prefix', '/settings',
                   '/bestiary', '/weapon_info', '/location', '/location_check',
                   '/professions', '/dungeon_list', '/mobs', '/tip', '/codes',
                   '/support', '/exit', '/x', '/dimensions', '/dim', '/camp',
                   '/camp_build', '/camp_repair', '/camp_use', '/camp_demolish', '/camp_info',
                   '/return_home', '/weather', '/season', '/archaeology', '/arch',
                   '/artifacts', '/relics', '/ancient_knowledge'}

# Game time tracking
# Weather system
WEATHERS = {
    "clear": {
        "name": "Clear",
        "description": "Clear skies and pleasant temperatures.",
        "crop_growth_modifier": 1.0,
        "color": BLUE,
        "rarity": 0.30
    },
    "sunny": {
        "name": "Sunny",
        "description": "Bright sunshine warms the land.",
        "crop_growth_modifier": 1.2,  # Crops grow faster in sun
        "color": OKGREEN,
        "rarity": 0.20
    },
    "cloudy": {
        "name": "Cloudy",
        "description": "Gray clouds hang overhead, blocking the sun.",
        "crop_growth_modifier": 0.9,  # Slight slowdown
        "color": LIGHTGRAY, 
        "rarity": 0.15
    },
    "rainy": {
        "name": "Rainy",
        "description": "Rain falls steadily from the sky.",
        "crop_growth_modifier": 1.5,  # Rain helps most crops
        "color": CYAN,
        "rarity": 0.15
    },
    "stormy": {
        "name": "Stormy",
        "description": "Lightning flashes as a storm rages.",
        "crop_growth_modifier": 0.7,  # Storms damage some crops
        "color": PURPLE,
        "rarity": 0.07
    },
    "windy": {
        "name": "Windy",
        "description": "Strong winds blow across the land.",
        "crop_growth_modifier": 0.8,  # Wind can damage delicate crops
        "color": YELLOW,
        "rarity": 0.08
    },
    "foggy": {
        "name": "Foggy",
        "description": "A thick fog obscures visibility.",
        "crop_growth_modifier": 0.9,  # Slight slowdown
        "color": WHITE,
        "rarity": 0.05
    }
}

# Special weathers for dimensions
DIMENSION_WEATHERS = {
    "Celestial Realm": [
        {"name": "Cosmic Rain", "description": "Glowing stardust falls from the heavens.", "crop_growth_modifier": 2.0, "color": PURPLE},
        {"name": "Celestial Harmony", "description": "The stars align in perfect harmony.", "crop_growth_modifier": 1.8, "color": CYAN}
    ],
    "Shadow Realm": [
        {"name": "Darkness Storm", "description": "Swirling shadows block all light.", "crop_growth_modifier": 0.4, "color": DARKGRAY},
        {"name": "Void Mist", "description": "A mist that seems to absorb all life energy.", "crop_growth_modifier": 0.5, "color": PURPLE}
    ],
    "Elemental Plane": [
        {"name": "Elemental Surge", "description": "Raw elemental energies fill the air.", "crop_growth_modifier": 1.7, "color": RED},
        {"name": "Primal Storm", "description": "A chaotic storm of all elements.", "crop_growth_modifier": 0.6, "color": YELLOW}
    ],
    "Ancient Ruins": [
        {"name": "Time Flux", "description": "Reality shifts as time flows erratically.", "crop_growth_modifier": 1.3, "color": BLUE},
        {"name": "Arcane Winds", "description": "Magical winds carry remnants of ancient spells.", "crop_growth_modifier": 1.4, "color": MAGENTA}
    ]
}

game_state = {
    "current_tick": 0,
    "current_day": 0,
    "last_command_tick": 0,
    "current_weather": "clear",
    "weather_duration": 5,  # Weather changes every 5 game days by default
    "last_weather_change": 0
}

# NPCs and their dialogues
NPCS = {
    "Old Sage": {
        "location": "Greenwood Village",
        "dialogues": {
            "greeting": "Welcome, young adventurer. The world needs heroes now more than ever.",
            "quest": "Dark forces gather in the east. Will you help us?",
            "story": {
                "intro": "Long ago, our lands were peaceful...",
                "chapter1": "But then the Legion Of Darkness, once sealed underground, came back...",
                "chapter2": "Now we need a hero to unite everyone against the Legion Of Darkness like how the legendary heroes did to seal it..."
            },
            "additional": [
                "Legends speak of an ancient power hidden deep within the mountains.",
                "Remember, courage and wisdom will guide you through the darkest times."
            ]
        },
        "quests": ["Dragon Hunter", "Skeleton Cleanup"]
    },
    "Blacksmith": {
        "location": "Stormhaven",
        "dialogues": {
            "greeting": "Need weapons? I've got the finest steel in all the realms.",
            "quest": "If you bring me some iron ore, I can forge you special weapons.",
            "trade": "Take a look at my wares."
        },
        "quests": ["Iron Gatherer"],
        "shop": ["Iron Sword", "Steel Sword", "Iron Armor"]
    },
    "Mysterious Stranger": {
        "location": "Shadowmere",
        "dialogues": {
            "greeting": "Psst... seeking rare artifacts?",
            "quest": "The shadows hold many secrets... and treasures.",
            "warning": "Beware the Crimson Abyss... death awaits the unprepared.",
            "additional": [
                "There are secrets buried beneath the ruins, waiting to be uncovered.",
                "Trust no one, for the enemy may be closer than you think."
            ]
        },
        "quests": ["Shadow Walker"]
    },
    "Village Elder": {
        "location": "Greenwood Village",
        "dialogues": {
            "greeting": "Greetings, traveler. Our village has seen better days.",
            "quest": "We need help gathering herbs to heal the sick.",
            "story": "The forest holds many secrets, some better left undisturbed."
        },
        "quests": ["Herbal Remedy"]
    },
    "Merchant": {
        "location": "Stormhaven",
        "dialogues": {
            "greeting": "Looking for rare goods? You've come to the right place.",
            "trade": "I have wares from distant lands, take a look."
        },
        "shop": ["Exotic Spices", "Rare Gems", "Magic Potions"]
    },
    # New NPCs for Weather Mysteries questline
    "Weather Sage": {
        "location": "Mountain Peaks",
        "dialogues": {
            "greeting": "The winds speak to those who listen. I hear you've come seeking knowledge.",
            "quest": "The weather patterns have been disturbed lately. Something unnatural is at work.",
            "story": {
                "intro": "For generations, my family has studied the weather and its connection to the world's magic.",
                "chapter1": "Recently, the patterns have become erratic. I fear a malevolent force is manipulating nature itself.",
                "chapter2": "If we collect samples from different weather conditions, I might be able to trace the source of this disturbance."
            },
            "weather_lore": "Each type of weather carries its own magic. Thunderstorms hold the power of transformation, while snow preserves ancient energies."
        },
        "quests": ["The Weather Sage", "Collecting Weather Samples", "The Weather Anomaly", "Confronting the Storm Entity"]
    },
    "Storm Entity": {
        "location": "Ancient Forest",
        "dialogues": {
            "greeting": "You dare interrupt my work? The weather bends to MY will now!",
            "battle": "Your pathetic resistance ends here. The elements answer to me alone!",
            "defeat": "Impossible... how could a mere mortal harness such power? Perhaps... I was wrong..."
        },
        "monster": True,
        "boss": True,
        "element": "Storm",
        "quests": ["Confronting the Storm Entity"]
    },
    # New NPCs for Void Walker questline
    "Dimensional Scholar": {
        "location": "Grand Library",
        "dialogues": {
            "greeting": "Ah, an adventurer! Have you noticed the strange rifts appearing throughout the land?",
            "quest": "I've been documenting these dimensional anomalies. Would you help me collect data?",
            "story": {
                "intro": "The boundaries between dimensions have always been thin in certain places.",
                "chapter1": "But lately, something or someone has been purposely tearing holes between worlds.",
                "chapter2": "These aren't natural occurrences - they're deliberate incursions. We must find who's responsible."
            }
        },
        "quests": ["Strange Disturbances", "The Void Walker's Trail"]
    },
    "Dimension Guardian": {
        "location": "Dimensional Nexus",
        "dialogues": {
            "greeting": "HALT! None may pass beyond this point without proving their worth.",
            "battle": "The spaces between worlds are not meant for mortal travel. Turn back or face judgment!",
            "defeat": "You possess... unusual strength for one of your kind. Perhaps you are... the one prophesied."
        },
        "monster": True,
        "element": "Void",
        "quests": ["Dimensional Guardians"]
    },
    "Void Walker": {
        "location": "Dimensional Nexus Core",
        "dialogues": {
            "greeting": "So, you've found me at last. Few have the determination to follow my path.",
            "reveal": "I am not your enemy. I am trying to seal the dimensional wounds before HE returns.",
            "story": {
                "intro": "I was once a guardian like those you've defeated.",
                "chapter1": "But I discovered a terrible threat - an entity that consumes entire dimensions.",
                "chapter2": "It was sealed away millennia ago, but the seal weakens. I've been strengthening the barriers.",
                "chapter3": "Now that you know the truth, will you help me complete my work? Or will you stand against me?"
            }
        },
        "quests": ["The Void Walker's Identity"],
        "choices": {
            "ally": "I understand now. I'll help you protect the dimensions.",
            "oppose": "How can I trust you? Your methods have caused chaos across the realms."
        },
        "outcomes": {
            "ally": {"item": "Void Walker's Staff", "dimension_key": "Void Plane"},
            "oppose": {"item": "Dimensional Seal Fragment", "dimension_key": "Guardian Realm"}
        }
    },
    "Wandering Bard": {
        "location": "Dragon's Peak",
        "dialogues": {
            "greeting": "Songs of heroes and legends, care to listen?",
            "story": "They say the mountains echo with the voices of ancient dragons.",
            "quest": "Help me collect tales from the nearby villages."
        },
        "quests": ["Tales of the Mountain"]
    },
    "Resistant Underground Leader": {
        "location": "Iron Caliphate of Al-Khilafah Al-Hadidiyah",
        "dialogues": {
            "greeting": "We must act carefully. The Caliphate's spies are everywhere."
        },
        "quests": ["Sabotage Supply Lines", "Rescue Imprisoned Dissidents"],
        "reward": "Rare blueprints for crafting resistance gear"
    },
    "Sympathetic Guard": {
        "location": "Iron Caliphate of Al-Khilafah Al-Hadidiyah",
        "dialogues": {
            "greeting": "The lockdown... it wasn't always like this. Something changed the Caliph."
        },
        "quests": ["Infiltrate the Palace", "Recover Stolen Artifacts"],
        "reward": "Access to guarded areas, special weapons"
    },
    "Black Market Supplier": {
        "location": "Iron Caliphate of Al-Khilafah Al-Hadidiyah",
        "dialogues": {
            "greeting": "Need food? Medical supplies? The price is high, but so are the risks."
        },
        "shop": ["Rare food items", "Medicinal herbs", "Lock-picking tools"],
        "quests": ["Distract the Patrols", "Smuggle Supplies"]
    },
    "Ronin Mercenary": {
        "location": "Shogunate of Shirui",
        "dialogues": {
            "greeting": "Honor is a luxury I can no longer afford."
        },
        "quests": ["Assassinate a Corrupt Official", "Protect a Whistleblower"],
        "reward": "Unique samurai weapons, ronin armor"
    },
    "Imperial Spy": {
        "location": "Shogunate of Shirui",
        "dialogues": {
            "greeting": "The Shogun knows everything... or so he believes."
        },
        "quests": ["Infiltrate the Dojo", "Decode Intercepted Messages"],
        "reward": "Spy tools, intelligence network access"
    },
    "Shadow Broker": {
        "location": "Shadowmere",
        "dialogues": {
            "greeting": "Information costs more than gold here."
        },
        "quests": ["Retrieve Stolen Secrets", "Eliminate a Rival"],
        "reward": "Rare magic items, forbidden scrolls"
    },
    "Fallen Noble": {
        "location": "Shadowmere",
        "dialogues": {
            "greeting": "The darkness consumes everyone eventually."
        },
        "quests": ["Reclaim Family Heirlooms", "Exposing Corruption"],
        "reward": "Ancient family weapons, noble artifacts"
    },
    "Exiled Mage": {
        "location": "Frostvale",
        "dialogues": {
            "greeting": "Cold preserves... and destroys."
        },
        "quests": ["Contain the Ice Wraith", "Retrieve Magical Research"],
        "reward": "Ice-elemental weapons, frost-resistant gear"
    },
    "Survival Guide": {
        "location": "Frostvale",
        "dialogues": {
            "greeting": "In Frostvale, respect the elements or perish."
        },
        "quests": ["Hunt Polar Creatures", "Establish a Safe House"],
        "reward": "Survival kits, cold-weather armor"
    },
    "Dragon Egg Collector": {
        "location": "Dragon's Peak",
        "dialogues": {
            "greeting": "A dragon's power begins with its egg."
        },
        "quests": ["Retrieve a Specific Egg", "Protect a Nest"],
        "reward": "Dragon egg fragments (crafting materials), rare mounts"
    },
    "Mountain Guide": {
        "location": "Dragon's Peak",
        "dialogues": {
            "greeting": "Without a guide, the mountains will bury you."
        },
        "quests": ["Map New Routes", "Rescue Lost Climbers"],
        "reward": "Mountaineering gear, map fragments"
    },
    "Dragon Lore Scholar": {
        "location": "Long Shui Zhen",
        "dialogues": {
            "greeting": "Dragons are not just beasts—they are history."
        },
        "quests": ["Decode Ancient Dragon Texts", "Find a Legendary Dragon"],
        "reward": "Knowledge-based items, dragon lore books"
    },
    "Martial Arts Rival": {
        "location": "Long Shui Zhen",
        "dialogues": {
            "greeting": "Your form is weak. Let me correct you."
        },
        "quests": ["Win the Tournament", "Retrieve Training Weapons"],
        "reward": "Unique martial arts weapons, prestige items"
    },
    "Deserted Researcher": {
        "location": "Crimson Abyss",
        "dialogues": {
            "greeting": "What we unleashed... I fear it's too late to stop."
        },
        "quests": ["Contain the Corruption", "Destroy Experimental Devices"],
        "reward": "Resistance gear, purified abyssal materials"
    },
    "Corrupted Survivor": {
        "location": "Crimson Abyss",
        "dialogues": {
            "greeting": "The Abyss... it whispers. It promises power."
        },
        "quests": ["Find the Cure", "Destroy the Corruption Source"],
        "reward": "Anti-corruption items, purification rituals"
    },
    "Village Historian": {
        "location": "Greenwood Village",
        "dialogues": {
            "greeting": "The forest holds many secrets older than the village itself."
        },
        "quests": ["Research Ancient Trees", "Translate Old Scrolls"],
        "reward": "Historical artifacts, knowledge points"
    },
    "Local Farmer": {
        "location": "Greenwood Village",
        "dialogues": {
            "greeting": "The soil here is rich, but it requires respect."
        },
        "quests": ["Harvest Rare Crops", "Scare Off Pests"],
        "reward": "Farming tools, rare seeds"
    },
    "Fisherman": {
        "location": "Stormhaven",
        "dialogues": {
            "greeting": "The sea gives generously to those who understand her."
        },
        "quests": ["Catch Legendary Fish", "Repair the Harbor"],
        "reward": "Fishing gear, rare fish"
    },
    "Shipwright": {
        "location": "Stormhaven",
        "dialogues": {
            "greeting": "A good ship is built with patience, not haste."
        },
        "quests": ["Find Ship Materials", "Solve Shipyard Sabotage"],
        "reward": "Boat blueprints, navigation tools"
    },
    "Dragon Tamer": {
        "location": "Dragon's Reach",
        "dialogues": {
            "greeting": "Dragons respect strength, but they follow wisdom."
        },
        "quests": ["Tame a Specific Dragon", "Retrieve Dragon Eggs", "Dragon Tamer Initiate"],
        "reward": "Dragon companions, taming gear"
    },
    "Mercenary Captain": {
        "location": "Dragon's Reach",
        "dialogues": {
            "greeting": "The mountains are dangerous, but the pay is good."
        },
        "quests": ["Escort the Convoy", "Eliminate Bandit Camps"],
        "reward": "Mercenary gear, gold"
    },
    "Garden Master": {
        "location": "Jade Lotus Village",
        "dialogues": {
            "greeting": "A garden reflects the grower's soul."
        },
        "quests": ["Cultivate Rare Herbs", "Design a Zen Garden"],
        "reward": "Special seeds, gardening tools"
    },
    "Tea House Owner": {
        "location": "Jade Lotus Village",
        "dialogues": {
            "greeting": "A good cup of tea can change your day."
        },
        "shop": ["Temporary stat-boosting teas"],
        "quests": ["Collect Rare Tea Leaves", "Host a Tea Ceremony"],
        "reward": "Special tea blends, social reputation"
    },
    "Lava Prospector": {
        "location": "Ember Hollow",
        "dialogues": {
            "greeting": "The earth gives treasure to those who endure its heat."
        },
        "quests": ["Extract Magma Crystals", "Repair the Cooling System"],
        "reward": "Volcanic gear, rare minerals"
    },
    "Fire Mage": {
        "location": "Ember Hollow",
        "dialogues": {
            "greeting": "Fire is both creator and destroyer."
        },
        "quests": ["Contain Lava Elemental", "Retrieve Ancient Tome"],
        "reward": "Fire-elemental weapons, spellbooks"
    },
    "Lunar Cultist": {
        "location": "Moonveil Harbor",
        "dialogues": {
            "greeting": "The moon guides us through the darkest nights."
        },
        "quests": ["Harvest Moonlit Herbs", "Restore the Lunar Altar"],
        "reward": "Moon-based magic items, night vision gear"
    },
    "Sea Captain": {
        "location": "Moonveil Harbor",
        "dialogues": {
            "greeting": "The sea is a harsh mistress, but rewarding."
        },
        "quests": ["Escort the Trade Ship", "Map New Trade Routes"],
        "reward": "Nautical gear, rare trade goods"
    },
    "Swamp Hermit": {
        "location": "Blightmoor",
        "dialogues": {
            "greeting": "The swamp gives and takes in equal measure."
        },
        "quests": ["Develop an Antidote", "Destroy the Toxic Source"],
        "reward": "Antidote recipes, poison-resistant gear"
    },
    "Mutated Creature Tamer": {
        "location": "Blightmoor",
        "dialogues": {
            "greeting": "Even mutation has its uses."
        },
        "quests": ["Capture a Mutated Beast", "Retrieve Experimental Data"],
        "reward": "Mutated pet companions, toxic weapons"
    },
    "Elven Archdruid": {
        "location": "Verdant Spire",
        "dialogues": {
            "greeting": "Nature's balance must be preserved at all costs."
        },
        "quests": ["Purge the Corruption", "Retrieve the Druidic Staff"],
        "reward": "Nature magic items, elven armor"
    },
    "Sky Gardener": {
        "location": "Verdant Spire",
        "dialogues": {
            "greeting": "The sky holds plants that ground dwellers can't imagine."
        },
        "quests": ["Pollinate Rare Flowers", "Save the Floating Garden"],
        "reward": "Flying mounts, cloudwalking boots"
    },
    "Frost Witch": {
        "location": "Silverpine",
        "dialogues": {
            "greeting": "Winter tests us, but also blesses us."
        },
        "quests": ["Summon a Snow Spirit", "Protect the Winter Festival"],
        "reward": "Frost magic items, winter-themed gear"
    },
    "Yeti Guide": {
        "location": "Silverpine",
        "dialogues": {
            "greeting": "The mountains are my home. Let me show you their ways."
        },
        "quests": ["Escort Through the Pass", "Retrieve Stolen Idol"],
        "reward": "Yeti companions, cold-resistant gear"
    },
    "Imperial Inquisitor": {
        "location": "Tlācahcāyōtl Tletl Tecpanēcatl",
        "dialogues": {
            "greeting": "Heretics will burn for the purification of the realm."
        },
        "quests": ["Expose the Heretic Cell", "Retrieve the Sacred Flame"],
        "reward": "Inquisitor gear, fire magic items"
    },
    "Rebel Healer": {
        "location": "Tlācahcāyōtl Tletl Tecpanēcatl",
        "dialogues": {
            "greeting": "We heal the wounds the Empire inflicts."
        },
        "quests": ["Gather Medicine", "Save Imprisoned Dissidents"],
        "reward": "Healing potions, medical supplies"
    },
    "Wandering Spirit": {
        "location": "Cursed Katana",
        "dialogues": {
            "greeting": "This blade... it consumes souls."
        },
        "quests": ["Purify the Katana", "Find the Spirit's Rest"],
        "reward": "Purified weapon, spirit companion"
    },
}

# Main storyline chapters
STORYLINE = {
    "Chapter 1: The Awakening": {
        "title": "The Awakening",
        "description": "As darkness spreads across the land, a hero rises to face the looming threat. The fate of the realm hangs in the balance.",
        "required_level": 1,
        "quest_line": ["The Beginning", "First Steps", "The Dark Warning"],
        "reward": {"gold": 200, "exp": 300, "item": "Novice Ring"}
    },
    "Chapter 2: The Dragon's Call": {
        "title": "The Dragon's Call",
        "description": "Ancient dragons stir from their slumber, their power echoing through the mountains. The hero must prove their worth to tame these mighty beasts.",
        "required_level": 5,
        "quest_line": ["Dragon's Peak Journey", "Dragon Trials", "The First Flight"],
        "reward": {"gold": 500, "exp": 700, "item": "Dragon Scale Armor"}
    },
    "Chapter 3: The Gathering Storm": {
        "title": "The Gathering Storm",
        "description": "Dark forces gather in the distant lands, forming alliances that threaten the peace of all realms. You must unite the fractured kingdoms before it's too late.",
        "required_level": 10,
        "quest_line": ["Alliance of Kingdoms", "The Council Meeting", "The Diplomat's Journey"],
        "reward": {"gold": 800, "exp": 1200, "item": "Diplomat's Signet"}
    },
    "Chapter 4: The Shadow Legion": {
        "title": "The Shadow Legion",
        "description": "A mysterious legion of shadow warriors has emerged from the forbidden lands. Their dark magic corrupts everything they touch.",
        "required_level": 15,
        "quest_line": ["Scouts of Darkness", "The Corrupted Forest", "The Shadow General"],
        "reward": {"gold": 1200, "exp": 1800, "item": "Shadowbane Amulet"}
    },
    "Chapter 5: The Ancient Ones": {
        "title": "The Ancient Ones",
        "description": "Beings of immense power, forgotten by time, have awakened. Their return heralds an era of chaos unless their motives can be understood.",
        "required_level": 20,
        "quest_line": ["Whispers of the Past", "The Forbidden Library", "The Gateway"],
        "reward": {"gold": 1500, "exp": 2500, "item": "Tome of the Ancients"}
    },
    "Chapter 6: The Final Confrontation": {
        "title": "The Final Confrontation",
        "description": "All paths have led to this moment. The fate of the world rests on your final battle against the ultimate darkness.",
        "required_level": 25,
        "quest_line": ["The Path Opens", "Allies United", "Darkness Falls"],
        "reward": {"gold": 2000, "exp": 3000, "item": "Hero's Legacy"}
    },
    # Post-game storylines
    "Epilogue: The New Beginning": {
        "title": "The New Beginning",
        "description": "Though the great darkness has been defeated, new challenges arise in a world forever changed by your actions.",
        "required_level": 30,
        "post_game": True,
        "quest_line": ["Rebuilding the Realms", "New Threats Emerge", "The Hero's Journey Continues"],
        "reward": {"gold": 3000, "exp": 4000, "item": "Crown of New Dawn"}
    },
    "Dimensional Rifts": {
        "title": "Dimensional Rifts",
        "description": "Strange portals have appeared throughout the land, leading to alternate realities and timelines. What dangers—and opportunities—might they hold?",
        "required_level": 35,
        "post_game": True,
        "quest_line": ["The First Portal", "Mirror Worlds", "The Time Paradox"],
        "reward": {"gold": 3500, "exp": 4500, "item": "Dimensional Compass"}
    },
    "Legacy of the Gods": {
        "title": "Legacy of the Gods",
        "description": "Ancient deities have taken notice of your heroic deeds. Now they challenge you to trials that will test the limits of your abilities.",
        "required_level": 40,
        "post_game": True,
        "quest_line": ["Divine Challenge", "The Celestial Forge", "Ascension"],
        "reward": {"gold": 4000, "exp": 5000, "item": "Godforged Artifact"}
    },
    "Chapter 3: Shadows of the Past": {
        "title": "Shadows of the Past",
        "description": "Dark secrets emerge from the shadows of Shadowmere, threatening to unravel the peace. The hero must confront the darkness within.",
        "required_level": 10,
        "quest_line": ["The Shadow's Call", "Ancient Secrets", "The Final Shadow"],
        "reward": {"gold": 1000, "exp": 1500, "item": "Shadow Blade"}
    },
    "Chapter 4: The Dark Sun's Rise": {
        "title": "The Dark Sun's Rise",
        "description": "The Dark Sun Order, the Empire's ruthless secret police, is expanding its power. You must uncover their plans before it's too late.",
        "required_level": 15,
        "quest_line": ["Shadow Infiltration", "The Informant", "Dark Sun Archives"],
        "reward": {"gold": 1500, "exp": 2000, "item": "Shadow Cloak"}
    },
    "Chapter 5: Imperial Machinations": {
        "title": "Imperial Machinations",
        "description": "The Empire of Eternal Flame strengthens its grip on the lands while the Dark Sun Order enforces their will. You discover a resistance movement.",
        "required_level": 20,
        "quest_line": ["Resistance Contact", "Imperial Fortress", "Escape from the Capital"],
        "reward": {"gold": 2000, "exp": 2500, "item": "Resistance Insignia"}
    },
    "Chapter 6: Revolution's Dawn": {
        "title": "Revolution's Dawn",
        "description": "The time has come to strike against the Empire and the Dark Sun Order. You must unite the rebel factions and lead the final assault.",
        "required_level": 25,
        "quest_line": ["Uniting the Factions", "Battle for Freedom", "Emperor's Downfall"],
        "reward": {"gold": 2500, "exp": 3000, "item": "Freedom's Banner"}
    },
    "Chapter 7: The Crimson Abyss": {
        "title": "The Crimson Abyss",
        "description": "A dark and foreboding realm where ancient evils stir. The hero's journey continues beyond this point...",
        "required_level": 30,
        "quest_line": ["Crimson Abyss Awakening", "Demon's Heart", "Abyssal Leviathan"],
        "reward": {"gold": 3000, "exp": 3500, "item": "Demon's Heart"}
    }
}

# Weapon types and their properties
WEAPONS = {
    "Wooden Sword": {"damage": 5, "speed": 1.0, "price": 30},
    "Bone Sword": {"damage": 7, "speed": 1.0, "price": 50},
    "Iron Sword": {"damage": 10, "speed": 1.0, "price": 80},
    "Steel Sword": {"damage": 15, "speed": 0.9, "price": 150},
    "Flame Sword": {"damage": 20, "speed": 1.1, "price": 300, "effect": "burn"},
    "Ice Sword": {"damage": 18, "speed": 0.8, "price": 300, "effect": "freeze"},
    "Magic Staff": {"damage": 12, "speed": 1.2, "price": 200, "effect": "magic"},
    "Battle Axe": {"damage": 25, "speed": 0.7, "price": 250},
    "Longbow": {"damage": 20, "speed": 1.5, "price": 180},
    "Shortbow": {"damage": 18, "speed": 1.3, "price": 150},
    "Dagger": {"damage": 8, "speed": 1.5, "price": 100},
    "Spear": {"damage": 12, "speed": 1.2, "price": 120},
    "Crossbow": {"damage": 15, "speed": 0.6, "price": 200},
    "Katana": {"damage": 22, "speed": 1.0, "price": 350},
    "Elder Wand": {"damage": 30, "speed": 1.0, "price": 500, "effect": "ultimate"},
    "Assassin's Dagger": {"damage": 14, "speed": 1.7, "price": 220},
    "Miner's Pickaxe": {"damage": 18, "speed": 0.8, "price": 180},
    "Storm Staff": {"damage": 20, "speed": 1.0, "price": 300, "effect": "storm"},
    "Cursed Katana": {"damage": 40, "speed": 0.9, "price": 1500, "effect": "self_damage"},
    "Ninja Star": {"damage": 16, "speed": 1.8, "price": 250},
    "Cutlass": {"damage": 20, "speed": 1.1, "price": 300},
    "Shadow Blade": {"damage": 32, "speed": 1.2, "price": 950, "effect": "critical_hit"},
    "Dragonfire Sword": {"damage": 35, "speed": 1.0, "price": 1200, "effect": "fire_damage"},
    "Lightning Sword": {"damage": 30, "speed": 1.1, "price": 1100, "effect": "lightning_damage"},
    "Wind Sword": {"damage": 28, "speed": 1.3, "price": 1000, "effect": "wind_damage"},
    "Earth Sword": {"damage": 27, "speed": 1.0, "price": 950, "effect": "earth_damage"},
    "Nature Sword": {"damage": 25, "speed": 1.2, "price": 900, "effect": "nature_damage"},
    "Jade Sword": {"damage": 24, "speed": 1.1, "price": 850},
    "Shogun's Blade": {"damage": 38, "speed": 1.0, "price": 1400},
    "Crimson Cutlass": {"damage": 28, "speed": 1.0, "price": 750, "effect": "bleed"},
    "Thunder Staff": {"damage": 30, "speed": 1.0, "price": 1000, "effect": "thunder_damage"},
    "Obsidian Blade": {"damage": 100, "speed": 0.5, "price": 1000000}
}

# Towns and locations
LOCATIONS= {
    "Greenwood Village": {
        "type": "town",
        "shops": ["Blacksmith", "General Store", "Magic Shop"],
        "monsters": ["Goblin", "Wolf"],
        "description": "A peaceful village surrounded by dense forest"
    },
    "Stormhaven": {
        "type": "town",
        "shops": ["Weaponsmith", "Armory", "Alchemist"],
        "monsters": ["Skeleton", "Ghost"],
        "description": "A coastal town known for its skilled craftsmen"
    },
    "Dragon's Peak": {
        "type": "dangerous",
        "monsters": ["Fire Dragon", "Ice Dragon"],
        "description": "A treacherous mountain where dragons dwell"
    },
    "Crystal Cave": {
        "type": "dungeon",
        "monsters": ["Crystal Golem", "Cave Troll"],
        "description": "A cave system filled with valuable crystals"
    },
    "Shadowmere": {
        "type": "town",
        "shops": ["Dark Market", "Mystic Shop"],
        "monsters": ["Shadow Beast", "Dark Knight"],
        "description": "A mysterious town shrouded in darkness and secrets."
    },
    "Sunken Depths": {
        "type": "dungeon",
        "monsters": ["Abyssal Serpent", "Sunken Ghost", "Coral Golem"],
        "description": "Sunken cities and forgotten structures beneath the ocean, filled with ancient artifacts and dangers."
    },
    "Blightmoor": {
        "type": "dangerous",
        "monsters": ["Blight Beast", "Toxic Sludge", "Mutated Scorpion"],
        "description": "A dark and twisted environment where the very soil is tainted, giving rise to dangerous, mutated creatures and toxic flora."
    },
    "Silverpine": {
        "type": "town",
        "shops": ["Silver Smith", "Herbalist", "Hunter's Lodge"],
        "monsters": ["Silver Wolf", "Forest Spirit"],
        "description": "A cold and dense forest filled with evergreens and snow, inhabited by resilient wildlife adapted to the harsh conditions."
    },
    "Frostvale": {
        "type": "town",
        "shops": ["Ice Forge", "Potion Shop"],
        "monsters": ["Ice Troll", "Frost Giant"],
        "description": "A snowy town known for its ice magic"
    },
    "Long Shui Zhen (Dragonwater Town)": {
        "type": "city",
        "shops": ["Dragon Market", "Dragon Temple"],
        "monsters": ["Dragon Knight", "Water Elemental"],
        "description": "A bustling city with a rich history of dragon taming and martial arts"
    },
    "Jade Lotus Village": {
        "type": "town",
        "shops": ["Herbalist", "Tea House", "Charm Shop"],
        "monsters": ["Lotus Spirit", "Pond Serpent"],
        "description": "A tranquil village known for its serene gardens and sacred lotus ponds"
    },
    "Thundercliff Hold": {
        "type": "dangerous",
        "monsters": ["Storm Elemental", "Rock Wyvern"],
        "description": "A high cliff fortress battered by storms and haunted by sky beasts"
    },
    "Ember Hollow": {
        "type": "dungeon",
        "monsters": ["Lava Hound", "Molten Wraith"],
        "description": "A volcanic cavern where fire magic pulses through the earth"
    },
    "Moonveil Harbor": {
        "type": "town",
        "shops": ["Navigator's Guild", "Seafood Market", "Lunar Shrine"],
        "monsters": ["Moonshade Specter", "Sea Serpent"],
        "description": "A mystical harbor town bathed in moonlight and tied to ancient sea legends"
    },
    "Verdant Spire": {
        "type": "city",
        "shops": ["Elven Boutique", "Sky Garden", "Mystic Archives"],
        "monsters": ["Treant", "Forest Guardian"],
        "description": "A soaring city built into a sacred tree, home to ancient knowledge and nature spirits"
    },
    "Silent Ashes": {
        "type": "dungeon",
        "monsters": ["Ash Revenant", "Cursed Wanderer"],
        "description": "The ruins of a once-great city buried in ash and echoing with whispers of the past"
    },
    "Suirai": {
        "type": "city",
        "shops": ["Shogun's Armory", "Suirai Market", "Mystic Dojo"],
        "monsters": ["Shogun's Guard", "Jade Samurai", "Kitsune Warrior", "Tengu Warrior", "Oni Berserker", "Shadow Samurai"],
        "description": "A bustling city known for its fierce warriors and ancient traditions, and the capital of the Shogunate of Shirui."
    },
    "Dragon's Reach": {
        "type": "dangerous",
        "monsters": ["Dragon Whelp", "Dragon Spirit", "Dragon Knight"],
        "description": "A perilous mountain range where dragons and their knights roam."
    },
    "Sunken Abyss": {
        "type": "dungeon",
        "monsters": ["Abyssal Kraken", "Sunken Ghost", "Coral Golem"],
        "description": "An underwater trench filled with ancient ruins and dangerous sea creatures."
    },
    "Frostfang Keep": {
        "type": "dungeon",
        "monsters": ["Frost Giant", "Ice Revenant", "Frost Wraith"],
        "description": "A frozen fortress haunted by icy spirits and giants."
    },
    "Glimmering Grotto": {
        "type": "dungeon",
        "monsters": ["Crystal Golem", "Glimmering Sprite"],
        "description": "A cave filled with shimmering crystals and magical creatures."
    },
    "Imperial City": {
        "type": "city",
        "shops": ["Imperial Armory", "Grand Bazaar", "Royal Jeweler", "Alchemist's Guild"],
        "monsters": ["Imperial Guard", "Dark Sun Agent", "Royal Knight"],
        "description": "The sprawling capital of the Empire of Eternal Flame, with grand architecture and oppressive security provided by the Dark Sun Order."
    },
    "Dark Sun Headquarters": {
        "type": "dungeon",
        "monsters": ["Dark Sun Enforcer", "Shadow Mage", "Dark Sun Commander", "Sun Lord Eclipsius"],
        "description": "The hidden base of operations for the Dark Sun Order, the Empire's ruthless secret police. Few who enter ever leave."
    },
    "Resistance Hideout": {
        "type": "town",
        "shops": ["Blackmarket Trader", "Resistance Armorer", "Safe House"],
        "monsters": ["Imperial Spy", "Mercenary"],
        "description": "A secret network of caves and tunnels where rebels plan their resistance against the Empire and the Dark Sun Order."
    },
}

# Character classes
CHARACTER_CLASSES = {
    "Warrior": {"health_bonus": 20, "attack_bonus": 10, "defense_bonus": 15, "speed_bonus": 5},
    "Mage": {"health_bonus": -10, "attack_bonus": 25, "defense_bonus": 0, "speed_bonus": 7},
    "Rogue": {"health_bonus": 0, "attack_bonus": 15, "defense_bonus": 5, "speed_bonus": 10},
    "Paladin": {"health_bonus": 30, "attack_bonus": 15, "defense_bonus": 20, "speed_bonus": 4},
    "Archer": {"health_bonus": -10, "attack_bonus": 20, "defense_bonus": 5, "speed_bonus": 8},
    "Berserker": {"health_bonus": 20, "attack_bonus": 30, "defense_bonus": -10, "speed_bonus": 6},
    "Priest": {"health_bonus": 10, "attack_bonus": 5, "defense_bonus": 10, "speed_bonus": 5},
    "Assassin": {"health_bonus": -15, "attack_bonus": 35, "defense_bonus": -5, "speed_bonus": 12},
    "Druid": {"health_bonus": 15, "attack_bonus": 10, "defense_bonus": 15, "speed_bonus": 6},
    "Samurai": {"health_bonus": 0, "attack_bonus": 20, "defense_bonus": 10, "speed_bonus": 9},
}

# Character Gacha System - Inspired by Genshin Impact
# Characters have rarity tiers, elements, unique abilities, and stats

# Character rarity definitions with pull rates and colors
CHARACTER_RARITIES = {
    "Common": {"stars": 1, "color": WHITE, "pull_rate": 60.0, "pity_increase": 0},
    "Uncommon": {"stars": 2, "color": GREEN, "pull_rate": 25.0, "pity_increase": 1},
    "Rare": {"stars": 3, "color": BLUE + BOLD, "pull_rate": 10.0, "pity_increase": 5},
    "Epic": {"stars": 4, "color": MAGENTA + BOLD, "pull_rate": 4.0, "pity_increase": 10},
    "Legendary": {"stars": 5, "color": YELLOW + BOLD, "pull_rate": 1.0, "pity_increase": 25}
}

# Character elements and their colors
CHARACTER_ELEMENTS = {
    "Fire": RED + BOLD,
    "Water": BLUE,
    "Earth": GREEN,
    "Air": CYAN,
    "Light": YELLOW + BOLD,
    "Dark": DARKGRAY + BOLD,
    "Lightning": YELLOW,
    "Ice": CYAN + BOLD,
    "Nature": GREEN + BOLD,
    "Arcane": MAGENTA
}

# Gacha Character Collection - Detailed character entries with stats, abilities, and lore
GACHA_CHARACTERS = {
    # LEGENDARY CHARACTERS (5★)
    "Aurora": {
        "rarity": "Legendary",
        "element": "Light",
        "class": "Paladin",
        "weapon": "Sacred Sword",
        "base_stats": {"health": 1200, "attack": 85, "defense": 75, "speed": 60},
        "abilities": [
            {"name": "Divine Judgement", "description": "Deals massive Light damage to all enemies", "cooldown": 4},
            {"name": "Blessing of Light", "description": "Heals all allies and provides a defense boost", "cooldown": 3}
        ],
        "passive": "When HP drops below 20%, automatically heals for 30% of max HP once per battle",
        "constellation_bonus": "All Light damage increased by 25%",
        "lore": "Born under a solar eclipse, Aurora was blessed by the celestial light. She swore to protect the realm from darkness.",
        "obtain_method": "Radiance Gacha Banner (Limited)",
        "voice_lines": [
            "The light shall guide us to victory.",
            "Darkness cannot stand against my radiance!",
            "For the glory of the sun kingdom!"
        ]
    },
    "Ezra": {
        "rarity": "Legendary",
        "element": "Dark",
        "class": "Rogue",
        "weapon": "Shadow Daggers",
        "base_stats": {"health": 950, "attack": 95, "defense": 50, "speed": 85},
        "abilities": [
            {"name": "Void Strike", "description": "Deals massive Dark damage to a single target with 50% chance to inflict Void status", "cooldown": 3},
            {"name": "Shadow Realm", "description": "Makes entire party untargetable for 1 turn", "cooldown": 5}
        ],
        "passive": "20% chance to dodge any attack",
        "constellation_bonus": "After dodging, automatically counterattacks for 150% damage",
        "lore": "Once the heir to a noble kingdom, Ezra sacrificed everything to gain the power of the void when dark forces threatened his homeland.",
        "obtain_method": "Abyssal Desires Gacha Banner (Limited)",
        "voice_lines": [
            "The shadows bend to my will.",
            "You cannot see what lurks in the dark.",
            "My path is my own to choose."
        ]
    },
    "Solara": {
        "rarity": "Legendary",
        "element": "Fire",
        "class": "Mage",
        "weapon": "Solar Staff",
        "base_stats": {"health": 1000, "attack": 100, "defense": 60, "speed": 70},
        "abilities": [
            {"name": "Solar Flare", "description": "Deals immense Fire damage to all enemies with Burn chance", "cooldown": 4},
            {"name": "Phoenix Rebirth", "description": "Revives a fallen ally with 50% HP and grants Fire Shield", "cooldown": 6}
        ],
        "passive": "Applies Burn to all enemies at the start of battle",
        "constellation_bonus": "Burn damage increased by 50%",
        "lore": "Solara channels the eternal flame of the sun. Said to be the reincarnation of the Phoenix Queen.",
        "obtain_method": "Celestial Flame Gacha Banner (Limited)",
        "voice_lines": [
            "The sun rises with me.",
            "Ashes will be your end.",
            "Witness rebirth through fire!"
        ]
    },

    # EPIC CHARACTERS (4★)
    "Lyra": {
        "rarity": "Epic",
        "element": "Ice",
        "class": "Archer",
        "weapon": "Crystalline Bow",
        "base_stats": {"health": 850, "attack": 78, "defense": 45, "speed": 75},
        "abilities": [
            {"name": "Freezing Shot", "description": "Deals Ice damage with 70% chance to freeze target for 1 turn", "cooldown": 3},
            {"name": "Blizzard Volley", "description": "Fires multiple arrows dealing AoE Ice damage", "cooldown": 4}
        ],
        "passive": "Critical hits have a 50% chance to apply Chill effect, reducing enemy speed",
        "constellation_bonus": "Frozen enemies take 35% more damage from all sources",
        "lore": "Raised in the frozen north, Lyra learned to hunt in the harshest conditions. Her arrows are infused with ancient ice magic.",
        "obtain_method": "Standard Gacha Banner",
        "voice_lines": [
            "One shot, one kill.",
            "The cold never bothered me.",
            "I'll freeze your heart."
        ]
    },
    "Terra": {
        "rarity": "Epic",
        "element": "Earth",
        "class": "Mage",
        "weapon": "Living Stone Staff",
        "base_stats": {"health": 900, "attack": 72, "defense": 65, "speed": 50},
        "abilities": [
            {"name": "Stone Barrage", "description": "Launches multiple stone projectiles at random enemies", "cooldown": 3},
            {"name": "Earthquake", "description": "Deals Earth damage to all enemies and has a chance to stun", "cooldown": 5}
        ],
        "passive": "Whenever Terra takes damage, gains a stacking shield that absorbs 5% of max HP (up to 25%)",
        "constellation_bonus": "Earthquake now always stuns enemies for 1 turn",
        "lore": "A child of the mountains, Terra can feel the heartbeat of the world beneath her feet and call upon its strength.",
        "obtain_method": "Standard Gacha Banner",
        "voice_lines": [
            "The earth responds to my call.",
            "Mountains bow to me.",
            "Stand firm like stone."
        ]
    },
    "Vayne": {
        "rarity": "Epic",
        "element": "Air",
        "class": "Assassin",
        "weapon": "Twin Fans",
        "base_stats": {"health": 800, "attack": 82, "defense": 42, "speed": 90},
        "abilities": [
            {"name": "Gale Dance", "description": "Strikes multiple enemies with swift wind slashes", "cooldown": 3},
            {"name": "Silent Step", "description": "Becomes untargetable and gains crit boost next turn", "cooldown": 5}
        ],
        "passive": "Gains 15% evasion while above 70% HP",
        "constellation_bonus": "Silent Step also restores 10% HP",
        "lore": "A legendary dancer from the sky islands who uses elegance as a weapon.",
        "obtain_method": "Wind Whispers Gacha Banner",
        "voice_lines": [
            "Can you catch the wind?",
            "My blades are as swift as air.",
            "Dance of death, begin!"
        ]
    },

    # RARE CHARACTERS (3★)
    "Elm": {
        "rarity": "Rare",
        "element": "Nature",
        "class": "Rogue",
        "weapon": "Living Vines",
        "base_stats": {"health": 750, "attack": 65, "defense": 55, "speed": 70},
        "abilities": [
            {"name": "Entangling Roots", "description": "Immobilizes an enemy and deals Nature damage over time", "cooldown": 3},
            {"name": "Life Bloom", "description": "Heals the party for a moderate amount", "cooldown": 4}
        ],
        "passive": "Recovers 5% HP at the start of each turn",
        "constellation_bonus": "Entangling Roots affects all enemies",
        "lore": "Once a tree spirit, Elm took human form to protect the ancient forests from those who would destroy them.",
        "obtain_method": "Standard Gacha Banner",
        "voice_lines": [
            "Nature always finds a way.",
            "The forest speaks through me.",
            "Growth comes after hardship."
        ]
    },
    "Andrei": {
        "rarity": "Rare",
        "element": "Lightning",
        "class": "Warrior",
        "weapon": "Volt Axe",
        "base_stats": {"health": 780, "attack": 70, "defense": 60, "speed": 65},
        "abilities": [
            {
                "name": "Thunder Cleave",
                "description": "Deals Lightning damage to a single enemy and has a 30% chance to stun",
                "cooldown": 3
            },
            {
                "name": "Chargebreaker",
                "description": "Deals damage and reduces enemy defense for 2 turns",
                "cooldown": 4
            }
        ],
        "passive": "When landing a critical hit, gains +10 speed for 1 turn (stacks up to 3 times)",
        "constellation_bonus": "Thunder Cleave's stun chance increases to 60%",
        "lore": "A battle-hardened mercenary who fights for coin but carries a code of honor. His axe crackles with the fury of a hundred storms.",
        "obtain_method": "Standard Gacha Banner, Mercenary's Pact Event",
        "voice_lines": [
            "Pay me well, and I'll bring the thunder.",
            "Storm’s coming... and I'm leading it.",
            "No loyalty, only lightning."
        ]
    },

    # UNCOMMON CHARACTERS (2★)
    "Marin": {
        "rarity": "Uncommon",
        "element": "Water",
        "class": "Warrior",
        "weapon": "Coral Trident",
        "base_stats": {"health": 650, "attack": 58, "defense": 60, "speed": 55},
        "abilities": [
            {"name": "Tidal Slash", "description": "Deals Water damage to a single target", "cooldown": 2},
            {"name": "Ocean's Protection", "description": "Creates a water shield that reduces damage taken", "cooldown": 4}
        ],
        "passive": "Takes 20% reduced damage when below 50% HP",
        "constellation_bonus": "Ocean's Protection also heals allies for 10% of their max HP",
        "lore": "Born in a coastal village, Marin swore to protect his people from sea monsters and pirates alike.",
        "obtain_method": "Standard Gacha Banner",
        "voice_lines": [
            "The tide turns in my favor.",
            "Water always finds its path.",
            "I stand as the shore against the tide."
        ]
    },

    # COMMON CHARACTERS (1★)
    "Thorn": {
        "rarity": "Common",
        "element": "Earth",
        "class": "Warrior",
        "weapon": "Iron Sword",
        "base_stats": {"health": 550, "attack": 45, "defense": 50, "speed": 45},
        "abilities": [
            {"name": "Strong Slash", "description": "Basic attack with increased power", "cooldown": 2},
            {"name": "Defensive Stance", "description": "Increases defense for 2 turns", "cooldown": 3}
        ],
        "passive": "Has a 10% chance to counterattack when hit",
        "constellation_bonus": "Defensive Stance also recovers 10% HP",
        "lore": "A dedicated village guard who dreams of becoming a hero worthy of legend.",
        "obtain_method": "Standard Gacha Banner, Friend Summons",
        "voice_lines": [
            "I'll protect everyone!",
            "Stand behind me.",
            "My sword is ready."
        ]
    },
    "Juno": {
        "rarity": "Common",
        "element": "Water",
        "class": "Archer",
        "weapon": "Reed Bow",
        "base_stats": {"health": 540, "attack": 46, "defense": 40, "speed": 50},
        "abilities": [
            {"name": "Water Arrow", "description": "Deals minor Water damage to an enemy", "cooldown": 2},
            {"name": "Aqua Focus", "description": "Increases next attack's power", "cooldown": 3}
        ],
        "passive": "Has 5% chance to land a critical hit",
        "constellation_bonus": "Water Arrow has a 20% chance to slow",
        "lore": "An aspiring hunter from the riverside village, determined to prove herself.",
        "obtain_method": "Standard Gacha Banner, Beginner Rewards",
        "voice_lines": [
            "One day, I'll hit the bullseye!",
            "I won’t miss again!",
            "Splash and sting!"
        ]
    }
}

# Add additional character classes
CHARACTER_CLASSES.update({
    "Ninja": {"health_bonus": -5, "attack_bonus": 25, "defense_bonus": 5, "speed_bonus": 11},
    "Knight": {"health_bonus": 40, "attack_bonus": 10, "defense_bonus": 20, "speed_bonus": 4},
    "Hunter": {"health_bonus": 0, "attack_bonus": 15, "defense_bonus": 10, "speed_bonus": 7},
    "Tamer": {"health_bonus": 35, "attack_bonus": 50, "defense_bonus": -25, "speed_bonus": 5}
})

# Item rarity
RARITY_MULTIPLIERS = {
    "Common": 1.0,
    "Uncommon": 1.2,
    "Rare": 1.5,
    "Epic": 2.0,
    "Legendary": 3.0
}

# Basic skills
SKILLS = {
    "Warrior": ["Slam", "Shield Block", "Berserk"],
    "Mage": ["Fireball", "Ice Shield", "Lightning Bolt"],
    "Rogue": ["Backstab", "Stealth", "Poison Strike"],
    "Paladin": ["Holy Strike", "Divine Shield", "Healing Light"],
    "Archer": ["Quick Shot", "Rain of Arrows", "Eagle Eye"],
    "Berserker": ["Rage", "Whirlwind", "Blood Thirst"],
    "Priest": ["Holy Nova", "Divine Heal", "Smite"],
    "Assassin": ["Shadow Strike", "Vanish", "Death Mark"],
    "Druid": ["Entangle", "Nature's Touch", "Beast Form"],
    "Samurai": ["Iaijutsu Slash", "Bushido Focus", "Wind Cutter"],
    "Ninja": ["Shuriken Toss", "Shadow Clone", "Silent Step"],
    "Knight": ["Shield Bash", "Taunt", "Valor Strike"],
    "Hunter": ["Trap Set", "Beast Call", "Piercing Arrow"],
    "Tamer": ["Summon Beast", "Beast Fury", "Bonded Strike"]

}

# Enhanced crafting system
CRAFTING_RECIPES = {
    "Iron Sword": {
        "materials": {"Iron Ingot": 2, "Wood": 1},
        "level_required": 2,
        "type": "weapon",
        "effect": 10
    },
    "Steel Sword": {
        "materials": {"Steel Ingot": 2, "Leather": 1},
        "level_required": 5,
        "type": "weapon",
        "effect": 15
    },
    "Health Potion": {
        "materials": {"Red Herb": 2, "Water Flask": 1},
        "level_required": 1,
        "type": "consumable",
        "effect": 30
    },
    "Iron Armor": {
        "materials": {"Iron Ingot": 4, "Leather": 2},
        "level_required": 3,
        "type": "armor",
        "effect": 10
    }
}

# Materials that can be gathered
MATERIALS = {
    "Wood": {"areas": ["Forest"], "tool_required": "Axe"},
    "Iron Ore": {"areas": ["Cave", "Mountain"], "tool_required": "Pickaxe"},
    "Red Herb": {"areas": ["Forest", "Plains"], "tool_required": None},
    "Blue Herb": {"areas": ["Mountain", "Cave"], "tool_required": None},
    "Green Herb": {"areas": ["Forest", "Swamp"], "tool_required": None},
    "Water Flask": {"areas": ["River", "Lake"], "tool_required": "Flask"},
    "Leather": {"areas": ["Plains"], "tool_required": "Hunting Knife"},
    "Steel Ingot": {"areas": ["Mines","Mountains"], "tool_required": "Furnace"},
    "Gold Ore": {"areas": ["Mountain", "Deep Cave"], "tool_required": "Pickaxe"},
    "Magic Crystal": {"areas": ["Crystal Cave", "Ancient Ruins"], "tool_required": "Magic Chisel"},
    "Fish": {"areas": ["River", "Lake", "Coast"], "tool_required": "Fishing Rod"},
    "Silk Thread": {"areas": ["Forest", "Spider Nest"], "tool_required": "Silk Spinner"},
    "Clay": {"areas": ["Riverbank", "Swamp"], "tool_required": "Shovel"},
    "Coal": {"areas": ["Mines", "Mountain"], "tool_required": "Pickaxe"},
    "Ancient Relic": {"areas": ["Ancient Ruins", "Temple"], "tool_required": "Archaeology Kit"},
    "Salt": {"areas": ["Cave", "Desert Spring"], "tool_required": "Pickaxe"},
    "Venom Sac": {"areas": ["Swamp", "Spider Nest"], "tool_required": "Hunting Knife"},
    "Paper": {"areas": ["Forest", "Village"], "tool_required": "Wood Press"},
    "Magic Ink": {"areas": ["Ancient Ruins", "Wizard Tower"], "tool_required": "Magic Vial"},
    "Fire Essence": {"areas": ["Volcano", "Forge"], "tool_required": "Essence Collector"},
    "Stone": {"areas": ["Mountain", "River", "Plains"], "tool_required": "Pickaxe"},
    "Glass": {"areas": ["Desert", "Beach"], "tool_required": "Furnace"},
    "Sand": {"areas": ["Desert", "Beach"], "tool_required": "Shovel"},
    "Straw": {"areas": ["Plains", "Farm"], "tool_required": None},
    "Cloth": {"areas": ["Village", "City"], "tool_required": "Loom"},
    "Gears": {"areas": ["Workshop", "City"], "tool_required": "Metalworking Kit"},
    "Weather Sample": {"areas": ["Mountain Top", "Storm Plains", "Weather Sage's Hut"], "tool_required": "Weather Collection Kit"},
    "Feathers": {"areas": ["Plains", "Cliffside"], "tool_required": None},
    "Magma Stone": {"areas": ["Volcano", "Lava River"], "tool_required": "Pickaxe"},
    "Dragon Scale": {"areas": ["Dragon's Peak", "Dragon's Reach"], "tool_required": None},
    "Wheat seeds": {"areas": ["Plains", "Abundant Field"], "tool_required": None},
    "Rice seeds": {"areas": ["Plains", "Abundant Field"], "tool_required": None},
    "Lotus Seeds": {"areas": ["Lotus Pond", "Swamp"], "tool_required": None},
}

# Story quests are marked with story=True
QUESTS = [
    # Chapter 1: The Awakening Story Quests
    {
        "id": 101,
        "name": "The Beginning",
        "description": "Meet the Old Sage in Greenwood Village",
        "target": {"npc": "Old Sage", "count": 1},
        "reward": {"gold": 100, "exp": 200},
        "story": True,
        "chapter": 1,
        "travel_locations": ["Greenwood Village", "Stormhaven", "Crystal Cave"]
    },
    {
        "id": 102,
        "name": "First Steps",
        "description": "Defeat 10 monsters across Greenwood Village and Stormhaven",
        "target": {"monster": "any", "count": 10},
        "reward": {"gold": 150, "exp": 250},
        "story": True,
        "chapter": 1,
        "travel_locations": ["Greenwood Village", "Stormhaven"]
    },
    {
        "id": 103,
        "name": "The Dark Warning",
        "description": "Investigate the disturbance in Crystal Cave and Shadowmere",
        "target": {"location": "Crystal Cave", "count": 1},
        "reward": {"gold": 200, "exp": 300},
        "story": True,
        "chapter": 1,
        "travel_locations": ["Crystal Cave", "Shadowmere"]
    },

    # Chapter 2: The Dragon's Call Story Quests
    {
        "id": 201,
        "name": "Dragon's Peak Journey",
        "description": "Travel to Dragon's Peak, Stormhaven, and Greenwood Village to meet the Dragon Tamer",
        "target": {"npc": "Dragon Tamer", "count": 1},
        "reward": {"gold": 300, "exp": 400},
        "story": True,
        "chapter": 2,
        "travel_locations": ["Dragon's Peak", "Stormhaven", "Greenwood Village"]
    },
    {
        "id": 202,
        "name": "Dragon Trials",
        "description": "Complete the three trials of the Dragon Tamer across Dragon's Peak",
        "target": {"trials": "Dragon Trials", "count": 3},
        "reward": {"gold": 400, "exp": 500},
        "story": True,
        "chapter": 2,
        "travel_locations": ["Dragon's Peak"]
    },
    {
        "id": 203,
        "name": "The First Flight",
        "description": "Tame your first dragon after traveling through Dragon's Peak and Crystal Cave",
        "target": {"monster": "Dragon Whelp", "count": 1},
        "reward": {"gold": 500, "exp": 600, "item": "Dragon Whistle"},
        "story": True,
        "chapter": 2,
        "travel_locations": ["Dragon's Peak", "Crystal Cave"]
    },

    # Chapter 3: Shadows of the Past Story Quests
    {
        "id": 301,
        "name": "The Shadow's Call",
        "description": "Investigate the mysterious events in Shadowmere and Frostvale",
        "target": {"location": "Shadowmere", "count": 1},
        "reward": {"gold": 600, "exp": 700},
        "story": True,
        "chapter": 3,
        "travel_locations": ["Shadowmere", "Frostvale"]
    },
    {
        "id": 302,
        "name": "Ancient Secrets",
        "description": "Recover the lost artifacts from the Silent Ashes and Crystal Cave",
        "target": {"item": "Ancient Artifact", "count": 3},
        "reward": {"gold": 700, "exp": 800},
        "story": True,
        "chapter": 3,
        "travel_locations": ["Silent Ashes", "Crystal Cave"]
    },
    {
        "id": 303,
        "name": "The Shadow's Return",
        "description": "Confront the Shadow Master in his lair after traveling through Shadowmere and the Sunken Depths",
        "target": {"monster": "Shadow Master", "count": 1},
        "reward": {"gold": 1000, "exp": 1200, "item": "Shadow Master's Cloak"},
        "story": True,
        "chapter": 3,
        "travel_locations": ["Shadowmere", "Sunken Depths"]
    },
    {
        "id": 401,
        "name": "Shadow Infiltration",
        "description": "Infiltrate the Dark Sun Order's outer circle to gather intelligence on their operations.",
        "target": {"monster": "Dark Sun Agent", "count": 3},
        "reward": {"gold": 1200, "exp": 1600, "item": "Agent's Mask"},
        "story": True,
        "chapter": 4,
        "travel_locations": ["Imperial City", "Shadowmere"]
    },
    {
        "id": 402,
        "name": "The Informant",
        "description": "Make contact with a secret informant who can provide intel on the Dark Sun Order.",
        "target": {"npc": "Mysterious Informant", "count": 1},
        "reward": {"gold": 1300, "exp": 1700, "item": "Encrypted Documents"},
        "story": True,
        "chapter": 4,
        "travel_locations": ["Stormhaven", "Shadowmere"]
    },
    {
        "id": 403,
        "name": "Dark Sun Archives",
        "description": "Break into the Dark Sun archives to uncover evidence of their crimes.",
        "target": {"location": "Imperial City", "count": 1},
        "reward": {"gold": 1400, "exp": 1800, "item": "Dark Sun Cipher"},
        "story": True,
        "chapter": 4,
        "travel_locations": ["Imperial City", "Dark Sun Headquarters"]
    },
    {
        "id": 501,
        "name": "Resistance Contact",
        "description": "Establish contact with the resistance fighting against the Empire and the Dark Sun Order.",
        "target": {"npc": "Resistance Leader", "count": 1},
        "reward": {"gold": 1600, "exp": 2000, "item": "Resistance Badge"},
        "story": True,
        "chapter": 5,
        "travel_locations": ["Resistance Hideout", "Greenwood Village"]
    },
    {
        "id": 502,
        "name": "Imperial Fortress",
        "description": "Infiltrate one of the Empire's fortresses to sabotage their weapons supply.",
        "target": {"location": "Imperial Fortress", "count": 1},
        "reward": {"gold": 1800, "exp": 2200, "item": "Imperial Officer's Key"},
        "story": True,
        "chapter": 5,
        "travel_locations": ["Imperial City", "Thundercliff Hold"]
    },
    {
        "id": 503,
        "name": "Escape from the Capital",
        "description": "Help resistance fighters escape from the Imperial City while evading Dark Sun agents.",
        "target": {"npc": "Captured Resistance Member", "count": 3},
        "reward": {"gold": 2000, "exp": 2400, "item": "Shadow Cloak"},
        "story": True,
        "chapter": 5,
        "travel_locations": ["Imperial City", "Resistance Hideout"]
    },
    {
        "id": 601,
        "name": "Uniting the Factions",
        "description": "Travel across the land to unite the various resistance factions against the Empire.",
        "target": {"npc": "Faction Leader", "count": 4},
        "reward": {"gold": 2200, "exp": 2700, "item": "Unity Banner"},
        "story": True,
        "chapter": 6,
        "travel_locations": ["Stormhaven", "Verdant Spire", "Moonveil Harbor", "Resistance Hideout"]
    },
    {
        "id": 602,
        "name": "Battle for Freedom",
        "description": "Lead an assault on the Dark Sun Headquarters to dismantle their power structure.",
        "target": {"monster": "Dark Sun Commander", "count": 1},
        "reward": {"gold": 2300, "exp": 2800, "item": "Sorcerer's Tome"},
        "story": True,
        "chapter": 6,
        "travel_locations": ["Tlācahcāyōtl Tletl Tecpanēcatl/Empire of the Sacred Fire and Chains"]
    },
    {
        "id": 603,
        "name": "Sacred Fire",
        "description": "Ignite the sacred fire to rally the people against the empire.",
        "target": {"location": "Tlācahcāyōtl Tletl Tecpanēcatl Palace", "count": 1},
        "reward": {"gold": 2400, "exp": 2900, "item": "Sacred Flame"},
        "story": True,
        "chapter": 6,
        "travel_locations": ["Tlācahcāyōtl Tletl Tecpanēcatl/Empire of the Sacred Fire and Chains"]
    },
    {
        "id": 701,
        "name": "Crimson Abyss Awakening",
        "description": "Investigate the awakening of dark forces in the Crimson Abyss.",
        "target": {"monster": "Crimson Abyss Demon", "count": 1},
        "reward": {"gold": 3000, "exp": 3500, "item": "Demon's Heart"},
        "story": True,
        "chapter": 7,
        "travel_locations": ["Crimson Abyss"]
    },
    {
        "id": 702,
        "name": "Demon's Heart",
        "description": "Retrieve the Demon's Heart from the depths of the Crimson Abyss.",
        "target": {"monster": "Crimson Abyss Demon", "count": 1},
        "reward": {"gold": 3200, "exp": 3700, "item": "Demon's Heart"},
        "story": True,
        "chapter": 7,
        "travel_locations": ["Crimson Abyss"]
    },
    {
        "id": 703,
        "name": "Abyssal Leviathan",
        "description": "Defeat the Abyssal Leviathan terrorizing the Crimson Abyss.",
        "target": {"monster": "Abyssal Leviathan", "count": 1},
        "reward": {"gold": 3500, "exp": 4000, "item": "Leviathan Scale"},
        "story": True,
        "chapter": 7,
        "travel_locations": ["Crimson Abyss"]
    },
    {
        "id": 704,
        "name": "The Final Shadow",
        "description": "Confront the Shadow Master in the depths of the Crimson Abyss.",
        "target": {"monster": "Shadow Master", "count": 1},
        "reward": {"gold": 4000, "exp": 4500, "item": "Shadow Master's Cloak"},
        "story": True,
        "chapter": 7,
        "travel_locations": ["Crimson Abyss"]
    },
    {
        "id": 801,
        "name": "The Final War to end the Shadow order",
        "description": "Confront the Fallen Eternal,Noctis",
        "target": {"monster": "Dark Legionary Supreme Lord:Noctis", "count": 1},
        "reward": {"gold": 5000, "exp": 5500, "item": "Noctis's Shadow Crystal"},
        "story": True,
        "chapter": 8,
        "travel_locations": ["Dark Legion's Fortress"]
    },
    {
        "id": 1,
        "name": "Goblin Slayer",
        "description": "Kill 3 goblins",
        "target": {"monster": "Goblin", "count": 3},
        "reward": {"gold": 50, "exp": 100}
    },
    {
        "id": 2,
        "name": "Dragon Hunter",
        "description": "Defeat any dragon",
        "target": {"monster": "Dragon", "count": 1},
        "reward": {"gold": 200, "exp": 300}
    },
    {
        "id": 3,
        "name": "Howling Threat",
        "description": "Hunt down 5 wolves in the forest",
        "target": {"monster": "Wolf", "count": 5},
        "reward": {"gold": 40, "exp": 90}
    },
    {
        "id": 4,
        "name": "Skeleton Cleanup",
        "description": "Destroy 4 skeletons near the cemetery",
        "target": {"monster": "Skeleton", "count": 4},
        "reward": {"gold": 60, "exp": 110}
    },
    {
        "id": 5,
        "name": "Ghostly Presence",
        "description": "Banish 3 ghosts from Stormhaven",
        "target": {"monster": "Ghost", "count": 3},
        "reward": {"gold": 70, "exp": 150}
    },
    {
        "id": 6,
        "name": "Troll Trouble",
        "description": "Defeat 2 Cave Trolls",
        "target": {"monster": "Cave Troll", "count": 2},
        "reward": {"gold": 90, "exp": 180}
    },
    {
        "id": 7,
        "name": "Dark Knight Duel",
        "description": "Take down 1 Dark Knight in Shadowmere",
        "target": {"monster": "Dark Knight", "count": 1},
        "reward": {"gold": 120, "exp": 250}
    },
    {
        "id": 8,
        "name": "Fire Dragon Challenge",
        "description": "Defeat the Fire Dragon atop Dragon's Peak",
        "target": {"monster": "Fire Dragon", "count": 1},
        "reward": {"gold": 250, "exp": 400}
    },
    {
        "id": 9,
        "name": "Crystal Golem Rampage",
        "description": "Stop 2 Crystal Golems in Crystal Cave",
        "target": {"monster": "Crystal Golem", "count": 2},
        "reward": {"gold": 100, "exp": 200}
    },
    {
        "id": 10,
        "name": "Ice Troll Hunt",
        "description": "Eliminate 3 Ice Trolls in Frostvale",
        "target": {"monster": "Ice Troll", "count": 3},
        "reward": {"gold": 80, "exp": 170}
    },
    {
        "id": 11,
        "name": "Phoenix Feather",
        "description": "Collect 1 Phoenix Feather from the Silent Ashes",
        "target": {"monster": "Phoenix", "count": 1},
        "reward": {"gold": 300, "exp": 500}
    },
    {
        "id": 12,
        "name": "Water Elemental",
        "description": "Defeat 2 Water Elementals in Long Shui Zhen",
        "target": {"monster": "Water Elemental", "count": 2},
        "reward": {"gold": 110, "exp": 220}
    },
    {
        "id": 13,
        "name": "Sunken Depths",
        "description": "Explore the Sunken Depths and gather 3 Coral Golem parts",
        "target": {"monster": "Coral Golem", "count": 3},
        "reward": {"gold": 130, "exp": 250}
    },
    {
        "id": 14,
        "name": "Free the people",
        "description": "Free the Shogunate from the Shogun's Tyrany",
        "target": {"monster": "The Shogun", "count": 1},
        "reward": {"gold": 500, "exp": 1000}
    },
    {
        "id": 15,
        "name": "Dragon's Reach",
        "description": "Defeat the Dragon Knight in Dragon's Reach",
        "target": {"monster": "Dragon Knight", "count": 1},
        "reward": {"gold": 400, "exp": 600}
    },
    {
        "id": 16,
        "name": "Blightmoor Cleanup",
        "description": "Eliminate 5 Blight Beasts in Blightmoor",
        "target": {"monster": "Blight Beast", "count": 5},
        "reward": {"gold": 150, "exp": 300}
    },
    # New quests for Iron Caliphate of Al-Khilafah Al-Hadidiyah
    {
        "id": 553,
        "name": "Sabotage Supply Lines",
        "description": "Disrupt the Iron Caliphate's supply routes to weaken their forces.",
        "target": {"location": "The Iron Caliphate of Al-Khilafah Al-Hadidiyah", "count": 1},
        "reward": {"gold": 2000, "exp": 2500, "item": "Blueprints for Resistance Gear"},
        "story": False,
        "chapter": 5,
        "travel_locations": ["The Iron Caliphate of Al-Khilafah Al-Hadidiyah"]
    },
    {
        "id": 554,
        "name": "Rescue Imprisoned Dissidents",
        "description": "Free the dissidents imprisoned by the Iron Caliphate.",
        "target": {"npc": "Imprisoned Dissidents", "count": 1},
        "reward": {"gold": 2100, "exp": 2600, "item": "Resistance Gear"},
        "story": False,
        "chapter": 5,
        "travel_locations": ["The Iron Caliphate of Al-Khilafah Al-Hadidiyah"]
    },
    {
        "id": 505,
        "name": "Infiltrate the Palace",
        "description": "Sneak into the Iron Caliphate's palace to gather intelligence.",
        "target": {"location": "The Iron Caliphate of Al-Khilafah Al-Hadidiyah Palace", "count": 1},
        "reward": {"gold": 2200, "exp": 2700, "item": "Special Weapons"},
        "story": False,
        "chapter": 5,
        "travel_locations": ["The Iron Caliphate of Al-Khilafah Al-Hadidiyah"]
    },
    {
        "id": 506,
        "name": "Recover Stolen Artifacts",
        "description": "Retrieve artifacts stolen by the Iron Caliphate's forces.",
        "target": {"item": "Stolen Artifact", "count": 3},
        "reward": {"gold": 2300, "exp": 2800, "item": "Access to Guarded Areas"},
        "story": False,
        "chapter": 5,
        "travel_locations": ["The Iron Caliphate of Al-Khilafah Al-Hadidiyah"]
    },
    {
        "id": 507,
        "name": "Distract the Patrols",
        "description": "Create diversions to help resistance members move freely.",
        "target": {"location": "The Iron Caliphate of Al-Khilafah Al-Hadidiyah", "count": 1},
        "reward": {"gold": 1900, "exp": 2300},
        "story": False,
        "chapter": 5,
        "travel_locations": ["The Iron Caliphate of Al-Khilafah Al-Hadidiyah"]
    },
    {
        "id": 508,
        "name": "Smuggle Supplies",
        "description": "Help smuggle food and medical supplies to the resistance.",
        "target": {"location": "The Iron Caliphate of Al-Khilafah Al-Hadidiyah", "count": 1},
        "reward": {"gold": 2000, "exp": 2400},
        "story": False,
        "chapter": 5,
        "travel_locations": ["The Iron Caliphate of Al-Khilafah Al-Hadidiyah"]
    },
    # New quests for Shogunate of Shirui
    {
        "id": 433,
        "name": "Assassinate a Corrupt Official",
        "description": "Eliminate a corrupt official threatening the Shogunate's peace.",
        "target": {"npc": "Corrupt Official", "count": 1},
        "reward": {"gold": 1400, "exp": 1800, "item": "Unique Samurai Weapons"},
        "story": False,
        "chapter": 4,
        "travel_locations": ["Shogunate of Shirui"]
    },
    {
        "id": 434,
        "name": "Protect a Whistleblower",
        "description": "Escort a whistleblower safely out of the Shogunate.",
        "target": {"npc": "Whistleblower", "count": 1},
        "reward": {"gold": 1500, "exp": 1900, "item": "Ronin Armor"},
        "story": False,
        "chapter": 4,
        "travel_locations": ["Shogunate of Shirui"]
    },
    # New quests for Shadowmere
    {
        "id": 304,
        "name": "Retrieve Stolen Secrets",
        "description": "Recover secrets stolen by rival factions in Shadowmere.",
        "target": {"item": "Stolen Secrets", "count": 3},
        "reward": {"gold": 1100, "exp": 1300, "item": "Rare Magic Items"},
        "story": False,
        "chapter": 3,
        "travel_locations": ["Shadowmere"]
    },
    {
        "id": 305,
        "name": "Eliminate a Rival",
        "description": "Take out a rival threatening the Shadow Broker's operations.",
        "target": {"npc": "Rival", "count": 1},
        "reward": {"gold": 1200, "exp": 1400, "item": "Forbidden Scrolls"},
        "story": False,
        "chapter": 3,
        "travel_locations": ["Shadowmere"]
    },
    # New quests for Frostvale
    {
        "id": 306,
        "name": "Contain the Ice Wraith",
        "description": "Stop the Ice Wraith from terrorizing Frostvale.",
        "target": {"monster": "Ice Wraith", "count": 1},
        "reward": {"gold": 1300, "exp": 1500, "item": "Ice-elemental Weapons"},
        "story": False,
        "chapter": 3,
        "travel_locations": ["Frostvale"]
    },
    {
        "id": 307,
        "name": "Retrieve Magical Research",
        "description": "Find lost magical research in Frostvale.",
        "target": {"item": "Magical Research", "count": 1},
        "reward": {"gold": 1400, "exp": 1600, "item": "Frost-resistant Gear"},
        "story": False,
        "chapter": 3,
        "travel_locations": ["Frostvale"]
    },
    # New quests for Dragon's Peak
    {
        "id": 204,
        "name": "Retrieve a Specific Egg",
        "description": "Find and retrieve a rare dragon egg.",
        "target": {"item": "Dragon Egg", "count": 1},
        "reward": {"gold": 600, "exp": 700, "item": "Dragon Egg Fragments"},
        "story": False,
        "chapter": 2,
        "travel_locations": ["Dragon's Peak"]
    },
    {
        "id": 205,
        "name": "Protect a Nest",
        "description": "Defend a dragon's nest from poachers.",
        "target": {"location": "Dragon's Peak", "count": 1},
        "reward": {"gold": 650, "exp": 750, "item": "Rare Mounts"},
        "story": False,
        "chapter": 2,
        "travel_locations": ["Dragon's Peak"]
    },
    # New quests for Long Shui Zhen
    {
        "id": 308,
        "name": "Decode Ancient Dragon Texts",
        "description": "Translate ancient texts about dragons.",
        "target": {"item": "Ancient Dragon Texts", "count": 1},
        "reward": {"gold": 900, "exp": 1100, "item": "Dragon Lore Books"},
        "story": False,
        "chapter": 3,
        "travel_locations": ["Long Shui Zhen"]
    },
    {
        "id": 309,
        "name": "Find a Legendary Dragon",
        "description": "Locate a legendary dragon hidden in the mountains.",
        "target": {"monster": "Legendary Dragon", "count": 1},
        "reward": {"gold": 1000, "exp": 1200, "item": "Knowledge-based Items"},
        "story": False,
        "chapter": 3,
        "travel_locations": ["Long Shui Zhen's well"]
    },

    # Seasonal Farming Quests
    {
        "id": 451,
        "name": "Winter's Harvest",
        "description": "Grow and harvest 5 Winter Mint plants during the winter season.",
        "target": {"item": "Winter Mint", "count": 5},
        "reward": {"gold": 600, "exp": 500, "item": "Rare Winter Seeds"},
        "story": False,
        "chapter": 4,
        "requirements": {"season": "Winter"}
    },
    {
        "id": 452,
        "name": "Spring Bloom",
        "description": "Grow and harvest 5 Spring Tulips during the spring season.",
        "target": {"item": "Spring Tulips", "count": 5},
        "reward": {"gold": 550, "exp": 450, "item": "Rare Spring Seeds"},
        "story": False,
        "chapter": 4,
        "requirements": {"season": "Spring"}
    },
    {
        "id": 453,
        "name": "Summer's Bounty",
        "description": "Grow and harvest 5 Summer Melons during the summer season.",
        "target": {"item": "Summer Melon", "count": 5},
        "reward": {"gold": 700, "exp": 550, "item": "Rare Summer Seeds"},
        "story": False,
        "chapter": 4,
        "requirements": {"season": "Summer"}
    },
    {
        "id": 454,
        "name": "Autumn's Yield",
        "description": "Grow and harvest 5 Autumn Squash during the fall season.",
        "target": {"item": "Autumn Squash", "count": 5},
        "reward": {"gold": 650, "exp": 500, "item": "Rare Fall Seeds"},
        "story": False,
        "chapter": 4,
        "requirements": {"season": "Fall"}
    },

    # Weather-Dependent Quests
    {
        "id": 405,
        "name": "Storm Harvester",
        "description": "Grow and harvest 3 Thunderroots during stormy weather.",
        "target": {"item": "Thunderroot", "count": 3},
        "reward": {"gold": 800, "exp": 700, "item": "Lightning Essence"},
        "story": False,
        "chapter": 4,
        "requirements": {"weather": "stormy"}
    },
    {
        "id": 406,
        "name": "Frost Gardener",
        "description": "Grow and harvest 3 Frost Lotus plants during snowy weather.",
        "target": {"item": "Frost Lotus", "count": 3},
        "reward": {"gold": 850, "exp": 750, "item": "Frost Essence"},
        "story": False,
        "chapter": 4,
        "requirements": {"weather": "snowy"}
    },
    {
        "id": 407,
        "name": "Desert Bloom",
        "description": "Grow and harvest 3 Ghost Peppers during hot, sunny weather.",
        "target": {"item": "Ghost Pepper", "count": 3},
        "reward": {"gold": 900, "exp": 800, "item": "Fire Essence"},
        "story": False,
        "chapter": 4,
        "requirements": {"weather": "sunny"}
    },

    # Secondary Story Quests - The Weather Sage's Tale
    {
        "id": 851,
        "name": "The Weather Sage",
        "description": "Meet with the Weather Sage who lives in the mountains.",
        "target": {"npc": "Weather Sage", "count": 1},
        "reward": {"gold": 400, "exp": 350, "item": "Weather Map"},
        "story": True,
        "story_arc": "Weather Mysteries",
        "chapter": 8
    },
    {
        "id": 852,
        "name": "Collecting Weather Samples",
        "description": "Collect samples from different weather conditions for the Weather Sage.",
        "target": {"item": "Weather Sample", "count": 4},
        "reward": {"gold": 500, "exp": 450, "item": "Weather Vane"},
        "story": True,
        "story_arc": "Weather Mysteries",
        "chapter": 8,
        "prerequisite": 851
    },
    {
        "id": 853,
        "name": "The Weather Anomaly",
        "description": "Investigate the mysterious weather anomaly in the Ancient Forest.",
        "target": {"location": "Ancient Forest", "count": 1},
        "reward": {"gold": 600, "exp": 550, "item": "Weathered Pendant"},
        "story": True,
        "story_arc": "Weather Mysteries",
        "chapter": 8,
        "prerequisite": 852
    },
    {
        "id": 854,
        "name": "Confronting the Storm Entity",
        "description": "Defeat the entity causing the weather disturbances.",
        "target": {"monster": "Storm Entity", "count": 1},
        "reward": {"gold": 1000, "exp": 900, "item": "Weather Control Rod"},
        "story": True,
        "story_arc": "Weather Mysteries",
        "chapter": 8,
        "prerequisite": 853
    },

    # Dimension-Specific Secondary Stories - The Void Walker
    {
        "id": 901,
        "name": "Strange Disturbances",
        "description": "Investigate dimensional rifts appearing in various locations.",
        "target": {"item": "Dimensional Fragment", "count": 5},
        "reward": {"gold": 700, "exp": 650, "item": "Dimensional Compass"},
        "story": True,
        "story_arc": "Void Walker",
        "chapter": 9
    },
    {
        "id": 902,
        "name": "The Void Walker's Trail",
        "description": "Follow the mysterious entity that's been crossing between dimensions.",
        "target": {"location": "Dimensional Nexus", "count": 1},
        "reward": {"gold": 800, "exp": 750, "item": "Void Shard"},
        "story": True,
        "story_arc": "Void Walker",
        "chapter": 9,
        "prerequisite": 901
    },
    {
        "id": 903,
        "name": "Dimensional Guardians",
        "description": "Defeat the guardians protecting the dimensional gates.",
        "target": {"monster": "Dimension Guardian", "count": 3},
        "reward": {"gold": 900, "exp": 850, "item": "Guardian's Essence"},
        "story": True,
        "story_arc": "Void Walker",
        "chapter": 9,
        "prerequisite": 902
    },
    {
        "id": 904,
        "name": "The Void Walker's Identity",
        "description": "Discover the true identity of the Void Walker and their intentions.",
        "target": {"npc": "Void Walker", "count": 1},
        "reward": {"gold": 1200, "exp": 1100, "item": "Dimensional Key"},
        "story": True,
        "story_arc": "Void Walker",
        "chapter": 9,
        "prerequisite": 903
    }
]

# Available professions with their bonuses
PROFESSIONS = {
    # Traditional professions
    "Miner": {
        "gather_bonus": ["Iron Ore", "Gold Ore", "Silver Ore", "Mythril Ore", "Ancient Fossil"],
        "craft_bonus": ["weapons", "mining tools"],
        "special_ability": "Deep Mining",
        "ability_description": "Chance to find rare ores and gems",
        "passive_bonus": {"defense": 5},
        "level_bonuses": {
            5: "Ore Identification - Can identify rare ores without tools",
            10: "Double Mining - Chance to get double resources",
            15: "Gem Expert - Can find gems in normal mining nodes"
        }
    },
    "Herbalist": {
        "gather_bonus": ["Red Herb", "Blue Herb", "Green Herb", "Purple Herb", "Rainbow Herb"],
        "craft_bonus": ["potions", "herbal remedies"],
        "special_ability": "Herbal Knowledge",
        "ability_description": "Can identify useful herbs in any biome",
        "passive_bonus": {"health_regen": 2},
        "level_bonuses": {
            5: "Herb Preservation - Herbs stay fresh longer",
            10: "Double Harvest - Chance to gather twice as many herbs",
            15: "Rare Herb Finder - Can locate rare herbs in any biome"
        }
    },
    "Blacksmith": {
        "gather_bonus": ["Iron Ore", "Steel Ingot", "Metal Scraps"],
        "craft_bonus": ["armor", "weapons", "tools"],
        "special_ability": "Master Forging",
        "ability_description": "Chance to create superior quality equipment",
        "passive_bonus": {"attack": 3},
        "level_bonuses": {
            5: "Metal Conservation - Uses fewer materials when crafting",
            10: "Quality Crafting - Higher durability on crafted items",
            15: "Masterwork - Chance to create exceptional quality gear"
        }
    },
    "Alchemist": {
        "gather_bonus": ["Red Herb", "Magic Crystal", "Alchemical Base"],
        "craft_bonus": ["potions", "elixirs", "transmutations"],
        "special_ability": "Potion Mastery",
        "ability_description": "Potions have stronger effects",
        "passive_bonus": {"magic_defense": 5},
        "level_bonuses": {
            5: "Conservation - Chance to not consume ingredients",
            10: "Extended Effect - Potions last longer",
            15: "Alchemical Breakthrough - Can create unique potions"
        }
    },
    "Hunter": {
        "gather_bonus": ["Leather", "Monster Part", "Hunter's Trophy", "Rare Pelt"],
        "craft_bonus": ["bows", "hunting gear", "traps"],
        "special_ability": "Keen Eye",
        "ability_description": "Can track rare monsters more easily",
        "passive_bonus": {"critical_chance": 3},
        "level_bonuses": {
            5: "Clean Kill - Better quality materials from monsters",
            10: "Monster Knowledge - Increased damage against known monsters",
            15: "Rare Trophy - Chance to obtain unique monster parts"
        }
    },
    "Woodcutter": {
        "gather_bonus": ["Wood", "Rare Wood", "Ancient Bark", "Living Wood"],
        "craft_bonus": ["staves", "wooden weapons", "wooden structures"],
        "special_ability": "Lumber Expert",
        "ability_description": "Can harvest special types of wood",
        "passive_bonus": {"max_health": 10},
        "level_bonuses": {
            5: "Efficient Chopping - More wood from each tree",
            10: "Wood Whisperer - Can find magical wood types",
            15: "Ancient Forestry - Can harvest from ancient trees"
        }
    },
    "Fisher": {
        "gather_bonus": ["Fish", "Rare Fish", "Coral", "Deep Sea Treasure"],
        "craft_bonus": ["fishing gear", "water-based potions"],
        "special_ability": "Deep Fishing",
        "ability_description": "Can catch rare aquatic creatures",
        "passive_bonus": {"water_resistance": 10},
        "level_bonuses": {
            5: "Patient Angler - Better quality fish",
            10: "Treasure Hunter - Chance to find sunken treasures",
            15: "Master Baiter - Can catch legendary fish"
        }
    },
    "Archaeologist": {
        "gather_bonus": ["Ancient Relic", "Historical Artifact", "Lost Knowledge"],
        "craft_bonus": ["artifacts", "ancient weapons"],
        "special_ability": "Historian",
        "ability_description": "Can identify and restore ancient items",
        "passive_bonus": {"intelligence": 5},
        "level_bonuses": {
            5: "Careful Excavation - Better condition artifacts",
            10: "Lost Knowledge - Can read ancient texts",
            15: "Treasure Maps - Can locate hidden ruins and treasures"
        }
    },
    "Enchanter": {
        "gather_bonus": ["Magic Crystal", "Enchanted Fragment", "Arcane Dust"],
        "craft_bonus": ["enchanted items", "magical weapons"],
        "special_ability": "Mana Infusion",
        "ability_description": "Can create more powerful enchantments",
        "passive_bonus": {"magic_power": 8},
        "level_bonuses": {
            5: "Magical Insight - Can see magical properties of items",
            10: "Enchantment Mastery - Stronger enchantments",
            15: "Artifact Creation - Can create custom magical items"
        }
    },

    # New professions
    "Farmer": {
        "gather_bonus": ["Seeds", "Crop", "Fertilizer", "Exotic Seeds"],
        "craft_bonus": ["farming tools", "food", "crop-based items"],
        "special_ability": "Green Thumb",
        "ability_description": "Crops grow faster and yield more",
        "passive_bonus": {"stamina_regen": 3},
        "level_bonuses": {
            5: "Crop Rotation - Better yields from farming",
            10: "Weather Prediction - Can forecast weather changes",
            15: "Magical Agriculture - Can grow special magical crops"
        },
        "weather_bonuses": {
            "Sunny": "Solar Growth - Crops grow faster in sunny weather",
            "Rainy": "Water Conservation - Less watering needed during rain",
            "Stormy": "Lightning Infusion - Chance for crops to gain special properties"
        },
        "season_bonuses": {
            "Spring": "Spring Bloom - Better yields in spring",
            "Summer": "Summer Heat - Faster growth in summer",
            "Fall": "Harvest Bounty - More crops in fall",
            "Winter": "Cold Resilience - Can grow special winter crops"
        }
    },
    "Weather Mage": {
        "gather_bonus": ["Storm Crystal", "Weather Essence", "Elemental Core"],
        "craft_bonus": ["weather charms", "elemental weapons"],
        "special_ability": "Weather Sense",
        "ability_description": "Can predict and slightly influence weather",
        "passive_bonus": {"elemental_resistance": 10},
        "level_bonuses": {
            5: "Weather Reading - Can predict weather changes accurately",
            10: "Weather Shift - Can change weather for a short time",
            15: "Elemental Mastery - Weather effects boost elemental damage"
        },
        "weather_bonuses": {
            "Sunny": "Solar Power - Increased fire damage during sunny weather",
            "Rainy": "Hydration - Increased water damage during rainy weather",
            "Stormy": "Storm Caller - Increased lightning damage during storms",
            "Snowy": "Frost Bite - Increased ice damage during snow",
            "Windy": "Wind Rider - Increased movement speed during windy weather",
            "Foggy": "Mistsight - Can see clearly through fog"
        }
    },
    "Artifact Hunter": {
        "gather_bonus": ["Ancient Relic", "Artifact Fragment", "Lost Technology"],
        "craft_bonus": ["artifacts", "ancient weapons", "artifact restoration"],
        "special_ability": "Relic Sense",
        "ability_description": "Can sense nearby artifacts and relics",
        "passive_bonus": {"artifact_power": 15},
        "level_bonuses": {
            5: "Artifact Lore - Can identify artifact properties",
            10: "Restoration Expert - Can restore damaged artifacts",
            15: "Set Completion - Bonus when wearing complete artifact sets"
        }
    },
    "Monster Tamer": {
        "gather_bonus": ["Monster Essence", "Taming Crystal", "Beast Hide"],
        "craft_bonus": ["taming gear", "monster equipment"],
        "special_ability": "Beast Speech",
        "ability_description": "Can communicate with certain monsters",
        "passive_bonus": {"monster_relation": 50},
        "level_bonuses": {
            5: "Monster Empathy - Some monsters won't attack first",
            10: "Taming Mastery - Can tame certain monsters as companions",
            15: "Monster Bond - Tamed monsters are more powerful"
        }
    }
}

# Initialize user data with proper typing
user_data = {
    "name": None,
    "class": None,
    "profession": None,
    "has_chosen_profession": False,
    "level": 1,
    "inventory": [],
    "equipped": {"weapon": None, "armor": None},
    "gold": INITIAL_GOLD,
    "coolness": 0,
    "guild": None,
    "pets": [],
    "progress": "starter",
    "exp": 0,
    "health": INITIAL_HEALTH,
    "max_health": INITIAL_HEALTH,
    "attack": 10,
    "defense": 0,
    "speed": 5,
    "skills": [],
    "active_quests": [],
    "completed_quests": [],
    "materials": {},
    "tools": ["Axe", "Pickaxe", "Flask", "Hunting Knife"],
    "current_area": "Greenwood Village",
    "monsters_killed": 0,
    "dungeons_completed": [],
    # Dimension system data
    "current_dimension": "Overworld",
    "dimensions_discovered": ["Overworld"],
    "dimension_keys": [],
    # Home/camp system data
    "home_structures": {"Tent": {"built": True, "position": [0, 0], "health": 100}},
    "home_location": "Camp"
}

# Load literature data from JSON file
try:
    with open('Legacies_Literature.json', 'r') as f:
        LITERATURE_DATA = json.load(f)
except FileNotFoundError:
    LITERATURE_DATA = {"books": {}, "scrolls": {}, "notes": {}}

# Literature quests - unlocked by reading specific books, scrolls, or notes
LITERATURE_QUESTS = [
    {
        "id": "the_whispering_crown",
        "name": "The Whispering Crown",
        "description": "Investigate the strange behavior of the king after discovering an ancient curse in the royal wizard's diary.",
        "level_requirement": 15,
        "location_requirement": "Royal Castle",
        "unlock_requirements": {
            "literature": ["Notes:Personal Journals:Diary of a Court Wizard"]
        },
        "objectives": [
            {
                "type": "examine",
                "target": "Royal Crown",
                "description": "Examine the king's crown without raising suspicion",
                "location": "Royal Castle"
            },
            {
                "type": "find",
                "target": "Book of Counter-Enchantments",
                "description": "Find the Book of Counter-Enchantments in the Royal Archives",
                "location": "Royal Archives"
            },
            {
                "type": "defeat",
                "target": "Crown Guardian",
                "description": "Defeat the magical guardian protecting the crown",
                "location": "Royal Castle"
            },
            {
                "type": "use",
                "target": "Counter-Enchantment",
                "description": "Use the counter-enchantment on the crown",
                "location": "Royal Castle"
            }
        ],
        "rewards": {
            "gold": 1500,
            "exp": 2000,
            "items": ["Royal Gratitude", "Arcane Tome of Silence"],
            "reputation": {
                "Kingdom": 100
            }
        }
    },
    {
        "id": "the_sunken_treasury",
        "name": "The Sunken Treasury",
        "description": "Follow an ancient map to recover treasures from a ship that sank centuries ago.",
        "level_requirement": 10,
        "location_requirement": "Coastal Town",
        "unlock_requirements": {
            "literature": ["Scrolls:Ancient Maps:Map to the Sunken Treasury"]
        },
        "objectives": [
            {
                "type": "travel",
                "target": "Offshore Location",
                "description": "Travel to the marked location during the twin moons alignment",
                "location": "Coastal Waters"
            },
            {
                "type": "defeat",
                "target": "Sea Guardian",
                "description": "Defeat the guardian protecting the sunken ship",
                "location": "Coastal Waters"
            },
            {
                "type": "collect",
                "target": "Royal Chest",
                "description": "Recover the royal chest from the captain's quarters",
                "location": "Sunken Ship"
            },
            {
                "type": "return",
                "target": "Coastal Town",
                "description": "Return safely to the coastal town with the treasure",
                "location": "Coastal Town"
            }
        ],
        "rewards": {
            "gold": 2500,
            "exp": 1800,
            "items": ["Trident of the Seas", "Water Breathing Amulet"],
            "reputation": {
                "Coastal Town": 75
            }
        }
    },
    {
        "id": "the_silent_watchtower",
        "name": "The Silent Watchtower",
        "description": "Investigate what happened to the border patrol after finding an ominous warning letter.",
        "level_requirement": 12,
        "location_requirement": "Eastern Border",
        "unlock_requirements": {
            "literature": ["Notes:Letters:Warning from the Watchtower"]
        },
        "objectives": [
            {
                "type": "travel",
                "target": "Abandoned Watchtower",
                "description": "Travel to the abandoned watchtower at the eastern border",
                "location": "Eastern Border"
            },
            {
                "type": "investigate",
                "target": "Patrol Records",
                "description": "Search for patrol records and clues",
                "location": "Abandoned Watchtower"
            },
            {
                "type": "defeat",
                "target": "Shadow Creatures",
                "description": "Defeat the strange creatures lurking in the watchtower",
                "location": "Abandoned Watchtower"
            },
            {
                "type": "rescue",
                "target": "Survivors",
                "description": "Find and rescue any survivors",
                "location": "Abandoned Watchtower"
            },
            {
                "type": "report",
                "target": "Eastern Garrison",
                "description": "Report your findings to the Eastern Garrison",
                "location": "Eastern Garrison"
            }
        ],
        "rewards": {
            "gold": 1200,
            "exp": 1600,
            "items": ["Scout's Bow", "Shadow Essence"],
            "reputation": {
                "Kingdom": 60,
                "Eastern Garrison": 100
            }
        }
    },
    {
        "id": "seeking_the_guardian_beasts",
        "name": "Seeking the Guardian Beasts",
        "description": "Track down the mythical guardian beasts to seek their blessings.",
        "level_requirement": 20,
        "location_requirement": "Deep Forest",
        "unlock_requirements": {
            "literature": ["Books:Mythical Legends:The Guardian Beasts"]
        },
        "objectives": [
            {
                "type": "travel",
                "target": "Volcanic Crown",
                "description": "Journey to the Volcanic Crown mountains to seek the Phoenix",
                "location": "Volcanic Crown"
            },
            {
                "type": "offer",
                "target": "Phoenix Tribute",
                "description": "Present a worthy offering to the Phoenix",
                "location": "Phoenix Nest"
            },
            {
                "type": "travel",
                "target": "Forgotten Sea",
                "description": "Travel to the depths of the Forgotten Sea to find the Leviathan",
                "location": "Forgotten Sea"
            },
            {
                "type": "offer",
                "target": "Rare Pearls",
                "description": "Offer rare pearls to the Leviathan",
                "location": "Abyssal Depths"
            },
            {
                "type": "travel",
                "target": "Whispering Woods",
                "description": "Find the Great Elk in the heart of the Whispering Woods",
                "location": "Whispering Woods"
            },
            {
                "type": "offer",
                "target": "Forest Tribute",
                "description": "Present an offering of preserved ancient seeds",
                "location": "Hidden Grove"
            }
        ],
        "rewards": {
            "gold": 3000,
            "exp": 5000,
            "items": ["Phoenix Feather", "Leviathan Scale", "Elk Antler Fragment"],
            "abilities": ["Beast Communication", "Elemental Harmony"],
            "reputation": {
                "Natural World": 200
            }
        }
    },
    {
        "id": "bandit_elimination",
        "name": "Forest Bandits Bounty",
        "description": "Eliminate the bandit leader 'Shadowstep' and his crew who are harassing travelers.",
        "level_requirement": 8,
        "location_requirement": "Eastern Forest Road",
        "unlock_requirements": {
            "literature": ["Scrolls:Royal Decrees:Bounty on the Forest Bandits"]
        },
        "objectives": [
            {
                "type": "travel",
                "target": "Eastern Forest Road",
                "description": "Patrol the Eastern Forest Road for signs of bandit activity",
                "location": "Eastern Forest Road"
            },
            {
                "type": "track",
                "target": "Bandit Camp",
                "description": "Follow the bandit tracks to locate their hidden camp",
                "location": "Deep Forest"
            },
            {
                "type": "defeat",
                "target": "Bandit Guards",
                "description": "Defeat the bandit sentries",
                "location": "Bandit Camp"
            },
            {
                "type": "defeat",
                "target": "Shadowstep",
                "description": "Defeat the bandit leader 'Shadowstep'",
                "location": "Bandit Camp"
            },
            {
                "type": "collect",
                "target": "Proof of Completion",
                "description": "Collect Shadowstep's signature dagger as proof",
                "location": "Bandit Camp"
            },
            {
                "type": "return",
                "target": "Royal Guard Captain",
                "description": "Present the proof to the Royal Guard Captain",
                "location": "Kingdom Capital"
            }
        ],
        "rewards": {
            "gold": 500,
            "exp": 1000,
            "items": ["Shadowstep's Cloak", "Royal Commendation"],
            "reputation": {
                "Kingdom": 50,
                "Merchants Guild": 75
            }
        }
    }
]

# New locations related to the literature system
NEW_LOCATIONS = [
    {
        "id": "village_library",
        "name": "Village Library",
        "description": "A quaint building housing scrolls and books collected by the villagers over generations.",
        "level_range": [1, 3],
        "enemies": [],
        "literature": [
            "Books:Crafting Guides:Alchemy of Growth", 
            "Notes:Recipes:Grandmother's Healing Stew"
        ],
        "points_of_interest": [
            "Librarian's Desk",
            "Reading Nook",
            "Children's Section",
            "Local History Shelf"
        ],
        "npcs": [
            {
                "name": "Eliza Pagebinder",
                "role": "Village Librarian",
                "dialogue": [
                    "Welcome to our humble library! Feel free to browse our collection.",
                    "We have many practical books on farming and crafting that the villagers find useful.",
                    "If you're interested in local legends, check the shelf by the window. Some fascinating stories there!",
                    "The children love story time. I read to them every evening before sunset."
                ]
            }
        ]
    },
    {
        "id": "royal_archives",
        "name": "Royal Archives",
        "description": "The kingdom's vast repository of knowledge, accessible only to those with special permission.",
        "level_range": [15, 20],
        "enemies": ["Royal Guard", "Scholar"],
        "literature": [
            "Books:Ancient Tomes:The Lost Kingdom",
            "Scrolls:Royal Decrees:Charter of Exploration"
        ],
        "points_of_interest": [
            "Restricted Section",
            "Royal Historians' Study",
            "Map Room",
            "Ancient Manuscripts Vault"
        ],
        "npcs": [
            {
                "name": "Archivist Thaddeus",
                "role": "Royal Archivist",
                "dialogue": [
                    "State your business. The Royal Archives are not open to the general public.",
                    "Every document here is cataloged and accounted for. Nothing leaves without proper authorization.",
                    "The restricted section? That requires approval from the Royal Council itself.",
                    "Some of these documents date back to the founding of the kingdom itself. Handle with utmost care!"
                ]
            }
        ]
    },
    {
        "id": "great_library",
        "name": "Great Library",
        "description": "An ancient library from a forgotten age, containing knowledge from civilizations long past.",
        "level_range": [18, 25],
        "enemies": ["Animated Book", "Ink Elemental", "Knowledge Seeker"],
        "literature": [
            "Books:Mythical Legends:The Divine Concordance",
            "Books:Ancient Tomes:Elemental Harmonies"
        ],
        "points_of_interest": [
            "Infinite Stacks",
            "Whispering Gallery",
            "Constellation Chamber",
            "Forbidden Tomes Section"
        ],
        "npcs": [
            {
                "name": "The Keeper",
                "role": "Ancient Guardian",
                "dialogue": [
                    "Few find their way here. What knowledge do you seek, wanderer?",
                    "The library exists in many places and times at once. Be careful where you step.",
                    "Books here are not merely read—they experience you as much as you experience them.",
                    "Some knowledge was never meant to be found again. Heed the warnings on sealed texts."
                ]
            }
        ]
    },
    {
        "id": "abandoned_study",
        "name": "Abandoned Study",
        "description": "The private study of a powerful wizard, left untouched for centuries and filled with arcane texts.",
        "level_range": [20, 30],
        "enemies": ["Animated Quill", "Book Mimic", "Arcane Construct"],
        "literature": [
            "Scrolls:Spell Scrolls:Scroll of Teleportation"
        ],
        "points_of_interest": [
            "Wizard's Desk",
            "Experimental Apparatus",
            "Arcane Circle",
            "Personal Library"
        ],
        "npcs": [
            {
                "name": "Echo of Archmagus Valorian",
                "role": "Magical Remnant",
                "dialogue": [
                    "...interrupt my work... who dares... oh, a visitor after all this time?",
                    "My research... did it succeed? Did it fail? I cannot remember...",
                    "Be careful with those scrolls. Some are... unstable... without proper preparation.",
                    "If you seek my greatest works, look beneath the floorboards. I trust no one with their keeping."
                ]
            }
        ]
    },
    {
        "id": "secret_thieves_guild",
        "name": "Secret Thieves' Guild",
        "description": "A hidden underground complex where thieves and assassins gather to trade secrets and stolen goods.",
        "level_range": [15, 25],
        "enemies": ["Thief", "Assassin", "Guild Enforcer"],
        "literature": [
            "Notes:Recipes:Assassin's Poison Primer"
        ],
        "points_of_interest": [
            "Black Market",
            "Training Grounds",
            "Guildmaster's Office",
            "Treasure Vault"
        ],
        "npcs": [
            {
                "name": "Shadowhand Vex",
                "role": "Guild Lieutenant",
                "dialogue": [
                    "Who vouched for you? We don't take kindly to uninvited guests.",
                    "The guild has eyes everywhere. Cross us, and there's nowhere to hide.",
                    "Need something... special? For the right price, anything can be arranged.",
                    "The Guildmaster only meets with those who've proven their worth. Come back when you've made a name for yourself."
                ]
            }
        ]
    }
]

# Default AREAS dictionary if not defined elsewhere
AREAS = {
    "Greenwood Village": {
        "description": "A small village surrounded by dense forest. The local inn offers cheap accommodation.",
        "mobs": ["Wolf", "Boar", "Bandit"],
        "level_range": (1, 5),
        "biome": "Forest",
        "travel_options": ["Mountainside", "Coastal Town", "Deep Forest", "Monster Plains"]
    },
    "Mountainside": {
        "description": "Rocky terrain with sparse vegetation. Home to dangerous mountain creatures.",
        "mobs": ["Mountain Lion", "Rock Elemental", "Troll"],
        "level_range": (5, 10),
        "biome": "Mountain",
        "travel_options": ["Greenwood Village", "Mountain Peak", "Deep Cave"]
    },
    "Kingdom Capital": {
        "description": "The bustling capital city with markets, guilds, and the royal castle.",
        "mobs": ["Guard", "Thief", "Noble"],
        "level_range": (5, 15),
        "biome": "Urban",
        "travel_options": ["Greenwood Village", "Royal Castle", "Merchant District"]
    }
}

# Function to integrate new locations into the game world
def integrate_new_locations() -> None:
    """Add the new literature-related locations to appropriate area connections in the game world"""

    # Add Village Library to Greenwood Village connections
    if "Greenwood Village" in AREAS:
        if "travel_options" not in AREAS["Greenwood Village"]:
            AREAS["Greenwood Village"]["travel_options"] = []
        if "Village Library" not in AREAS["Greenwood Village"]["travel_options"]:
            AREAS["Greenwood Village"]["travel_options"].append("Village Library")

    # Create new locations based on NEW_LOCATIONS
    for location in NEW_LOCATIONS:
        # Get the name and use it directly (no need for location_id)
        name = location["name"]

        if name not in AREAS:
            AREAS[name] = {
                "description": location["description"],
                "mobs": location.get("enemies", []),
                "level_range": tuple(location["level_range"]) if "level_range" in location else (1, 5),
                "biome": "Settlement" if "enemies" not in location or not location["enemies"] else "Magical",
                "travel_options": []
            }

            # Connect locations based on their types
            if name == "Village Library":
                AREAS[name]["travel_options"] = ["Greenwood Village"]
            elif name == "Royal Archives":
                AREAS[name]["travel_options"] = ["Kingdom Capital", "Great Library"]
            elif name == "Great Library":
                AREAS[name]["travel_options"] = ["Royal Archives", "Abandoned Study"]
            elif name == "Abandoned Study":
                AREAS[name]["travel_options"] = ["Great Library"]
            elif name == "Secret Thieves' Guild":
                AREAS[name]["travel_options"] = ["Kingdom Capital", "Underground Passages"]

# Call the function to integrate new locations
integrate_new_locations()

def ensure_user_data_keys(data: Dict) -> None:
    defaults = {
        "class": None,
        "profession": None,
        "has_chosen_profession": False,
        "level": 1,
        "inventory": [],
        "equipped": {"weapon": None, "armor": None},
        "gold": INITIAL_GOLD,
        "literature": {
            "discovered": [],
            "read": [],
            "owned": []
        },
        "coolness": 0,
        "guild": None,
        "pets": [],
        "legendary_pets": {},
        "ships": {},
        "navigation": {
            "maps": ["Sealtea Map"],
            "discovered_regions": ["Sealtea"],
            "ocean_routes": []
        },
        "progress": "starter",
        "exp": 0,
        "health": INITIAL_HEALTH,
        "max_health": INITIAL_HEALTH,
        "attack": 10,
        "defense": 0,
        "speed": 5,
        "skills": [],
        "active_quests": [],
        "completed_quests": [],
        "materials": {},
        "tools": ["Axe", "Pickaxe", "Flask", "Hunting Knife"],
        "current_area": "Greenwood Village",
        "monsters_killed": 0,
        "dungeons_completed": [],
        # Dimension system data
        "current_dimension": "Overworld",
        "dimensions_discovered": ["Overworld"],
        "dimension_keys": [],
        # Home/camp system data
        "home_structures": {"Tent": {"built": True, "position": [0, 0], "health": 100}},
        "home_location": "Camp",
        # Archaeology system data
        "archaeology": {
            "discovered_sites": [],
            "excavated_artifacts": [],
            "knowledge": [],
            "tools": ["Basic Trowel"],
            "museum_exhibits": [],
            "excavation_skill": 1,
            "analysis_skill": 1,
            "artifact_collections": {},
            "site_levels": {},
            "current_site": None,
            "rare_discoveries": [],
            "excavation_dates": {},
            "last_excavation": None
        },
        # Character gacha system
        "gacha": {
            "characters": [],
            "weapons": [],
            "memory_shards": {},  # Character constellation system
            "character_pity_5star": 0,  # Pity counter for 5-star characters
            "character_pity_4star": 0,  # Pity counter for 4-star characters
            "weapon_pity_5star": 0,     # Pity counter for 5-star weapons
            "weapon_pity_4star": 0,     # Pity counter for 4-star weapons
            "memory_dust": 0,           # Currency for memory shop
            "primogems": 1600,          # Gacha currency
            "fates": 0,                 # Pull tokens 
            "last_5star_was_featured": False,  # For 50/50 system on limited banners
            "daily_login": {
                "last_login": None,     # Last login date for daily rewards
                "login_streak": 0,      # Consecutive days logged in
                "claimed_milestones": [] # Milestone rewards claimed
            },
            "farmed_materials": {},     # Farming materials for characters and weapons
            "character_levels": {},     # Character levels (1-90)
            "weapon_levels": {},        # Weapon levels (1-90)
            "weapon_refinements": {},   # Weapon refinement levels (1-5)
            "equipped_weapons": {},     # Characters -> equipped weapons mapping
            "active_party": []          # Currently active characters (up to 4)
        },
        "achievements": {
            "completed": set(),
            "stats": {
                "monsters_killed": 0,
                "items_crafted": 0,
                "bosses_defeated": 0,
                "quests_completed": 0,
                "areas_visited": set(),
                "crops_harvested": 0,
                "max_damage_dealt": 0,
                "total_gold_earned": 0,
                "rare_items_found": 0,
                "characters_collected": 0,
                "weapons_collected": 0,
                "gacha_pulls": 0
            }
        }
    }
    for key, default_value in defaults.items():
        if key not in data:
            data[key] = default_value
        else:
            # For nested dicts, ensure keys exist recursively
            if isinstance(default_value, dict) and isinstance(data[key], dict):
                for subkey, subdefault in default_value.items():
                    if subkey not in data[key]:
                        data[key][subkey] = subdefault

                    # Handle nested dictionaries one level deeper
                    if isinstance(subdefault, dict) and isinstance(data[key][subkey], dict):
                        for sub_subkey, sub_subdefault in subdefault.items():
                            if sub_subkey not in data[key][subkey]:
                                data[key][subkey][sub_subkey] = sub_subdefault


# Market prices for items and materials
MARKET_PRICES = {
    # Basic Materials
    "Wood": 5,
    "Iron Ore": 8,
    "Gold Ore": 15,
    "Red Herb": 3,
    "Water Flask": 2,
    "Leather": 4,
    "Steel Ingot": 12,
    "Magic Crystal": 20,

    # Crops and Seeds
    "Wheat": 8,
    "Corn": 12,
    "Tomato": 15,
    "Potato": 18,
    "Rice": 20,
    "Carrot": 12,
    "Lettuce": 8,
    "Strawberry": 18,

    # Monster Drops
    "Dragon Scale": 100,
    "Phoenix Feather": 200,
    "Wolf Pelt": 15,
    "Spider Silk": 10,
    "Spirit Essence": 25,
    "Soul Gem": 50,
    "Demon's Heart": 500,
    "Leviathan Scale": 400,

    # Common Equipment
    "Wooden Sword": 15,
    "Iron Sword": 40,
    "Steel Sword": 75,
    "Bone Armor": 20,
    "Iron Armor": 50,
    "Steel Armor": 90,

    # Rare Equipment
    "Flame Sword": 150,
    "Ice Sword": 150,
    "Shadow Blade": 475,
    "Dragon Armor": 425,
    "Samurai Armor": 650,
    "Cursed Katana": 750,

    # Legendary Equipment
    "Elder Wand": 400,
    "Vorpal Blade": 250,
    "Phoenix Plate": 300,
    "Mjolnir": 500,
    "Dragon Scale Armor": 425,
    "Iron Caliph's Crown": 1000,
}

def sell_item(item_name: str) -> None:
    if not item_name:
        print("Please specify an item to sell.")
        return

    # Case-insensitive search in inventory
    item = next((i for i in user_data["inventory"] if i.lower() == item_name.lower()), None)
    if not item:
        print(f"You don't have {item_name} in your inventory.")
        return

    # Check if item has a market price
    if item not in MARKET_PRICES:
        print("This item cannot be sold.")
        return

    # Remove from inventory and add gold
    user_data["inventory"].remove(item)
    price = MARKET_PRICES[item]
    user_data["gold"] += price
    print(f"Sold {item} for {price} gold.")

# Shop items
shop_items = [
    # === Basic Equipment ===
    {"name": "Wooden Sword", "type": "weapon", "effect": 5, "price": 30},
    {"name": "Iron Sword", "type": "weapon", "effect": 10, "price": 80},
    {"name": "Steel Sword", "type": "weapon", "effect": 15, "price": 150},
    {"name": "Bone Armor", "type": "armor", "effect": 5, "price": 40},
    {"name": "Iron Armor", "type": "armor", "effect": 10, "price": 100},
    {"name": "Steel Armor", "type": "armor", "effect": 15, "price": 180},
    {"name": "Bronze Dagger", "type": "weapon", "effect": 7, "price": 50},
    {"name": "Chainmail", "type": "armor", "effect": 8, "price": 75},

    # === Consumables ===
    {"name": "Healing Potion", "type": "consumable", "effect": 30, "price": 20},
    {"name": "Greater Healing Potion", "type": "consumable", "effect": 60, "price": 50},
    {"name": "Antidote", "type": "consumable", "effect": "cure_poison", "price": 25},
    {"name": "Mega Healing Potion", "type": "consumable", "effect": 60, "price": 50},
    {"name": "Mana Potion", "type": "consumable", "effect": 40, "price": 35},
    {"name": "Stamina Elixir", "type": "consumable", "effect": "restore_stamina", "price": 30},
    {"name": "Revival Herb", "type": "consumable", "effect": "revive", "price": 100},
    {"name": "Energy Drink", "type": "consumable", "effect": 25, "price": 15},

    # === Special Equipment ===
    {"name": "Magic Staff", "type": "weapon", "effect": 12, "price": 200},
    {"name": "Shadow Cloak", "type": "armor", "effect": 8, "price": 90},
    {"name": "Flame Dagger", "type": "weapon", "effect": 12, "price": 130},
    {"name": "Leather Armor", "type": "armor", "effect": 7, "price": 70},
    {"name": "Bow of the Eagle", "type": "weapon", "effect": 14, "price": 160},
    {"name": "Throwing Knife", "type": "weapon", "effect": 6, "price": 45},
    {"name": "Obsidian Greatsword", "type": "weapon", "effect": 18, "price": 220},
    {"name": "Dragonhide Vest", "type": "armor", "effect": 12, "price": 150},
    {"name": "Silver Rapier", "type": "weapon", "effect": 16, "price": 190},
    {"name": "Enchanted Robes", "type": "armor", "effect": 10, "price": 120},
    {"name": "Crossbow", "type": "weapon", "effect": 13, "price": 140},
    {"name": "Tower Shield", "type": "armor", "effect": 14, "price": 170},

    # === Exotic Equipment ===
    {"name": "Vorpal Blade", "type": "weapon", "effect": 25, "price": 500, "special": "Ignores armor"},
    {"name": "Phoenix Plate", "type": "armor", "effect": 20, "price": 600, "special": "Self-repair over time"},
    {"name": "Elder Wand", "type": "weapon", "effect": 30, "price": 800, "special": "Chance to cast spells for free"},
    {"name": "Cloak of Invisibility", "type": "armor", "effect": 15, "price": 700, "special": "Temporary stealth on use"},
    {"name": "Mjolnir", "type": "weapon", "effect": 35, "price": 1000, "special": "Lightning strikes on critical hits"},
    {"name": "Aegis of the Gods", "type": "armor", "effect": 25, "price": 900, "special": "Blocks all critical hits"},

    # === More Exotic Items from Monster Drops ===
    {"name": "Crimson Cutlass", "type": "weapon", "effect": 28, "price": 750, "special": "Bleeds enemies over time", "source": "Dreadlord Varkhull"},
    {"name": "Dragon Armor", "type": "armor", "effect": 22, "price": 850, "special": "Resistant to fire/ice/lightning", "source": "Dragon Knight"},
    {"name": "Undead Blade", "type": "weapon", "effect": 30, "price": 900, "special": "Life steal (10% of damage)", "source": "Undead Knight"},
    {"name": "Jade Crown", "type": "armor", "effect": 25, "price": 1200, "special": "+20% max HP", "source": "Jade Emperor"},
    {"name": "Shadow Blade", "type": "weapon", "effect": 32, "price": 950, "special": "Critical hits deal 3x damage", "source": "Shadow Samurai"},
    {"name": "Phoenix Feather", "type": "consumable", "effect": "full_revive", "price": 800, "special": "Revives with full HP", "source": "Phoenix"},
    {"name": "Cursed Katana", "type": "weapon", "effect": 40, "price": 1500, "special": "Deals self-damage (5% per hit)", "source": "Possessed Katana"},
    {"name": "Samurai Armor", "type": "armor", "effect": 30, "price": 1300, "special": "Counterattacks when hit", "source": "The Shogun"},
    {"name": "Kitsune Mask", "type": "armor", "effect": 18, "price": 700, "special": "Illusionary clones confuse enemies", "source": "Kitsune Warrior"},
    {"name": "Storm Eye", "type": "consumable", "effect": "summon_storm", "price": 600, "special": "Calls lightning on enemies (3 uses)", "source": "Vision of the Thunder"},
    {"name": "Frozen Soul", "type": "consumable", "effect": "freeze_enemies", "price": 500, "special": "Freezes all enemies for 1 turn", "source": "Hatred frozen soul"},

    # === Elemental Lord Equipment ===
    {"name": "Blazing Warhammer", "type": "weapon", "effect": 55, "price": 3500, "special": "Ignites enemies", "source": "Ignis, Lord of Flames", "element": "Ignis"},
    {"name": "Frost Giant's Axe", "type": "weapon", "effect": 52, "price": 3200, "special": "Slows enemies", "source": "Glacies, Frost Sovereign", "element": "Glacies"},
    {"name": "Storm Caller Staff", "type": "weapon", "effect": 48, "price": 3400, "special": "Chain lightning effect", "source": "Fulmen, Storm Emperor", "element": "Fulmen"},
    {"name": "Earthshaker Maul", "type": "weapon", "effect": 58, "price": 3600, "special": "Stuns enemies", "source": "Terra, Earth Colossus", "element": "Gē"},
    {"name": "Tidecaller Trident", "type": "weapon", "effect": 50, "price": 3300, "special": "Drowns enemies", "source": "Aquarius, Tide Master", "element": "Aqua"},

    {"name": "Inferno Plate", "type": "armor", "effect": 45, "price": 3800, "special": "Fire resistance", "source": "Ignis, Lord of Flames", "element": "Ignis"},
    {"name": "Glacier Mail", "type": "armor", "effect": 42, "price": 3500, "special": "Ice resistance", "source": "Glacies, Frost Sovereign", "element": "Glacies"},
    {"name": "Thunderstorm Garb", "type": "armor", "effect": 40, "price": 3600, "special": "Lightning resistance", "source": "Fulmen, Storm Emperor", "element": "Fulmen"},
    {"name": "Mountain's Heart Plate", "type": "armor", "effect": 48, "price": 3900, "special": "Earth resistance", "source": "Terra, Earth Colossus", "element": "Gē"},
    {"name": "Deep Sea Armor", "type": "armor", "effect": 43, "price": 3700, "special": "Water resistance", "source": "Aquarius, Tide Master", "element": "Aqua"},

    # === Four Horsemen Equipment ===
    {"name": "Victor's Bow", "type": "weapon", "effect": 65, "price": 8000, "special": "Always strikes first", "source": "Conquest, The White Rider", "element": "Lux"},
    {"name": "Warlord's Greatsword", "type": "weapon", "effect": 75, "price": 8500, "special": "Causes bleeding", "source": "War, The Red Rider", "element": "Ignis"},
    {"name": "Famine's Scythe", "type": "weapon", "effect": 70, "price": 8200, "special": "Drains life", "source": "Famine, The Black Rider", "element": "Gē"},
    {"name": "Death's Reaper", "type": "weapon", "effect": 85, "price": 9000, "special": "Instant death chance", "source": "Death, The Pale Rider", "element": "Nullum"},

    {"name": "Armor of Conquest", "type": "armor", "effect": 60, "price": 8200, "special": "Victory aura", "source": "Conquest, The White Rider", "element": "Lux"},
    {"name": "Blood-Soaked Plate", "type": "armor", "effect": 65, "price": 8500, "special": "Returns damage", "source": "War, The Red Rider", "element": "Ignis"},
    {"name": "Withering Mail", "type": "armor", "effect": 62, "price": 8300, "special": "Weakens attackers", "source": "Famine, The Black Rider", "element": "Gē"},
    {"name": "Shroud of the Reaper", "type": "armor", "effect": 70, "price": 9000, "special": "Fear aura", "source": "Death, The Pale Rider", "element": "Nullum"}
]

monsters = [
    # Greenwood Village Monsters (Level 1-2)
    {"name": "Goblin", "level": 1, "health": 50, "attack": 10, "drops": ["Gold Coin", "Wooden Sword"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Wolf", "level": 2, "health": 60, "attack": 12, "drops": ["Wolf Pelt", "Gold Coin"], "element": "Aer", "immunities": ["Aer"]},
    {"name": "Forest Spider", "level": 1, "health": 45, "attack": 8, "drops": ["Spider Silk", "Gold Coin"], "element": "Venēnum", "immunities": ["Venēnum"]},
    {"name": "Bandit", "level": 2, "health": 65, "attack": 14, "drops": ["Leather Armor", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Dire Wolf", "level": 2, "health": 70, "attack": 15, "drops": ["Wolf Fang", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Goblin Shaman", "level": 2, "health": 55, "attack": 13, "drops": ["Goblin Staff", "Gold Coin"], "boss": True, "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Goblin King", "level": 3, "health": 80, "attack": 20, "drops": ["Goblin Crown", "Gold Coin"], "boss": True, "element": "Gē", "immunities": ["Gē"]},

    # Added missing monsters
    {"name": "Dragon Whelp", "level": 4, "health": 100, "attack": 25, "drops": ["Dragon Scale", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Shadow Master", "level": 10, "health": 300, "attack": 60, "drops": ["Shadow Master's Cloak", "Gold Coin"], "boss": True, "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Blight Beast", "level": 7, "health": 180, "attack": 40, "drops": ["Blight Beast Claw", "Gold Coin"], "element": "Venēnum", "immunities": ["Venēnum"]},

    # Stormhaven Monsters (Level 2-3)
    {"name": "Skeleton", "level": 2, "health": 75, "attack": 15, "drops": ["Gold Coin", "Bone Armor"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Ghost", "level": 3, "health": 70, "attack": 18, "drops": ["Spirit Essence", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Storm Elemental", "level": 3, "health": 85, "attack": 20, "drops": ["Storm Crystal", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Pirate Scout", "level": 2, "health": 70, "attack": 16, "drops": ["Cutlass", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Haunted Armor", "level": 3, "health": 80, "attack": 22, "drops": ["Cursed Shield", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Sea Serpent", "level": 3, "health": 90, "attack": 25, "drops": ["Serpent Scale", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Dreadlord Varkhull, the Crimson Abyss Pirate Captain", "level": 5, "health": 150, "attack": 30, "drops": ["Crimson Cutlass", "Gold Coin"], "boss": True, "element": "Ferrum", "immunities": ["Ferrum"]},

    # Dragon's Peak Monsters (Level 5-6)
    {"name": "Fire Dragon", "level": 6, "health": 200, "attack": 35, "drops": ["Dragon Scale", "Gold Coin", "Flame Sword"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Ice Dragon", "level": 6, "health": 200, "attack": 35, "drops": ["Dragon Scale", "Gold Coin", "Ice Sword"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Electrical Dragon", "level": 6, "health": 200, "attack": 35, "drops": ["Dragon Scale", "Gold Coin", "Lightning Sword"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Plant Dragon", "level": 6, "health": 200, "attack": 35, "drops": ["Dragon Scale", "Gold Coin", "Nature Sword"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Earth Dragon", "level": 6, "health": 200, "attack": 35, "drops": ["Dragon Scale", "Gold Coin", "Earth Sword"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Wind Dragon", "level": 6, "health": 200, "attack": 35, "drops": ["Dragon Scale", "Gold Coin", "Wind Sword"], "element": "Aer", "immunities": ["Aer"]},
    {"name": "Water Dragon", "level": 6, "health": 200, "attack": 35, "drops": ["Dragon Scale", "Gold Coin", "Water Sword"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Fire Wyvern", "level": 5, "health": 150, "attack": 28, "drops": ["Wyvern Scale", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Ice Wyvern", "level": 5, "health": 150, "attack": 28, "drops": ["Wyvern Scale", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Thunder Wyvern", "level": 5, "health": 150, "attack": 28, "drops": ["Wyvern Scale", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Earth Wyvern", "level": 5, "health": 150, "attack": 28, "drops": ["Wyvern Scale", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Dragon Knight", "level": 5, "health": 150, "attack": 28, "drops": ["Dragon Armor", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Water Wyvern", "level": 5, "health": 160, "attack": 30, "drops": ["Wyvern Wing", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Dragon Overlord", "level": 12, "health": 600, "attack": 90, "drops": ["Dragon Scale", "Dragonfire Sword", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Ignis"]},

    # Crystal Cave Monsters (Level 3-4)
    {"name": "Crystal Golem", "level": 4, "health": 120, "attack": 25, "drops": ["Crystal Shard", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Cave Troll", "level": 4, "health": 130, "attack": 28, "drops": ["Troll Hide", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Crystal Spider", "level": 3, "health": 90, "attack": 22, "drops": ["Crystal Web", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Rock Elemental", "level": 4, "health": 140, "attack": 26, "drops": ["Earth Stone", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Cave Bat", "level": 3, "health": 80, "attack": 20, "drops": ["Bat Wing", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Crystal Tarantula", "level": 4, "health": 110, "attack": 24, "drops": ["Crystal Fang", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Crystal Giant Tarantula", "level": 7, "health": 200, "attack": 40, "drops": ["Crystal Eye", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Crystal Serpent", "level": 4, "health": 110, "attack": 24, "drops": ["Serpent Scale", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Corrupted Miner", "level": 4, "health": 115, "attack": 25, "drops": ["Miner's Pickaxe", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},

    # Shadowmere Monsters (Level 4-5)
    {"name": "Shadow Beast", "level": 4, "health": 110, "attack": 24, "drops": ["Shadow Essence", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Dark Knight", "level": 5, "health": 140, "attack": 28, "drops": ["Dark Armor", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Wraith", "level": 5, "health": 120, "attack": 30, "drops": ["Soul Gem", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Night Stalker", "level": 4, "health": 100, "attack": 26, "drops": ["Night Blade", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Shadow Assassin", "level": 5, "health": 130, "attack": 32, "drops": ["Assassin's Dagger", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Vampire", "level": 5, "health": 150, "attack": 35, "drops": ["Vampire Fang", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Undead Knight", "level": 5, "health": 160, "attack": 38, "drops": ["Undead Blade", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Undead Army General","level": 7, "health": 200, "attack": 40, "drops": ["Undead Armor", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Undead Army Commander","level": 8, "health": 250, "attack": 50, "drops": ["Undead's Blade", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},

    # Frostvale Monsters (Level 3-4)
    {"name": "Ice Troll", "level": 4, "health": 125, "attack": 26, "drops": ["Frozen Heart", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Frost Giant", "level": 4, "health": 140, "attack": 28, "drops": ["Giant's Club", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Snow Wolf", "level": 3, "health": 95, "attack": 20, "drops": ["Frost Pelt", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Ice Elemental", "level": 4, "health": 115, "attack": 24, "drops": ["Ice Crystal", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Frost Wraith", "level": 4, "health": 130, "attack": 30, "drops": ["Wraith Essence", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Hatred frozen soul", "level": 5, "health": 150, "attack": 35, "drops": ["Frozen Soul", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Ice Revenant", "level": 5, "health": 160, "attack": 32, "drops": ["Frozen Heart", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Frost vengeful eye of the snow", "level": 7, "health": 200, "attack": 40, "drops": ["Frost Eye", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},

    # Long Shui Zhen Monsters (Level 4-8)
    {"name": "Dragon Spirit", "level": 5, "health": 130, "attack": 28, "drops": ["Spirit Pearl", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Water Elemental", "level": 4, "health": 110, "attack": 24, "drops": ["Water Essence", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Jade Warrior", "level": 5, "health": 140, "attack": 26, "drops": ["Jade Sword", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Jade General", "level": 5, "health": 150, "attack": 30, "drops": ["Jade Armor", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Jade soldier", "level": 4, "health": 120, "attack": 22, "drops": ["Jade Shield", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Jade Emperor's Guard", "level": 6, "health": 160, "attack": 32, "drops": ["Jade Shield", "Gold Coin"], "element": "Lux", "immunities": ["Lux"]},
    {"name": "Jade Emperor", "level": 8, "health": 390, "attack": 65, "drops": ["Jade Crown", "Gold Coin"], "element": "Lux", "immunities": ["Lux"]},
    {"name": "Legendary Dragon", "level": 8, "health": 400, "attack": 70, "drops": ["Dragon Scale", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},

    # Jade Lotus Village Monsters (Level 2-3)
    {"name": "Lotus Spirit", "level": 3, "health": 85, "attack": 18, "drops": ["Lotus Petal", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Pond Serpent", "level": 2, "health": 70, "attack": 16, "drops": ["Serpent Scale", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Garden Guardian", "level": 3, "health": 90, "attack": 20, "drops": ["Sacred Charm", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Lotus Guardian", "level": 3, "health": 95, "attack": 22, "drops": ["Lotus Shield", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Koi Empress", "level": 3, "health": 100, "attack": 24, "drops": ["Koi Scale", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},

    # Silent Ashes Monsters (Level 5-6)
    {"name": "Ash Revenant", "level": 6, "health": 160, "attack": 32, "drops": ["Revenant Ash", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Cursed Wanderer", "level": 5, "health": 140, "attack": 28, "drops": ["Cursed Relic", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Phoenix", "level": 6, "health": 180, "attack": 34, "drops": ["Phoenix Feather", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Ash Wraith", "level": 5, "health": 150, "attack": 30, "drops": ["Wraith Essence", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Burnt Guardian", "level": 5, "health": 145, "attack": 29, "drops": ["Guardian's Ash", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Magmatic Knight,The fallen knight of the ashes", "level": 6, "health": 200, "attack": 40, "drops": ["Knight's Ash", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},

    # Thundercliff Hold Monsters (Level 4-5)
    {"name": "Thunder Elemental", "level": 5, "health": 130, "attack": 28, "drops": ["Storm Crystal", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Rock Wyvern", "level": 4, "health": 120, "attack": 26, "drops": ["Wyvern Scale", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Storm Hawk", "level": 4, "health": 110, "attack": 24, "drops": ["Hawk Feather", "Gold Coin"], "element": "Aer", "immunities": ["Aer"]},
    {"name": "Storm Wyvern", "level": 5, "health": 140, "attack": 30, "drops": ["Wyvern Wing", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Thunder Mage", "level": 5, "health": 150, "attack": 32, "drops": ["Thunder Staff", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Storm Guardian", "level": 5, "health": 160, "attack": 34, "drops": ["Guardian's Storm", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Vision of the Thunder,the core of the storm", "level": 5, "health": 150, "attack": 32, "drops": ["Storm Eye", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},

    # Shogunate Of Shirui Monsters (Level 5-12)
    {"name": "The Shogun", "level": 12, "health": 400, "attack": 70, "drops": ["Samurai Armor", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Shogun's Guard", "level": 8, "health": 350, "attack": 60, "drops": ["Shogun's Blade", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Jade Samurai", "level": 7, "health": 300, "attack": 50, "drops": ["Jade Armor", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Kitsune Warrior", "level": 6, "health": 250, "attack": 40, "drops": ["Kitsune Mask", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Tengu Warrior", "level": 6, "health": 240, "attack": 38, "drops": ["Tengu Feather", "Gold Coin"], "element": "Aer", "immunities": ["Aer"]},
    {"name": "Kappa Guardian", "level": 5, "health": 220, "attack": 35, "drops": ["Kappa Shell", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Oni Berserker", "level": 7, "health": 280, "attack": 45, "drops": ["Oni Mask", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Corrupted Ninja", "level": 5, "health": 200, "attack": 30, "drops": ["Ninja Star", "Gold Coin"], "element": "Venēnum", "immunities": ["Venēnum"]},
    {"name": "Shadow Samurai", "level": 6, "health": 260, "attack": 42, "drops": ["Shadow Blade", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Possessed Katana", "level": 5, "health": 210, "attack": 36, "drops": ["Cursed Katana", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},

    # The Iron Caliphate of Al-Khilafah Al-Hadidiyah Monsters (Level 7-12)
    {"name": "Az-Zālim al-Muqaddas,The Caliph of Al-Khilafah Al-Hadidiyah", "level": 12, "health": 500, "attack": 80, "drops": ["Iron Caliph's Crown", "Gold Coin"], "boss": True, "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Al-Hadidiyah Guardian", "level": 11, "health": 450, "attack": 75, "drops": ["Guardian's Blade", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Al-Hadidiyah Knight", "level": 10, "health": 400, "attack": 70, "drops": ["Knight's Shield", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Mercenary of the caliphate", "level": 9, "health": 350, "attack": 65, "drops": ["Mercenary's Dagger", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Loyalist of the caliphate", "level": 8, "health": 300, "attack": 60, "drops": ["Loyalist's Blade", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "High Priest of the caliphate", "level": 7, "health": 250, "attack": 55, "drops": ["High Priest's Staff", "Gold Coin"], "element": "Lux", "immunities": ["Lux"]},
    {"name": "Al-Hadidiyah Sorcerer", "level": 7, "health": 240, "attack": 50, "drops": ["Sorcerer's Tome", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Steel Golem", "level": 8, "health": 280, "attack": 60, "drops": ["Steel Core", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Royal Janissary", "level": 9, "health": 320, "attack": 65, "drops": ["Janissary's Blade", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Iron Caliphate General", "level": 10, "health": 370, "attack": 70, "drops": ["General's Armor", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},


    #  Tlācahcāyōtl Tletl Tecpanēcatl/Empire of the Sacred Fire and Chains Monsters (Level 7-12)
    {"name": "Tēcpatl Tlamacazqui,The Emperor of the Sacred Fire and Chains", "level": 12, "health": 550, "attack": 85, "drops": ["Emperor's Crown", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Secret Police from The Order of the Black Sun (Yohualli Tōnatiuh)", "level": 10, "health": 400, "attack": 70, "drops": ["Black Sun Dagger", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Knight", "level": 11, "health": 450, "attack": 75, "drops": ["Knight's Shield", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Guardian", "level": 9, "health": 350, "attack": 65, "drops": ["Guardian's Blade", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Sorcerer", "level": 8, "health": 300, "attack": 60, "drops": ["Sorcerer's Tome", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl High Priest", "level": 7, "health": 250, "attack": 55, "drops": ["High Priest's Staff", "Gold Coin"], "element": "Lux", "immunities": ["Lux"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Mercenary", "level": 9, "health": 320, "attack": 65, "drops": ["Mercenary's Dagger", "Gold Coin"], "element": "Ferrum", "immunities": ["Ferrum"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Loyalist", "level": 8, "health": 280, "attack": 60, "drops": ["Loyalist's Blade", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Royal Guard", "level": 10, "health": 370, "attack": 70, "drops": ["Royal Guard's Sword", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},

     # Crimson Abyss Monsters (Level 9-16)
    {"name": "Crimson Abyss Demon", "level": 15, "health": 600, "attack": 100, "drops": ["Demon's Heart", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Crimson Abyss Knight", "level": 14, "health": 550, "attack": 90, "drops": ["Knight's Blade", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Crimson Abyss Sorcerer", "level": 13, "health": 500, "attack": 80, "drops": ["Sorcerer's Staff", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Crimson Abyss Guardian", "level": 12, "health": 450, "attack": 75, "drops": ["Guardian's Shield", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Abyssal Leviathan", "level": 16, "health": 700, "attack": 120, "drops": ["Leviathan Scale", "Gold Coin"], "boss": True, "element": "Aqua", "immunities": ["Aqua"]},

    # The Dark Legion (Level 17-20)
    {"name": "Dark Legion Elite", "level": 17, "health": 800, "attack": 130, "drops": ["Dark Legion Armor", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Dark Legion Warlock", "level": 18, "health": 750, "attack": 140, "drops": ["Warlock Staff", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Dark Legion Commander", "level": 19, "health": 900, "attack": 150, "drops": ["Commander's Blade", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Dark Legion's Shadow Assassin", "level": 17, "health": 700, "attack": 160, "drops": ["Shadow Dagger", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Dark Legion Archpriest", "level": 18, "health": 850, "attack": 145, "drops": ["Dark Tome", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Dark Legionary Supreme Lord:Noctis, the Obsidian Fallen Eternal", 
 "level": 20, 
 "health": 2000, 
 "attack": 250, 
 "drops": ["Eternal Crown", "Obsidian Blade", "Dark Legion's Heart", "Gold Coin", "Noctis's Soul"], 
 "boss": True,
 "special_abilities": {
     "Dark Oblivion": {"damage": 400, "effect": "health_drain"},
     "Shadow Legion": {"effect": "summon_minions", "minions": ["Dark Legion Elite", "Dark Legion Warlock"]},
     "Eternal Darkness": {"effect": "damage_reduction", "duration": 3},
     "Obsidian Shield": {"effect": "reflect_damage", "duration": 2}
 },
 "phases": 3,
 "phase_triggers": [0.7, 0.3],  # Triggers at 70% and 30% health
 "unique_mechanics": True,
 "description": "The supreme ruler of the Dark Legion, wielding powers of eternal darkness and commanding legions of the fallen. Each phase unleashes new devastating abilities."
},
    {"name": "Dark Legion's Shadow Knight", "level": 19, "health": 950, "attack": 170, "drops": ["Shadow Knight's Blade", "Gold Coin"]},
    {"name": "Dark Legion's Shadow Sorcerer", "level": 18, "health": 800, "attack": 160, "drops": ["Shadow Sorcerer's Staff", "Gold Coin"]},
    {"name": "Dark Legion's Shadow Guardian", "level": 17, "health": 750, "attack": 150, "drops": ["Shadow Guardian's Shield", "Gold Coin"]},

    # Post-game dungeon monsters
    {"name": "Void Reaper", "level": 25, "health": 2500, "attack": 300, "drops": ["Void Scythe", "Void Crystal", "Gold Coin"], "boss": True, "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Ancient Dragon God", "level": 30, "health": 3000, "attack": 400, "drops": ["Divine Dragon Scale", "Dragon God's Crown", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Eternal Phoenix", "level": 28, "health": 2800, "attack": 350, "drops": ["Eternal Flame", "Phoenix Crown", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Aqua"]},
    {"name": "Chaos Incarnate", "level": 35, "health": 3500, "attack": 450, "drops": ["Chaos Blade", "Chaos Crystal", "Gold Coin"], "boss": True, "element": "Nullum", "immunities": []},
    {"name": "Abyssal Overlord", "level": 40, "health": 4000, "attack": 500, "drops": ["Abyssal Crown", "Infinity Stone", "Gold Coin"], "boss": True, "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Dragon Elite Guard", "level": 32, "health": 3200, "attack": 420, "drops": ["Elite Dragon Scale", "Dragon Guard Armor", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Phoenix Guardian", "level": 30, "health": 3000, "attack": 380, "drops": ["Phoenix Feather", "Guardian's Flame", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Chaos Spawn", "level": 33, "health": 3300, "attack": 430, "drops": ["Chaos Shard", "Spawn Crystal", "Gold Coin"], "element": "Nullum", "immunities": []},
    {"name": "Abyss Dweller", "level": 38, "health": 3800, "attack": 480, "drops": ["Dweller's Heart", "Abyssal Fragment", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Void Dragon", "level": 45, "health": 5000, "attack": 600, "drops": ["Void Dragon Scale", "Void Crown", "Gold Coin"], "boss": True, "element": "Tenebrae", "immunities": ["Tenebrae", "Lux"]},

    # New Mid-Level Bosses (15-25)
    {"name": "Archmage Zephyrius", "level": 15, "health": 800, "attack": 120, "drops": ["Zephyr Staff", "Wind Crystal", "Gold Coin"], "boss": True, "element": "Pneuma", "immunities": ["Pneuma"], "special_ability": "Summons tornadoes that deal area damage"},
    {"name": "Warlord Magmar", "level": 18, "health": 950, "attack": 140, "drops": ["Magma Battleaxe", "Molten Core", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Ignis"], "special_ability": "Enrages at low health, increasing attack by 50%"},
    {"name": "Lady Crystallia", "level": 20, "health": 1100, "attack": 150, "drops": ["Crystal Scepter", "Diamond Heart", "Gold Coin"], "boss": True, "element": "Gē", "immunities": ["Gē"], "special_ability": "Creates crystal shields that must be broken first"},
    {"name": "Admiral Hydros", "level": 22, "health": 1250, "attack": 160, "drops": ["Trident of the Deep", "Abyssal Pearl", "Gold Coin"], "boss": True, "element": "Aqua", "immunities": ["Aqua"], "special_ability": "Summons tidal waves that push players back"},
    {"name": "Necrolord Morbius", "level": 25, "health": 1400, "attack": 175, "drops": ["Death's Embrace", "Soul Gem", "Gold Coin"], "boss": True, "element": "Tenebrae", "immunities": ["Tenebrae"], "special_ability": "Resurrects fallen minions to fight alongside him"},

    # New High-Level Bosses (35-50)
    {"name": "The Celestial Arbiter", "level": 35, "health": 3500, "attack": 300, "drops": ["Astral Judgment", "Star Fragment", "Gold Coin"], "boss": True, "element": "Lux", "immunities": ["Lux"], "special_ability": "Can banish players temporarily from battle"},
    {"name": "Queen Titania of the Fae", "level": 38, "health": 3800, "attack": 320, "drops": ["Titania's Blessing", "Fae Crown", "Gold Coin"], "boss": True, "element": "Vita", "immunities": ["Vita"], "special_ability": "Charms players to fight for her temporarily"},
    {"name": "Overlord Infernus", "level": 40, "health": 4200, "attack": 350, "drops": ["Infernal Mantle", "Demon's Heart", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Ignis", "Aqua"], "special_ability": "Sets the battlefield ablaze, causing damage over time"},
    {"name": "The World Serpent", "level": 45, "health": 4800, "attack": 380, "drops": ["Serpent Scale Mail", "Primordial Fang", "Gold Coin"], "boss": True, "element": "Venēnum", "immunities": ["Venēnum", "Gē"], "special_ability": "Coils around players, reducing their movement and attack speed"},
    {"name": "Chronos, Master of Time", "level": 48, "health": 5200, "attack": 400, "drops": ["Timekeeper's Watch", "Crystallized Time", "Gold Coin"], "boss": True, "element": "Nullum", "immunities": ["Nullum"], "special_ability": "Can rewind time to heal himself or reset player abilities"},

    # Ultimate Bosses (50+)
    {"name": "The Void Empress", "level": 50, "health": 6000, "attack": 500, "drops": ["Void Empress Crown", "Black Hole Core", "Void-Touched Weapon", "Gold Coin"], "boss": True, "element": "Tenebrae", "immunities": ["Tenebrae", "Lux", "Pneuma"], "special_ability": "Creates zones of emptiness that nullify all abilities"},
    {"name": "Primal Elemental Titan", "level": 55, "health": 7000, "attack": 550, "drops": ["Primal Essence", "Elemental Heart", "Titan's Greatsword", "Gold Coin"], "boss": True, "element": "Nullum", "immunities": [], "special_ability": "Changes elemental affinity throughout battle"},
    {"name": "Xal'gathoth, The Unknowable", "level": 60, "health": 8000, "attack": 600, "drops": ["Maddening Whisper", "Tentacle of the Deep", "Xal'gathoth's Eye", "Gold Coin"], "boss": True, "element": "Nullum", "immunities": ["Tenebrae", "Lux"], "special_ability": "Induces insanity in players, causing them to attack allies"},
    {"name": "The Worldbreaker", "level": 70, "health": 10000, "attack": 700, "drops": ["Worldbreaker Fragment", "Cosmic Shard", "Reality-Warping Gauntlet", "Gold Coin"], "boss": True, "element": "Nullum", "immunities": ["Ignis", "Aqua", "Pneuma", "Gē", "Lux", "Tenebrae"], "special_ability": "Can destroy parts of reality, removing player abilities temporarily"},
    {"name": "Time Keeper", "level": 42, "health": 4500, "attack": 550, "drops": ["Chronos Crystal", "Time Keeper's Staff", "Gold Coin"], "boss": True, "element": "Aer", "immunities": ["Aer"]},
    {"name": "Celestial Titan", "level": 48, "health": 5500, "attack": 650, "drops": ["Celestial Heart", "Titan's Crown", "Gold Coin"], "boss": True, "element": "Lux", "immunities": ["Lux"]},
    {"name": "Dimensional Horror", "level": 50, "health": 6000, "attack": 700, "drops": ["Horror Essence", "Dimensional Shard", "Gold Coin"], "boss": True, "element": "Tenebrae", "immunities": ["Tenebrae", "Lux"]},

    # New Elemental Lords bosses
    {"name": "Ignis, Lord of Flames", "level": 38, "health": 3800, "attack": 480, "drops": ["Heart of Fire", "Blazing Crown", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Glacies, Frost Sovereign", "level": 38, "health": 3800, "attack": 460, "drops": ["Core of Ice", "Frozen Crown", "Gold Coin"], "boss": True, "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Fulmen, Storm Emperor", "level": 38, "health": 3700, "attack": 490, "drops": ["Lightning Heart", "Storm Crown", "Gold Coin"], "boss": True, "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Terra, Earth Colossus", "level": 38, "health": 4000, "attack": 450, "drops": ["Earth Core", "Mountain Crown", "Gold Coin"], "boss": True, "element": "Gē", "immunities": ["Gē"]},
    {"name": "Aquarius, Tide Master", "level": 38, "health": 3800, "attack": 470, "drops": ["Ocean Heart", "Coral Crown", "Gold Coin"], "boss": True, "element": "Aqua", "immunities": ["Aqua"]},

    # Four Horsemen boss series
    {"name": "Conquest, The White Rider", "level": 52, "health": 5500, "attack": 700, "drops": ["White Bow", "Victor's Crown", "Gold Coin"], "boss": True, "element": "Lux", "immunities": ["Lux", "Tenebrae"]},
    {"name": "War, The Red Rider", "level": 54, "health": 5800, "attack": 750, "drops": ["Bloodthirsty Blade", "Warlord's Crown", "Gold Coin"], "boss": True, "element": "Ignis", "immunities": ["Ignis", "Aqua"]},
    {"name": "Famine, The Black Rider", "level": 56, "health": 6000, "attack": 720, "drops": ["Scales of Balance", "Crown of Hunger", "Gold Coin"], "boss": True, "element": "Gē", "immunities": ["Gē", "Viridia"]},
    {"name": "Death, The Pale Rider", "level": 60, "health": 7000, "attack": 800, "drops": ["Soul Scythe", "Pale Crown", "Gold Coin", "Final Judgment"], "boss": True, "element": "Nullum", "immunities": ["Tenebrae", "Lux"]},

    # New minions for elemental lords and horsemen
    {"name": "Winter Wolf", "level": 34, "health": 3400, "attack": 400, "drops": ["Wolf Fang", "Frost Crystal", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"]},
    {"name": "Lightning Elemental", "level": 34, "health": 3300, "attack": 420, "drops": ["Charged Crystal", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Stone Golem", "level": 34, "health": 3600, "attack": 380, "drops": ["Ancient Fossil", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Celestial Warrior", "level": 48, "health": 4800, "attack": 580, "drops": ["Celestial Armor", "Gold Coin"], "element": "Lux", "immunities": ["Lux"]},
    {"name": "Blood Knight", "level": 50, "health": 5000, "attack": 620, "drops": ["Blood-Stained Armor", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Withered Guardian", "level": 52, "health": 5200, "attack": 630, "drops": ["Life Essence", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Reaper's Assistant", "level": 56, "health": 5600, "attack": 680, "drops": ["Soul Fragment", "Gold Coin"], "element": "Tenebrae", "immunities": ["Tenebrae"]},
    {"name": "Temporal Guardian", "level": 40, "health": 4000, "attack": 500, "drops": ["Paradox Shard", "Gold Coin"], "element": "Aer", "immunities": ["Aer"]},
    {"name": "Astral Entity", "level": 44, "health": 4400, "attack": 550, "drops": ["Star Fragment", "Gold Coin"], "element": "Lux", "immunities": ["Lux"]},

    # Weather-dependent monsters
    {"name": "Lightning Wyvern", "level": 20, "health": 1200, "attack": 180, "drops": ["Storm Scale", "Lightning Crystal", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"], "weather": "Stormy"},
    {"name": "Mist Wraith", "level": 18, "health": 900, "attack": 150, "drops": ["Ethereal Essence", "Ghost Cloth", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"], "weather": "Foggy"},
    {"name": "Blizzard Beast", "level": 22, "health": 1300, "attack": 190, "drops": ["Frozen Heart", "Ice Crystal", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"], "weather": "Snowy"},
    {"name": "Sunlight Elemental", "level": 21, "health": 1100, "attack": 170, "drops": ["Radiant Core", "Bright Crystal", "Gold Coin"], "element": "Lux", "immunities": ["Lux"], "weather": "Sunny"},
    {"name": "Gale Harpy", "level": 19, "health": 950, "attack": 160, "drops": ["Razor Feather", "Wind Crystal", "Gold Coin"], "element": "Aer", "immunities": ["Aer"], "weather": "Windy"},
    {"name": "Mud Golem", "level": 20, "health": 1250, "attack": 165, "drops": ["Clay Core", "Mud Stone", "Gold Coin"], "element": "Gē", "immunities": ["Gē"], "weather": "Rainy"},
    {"name": "Cloud Skimmer", "level": 19, "health": 980, "attack": 155, "drops": ["Cloud Fragment", "Sky Essence", "Gold Coin"], "element": "Aer", "immunities": ["Aer"], "weather": "Cloudy"},

    # Seasonal monsters
    {"name": "Winter Frost Monarch", "level": 25, "health": 1500, "attack": 200, "drops": ["Frost Crown", "Winter Essence", "Gold Coin"], "element": "Glacies", "immunities": ["Glacies"], "season": "Winter"},
    {"name": "Spring Bloom Guardian", "level": 24, "health": 1400, "attack": 190, "drops": ["Petal Crown", "Spring Essence", "Gold Coin"], "element": "Viridia", "immunities": ["Viridia"], "season": "Spring"},
    {"name": "Summer Flame Salamander", "level": 26, "health": 1550, "attack": 210, "drops": ["Burning Scale", "Summer Essence", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"], "season": "Summer"},
    {"name": "Autumn Harvest Keeper", "level": 25, "health": 1450, "attack": 195, "drops": ["Harvest Crown", "Autumn Essence", "Gold Coin"], "element": "Gē", "immunities": ["Gē"], "season": "Autumn"},

    # Farming quest monsters
    {"name": "Gargantuan Turnip", "level": 15, "health": 500, "attack": 80, "drops": ["Giant Turnip Seeds", "Vegetable Essence", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Crop Devourer", "level": 18, "health": 800, "attack": 120, "drops": ["Fertilizer", "Pest Control", "Gold Coin"], "element": "Venēnum", "immunities": ["Venēnum"]},
    {"name": "Soil Defiler", "level": 20, "health": 900, "attack": 150, "drops": ["Purified Soil", "Earth Crystal", "Gold Coin"], "element": "Gē", "immunities": ["Gē"]},
    {"name": "Phantom Scarecrow", "level": 22, "health": 1000, "attack": 170, "drops": ["Enchanted Straw", "Fear Essence", "Gold Coin"], "element": "Pneuma", "immunities": ["Pneuma"]},
    {"name": "Berry Behemoth", "level": 16, "health": 600, "attack": 100, "drops": ["Giant Berry Seeds", "Fruit Essence", "Gold Coin"], "element": "Viridia", "immunities": ["Viridia"]},

    # Elemental infusion monsters
    {"name": "Thunderstruck Wolf", "level": 28, "health": 1700, "attack": 230, "drops": ["Charged Pelt", "Shock Fang", "Gold Coin"], "element": "Fulmen", "immunities": ["Fulmen"]},
    {"name": "Molten Spider", "level": 27, "health": 1600, "attack": 220, "drops": ["Heat-resistant Silk", "Lava Venom", "Gold Coin"], "element": "Ignis", "immunities": ["Ignis"]},
    {"name": "Abyssal Crab", "level": 29, "health": 1800, "attack": 240, "drops": ["Deep Sea Shell", "Pressure Crystal", "Gold Coin"], "element": "Aqua", "immunities": ["Aqua"]},
    {"name": "Crystal Serpent", "level": 30, "health": 1900, "attack": 250, "drops": ["Crystal Scale", "Prismatic Essence", "Gold Coin"], "element": "Lux", "immunities": ["Lux"]}
]

# Post-game dungeons will be added to the dungeons list after its definition



ACHIEVEMENTS = {
    "First Steps": {"desc": "Create your character", "reward": {"gold": 100}},
    "Monster Hunter": {"desc": "Kill 100 monsters", "reward": {"gold": 500}},
    "Dragon Slayer": {"desc": "Kill any dragon", "reward": {"exp": 1000}},
    "Master Crafter": {"desc": "Craft 50 items", "reward": {"gold": 1000}},
    "Dungeon Master": {"desc": "Complete all dungeons", "reward": {"gold": 5000}},
    "Legendary Hero": {"desc": "Reach level 50", "reward": {"gold": 10000}},
    "Material Master": {"desc": "Collect all materials", "reward": {"gold": 2000}},
    "Rich Merchant": {"desc": "Accumulate 100000 gold", "reward": {"exp": 5000}},
    "Pet Collector": {"desc": "Adopt 5 pets", "reward": {"gold": 1500}},
    "Master Farmer": {"desc": "Harvest 1000 crops", "reward": {"gold": 3000}}
}

# Track achievement progress
def check_achievements() -> None:
    """
    Enhanced achievement system with tiers, categories, and visual feedback
    """

    # All achievement categories
    all_achievements = {
        "Combat": [],
        "Wealth": [],
        "Experience": [],
        "Exploration": [],
        "Collection": [],
        "Crafting": [],
        "Quests": [],
        "Archaeology": [],
        "Literature": []
    }

    # Define archaeology-related achievements if not already defined
    archaeology_achievements = [
        {
            "id": "novice_archaeologist",
            "name": "Novice Archaeologist",
            "description": "Discover your first archaeological site.",
            "condition": "Discover 1 site",
            "tier": 1,
            "category": "Archaeology"
        },
        {
            "id": "amateur_archaeologist",
            "name": "Amateur Archaeologist",
            "description": "Discover 3 archaeological sites.",
            "condition": "Discover 3 sites",
            "tier": 2,
            "category": "Archaeology"
        },
        {
            "id": "professional_archaeologist",
            "name": "Professional Archaeologist",
            "description": "Discover all archaeological sites.",
            "condition": "Discover all sites",
            "tier": 3,
            "category": "Archaeology"
        },
        {
            "id": "artifact_collector",
            "name": "Artifact Collector",
            "description": "Complete your first artifact set.",
            "condition": "Complete 1 artifact set",
            "tier": 2,
            "category": "Archaeology"
        },
        {
            "id": "master_collector",
            "name": "Master Collector",
            "description": "Complete 3 artifact sets.",
            "condition": "Complete 3 artifact sets",
            "tier": 3,
            "category": "Archaeology"
        },
        {
            "id": "knowledge_seeker",
            "name": "Knowledge Seeker",
            "description": "Acquire your first piece of ancient knowledge.",
            "condition": "Acquire 1 ancient knowledge",
            "tier": 1,
            "category": "Archaeology"
        },
        {
            "id": "ancient_scholar",
            "name": "Ancient Scholar",
            "description": "Acquire all pieces of ancient knowledge.",
            "condition": "Acquire all ancient knowledge",
            "tier": 3,
            "category": "Archaeology"
        },
        {
            "id": "museum_curator",
            "name": "Museum Curator",
            "description": "Display 5 artifacts in your museum.",
            "condition": "Display 5 artifacts",
            "tier": 2,
            "category": "Archaeology"
        },
        {
            "id": "master_curator",
            "name": "Master Curator",
            "description": "Display 10 artifacts in your museum.",
            "condition": "Display 10 artifacts",
            "tier": 3,
            "category": "Archaeology"
        }
    ]

    # Add literature-related achievements
    literature_achievements = [
        {
            "id": "novice_reader",
            "name": "Novice Reader",
            "description": "Read your first book or scroll.",
            "condition": "Read 1 book",
            "tier": 1,
            "category": "Literature"
        },
        {
            "id": "bookworm",
            "name": "Bookworm",
            "description": "Read 10 different books and scrolls.",
            "condition": "Read 10 texts",
            "tier": 2,
            "category": "Literature"
        },
        {
            "id": "scholar",
            "name": "Scholar",
            "description": "Read 25 different books and scrolls.",
            "condition": "Read 25 texts",
            "tier": 3,
            "category": "Literature"
        },
        {
            "id": "collector_of_knowledge",
            "name": "Collector of Knowledge",
            "description": "Own 15 different books and scrolls in your collection.",
            "condition": "Collect 15 texts",
            "tier": 2,
            "category": "Literature"
        },
        {
            "id": "master_of_lore",
            "name": "Master of Lore",
            "description": "Read at least one book from every category.",
            "condition": "Read diverse texts",
            "tier": 3,
            "category": "Literature"
        }
    ]

    # Add archaeology and literature achievements to achievements list
    all_achievement_types = {
        "Archaeology": archaeology_achievements,
        "Literature": literature_achievements
    }

    for category, achievements_list in all_achievement_types.items():
        if category not in all_achievements:
            all_achievements[category] = []

        # Check if achievements need to be added
        existing_ids = {ach.get("id", "") for ach in all_achievements[category]}
        for achievement in achievements_list:
            if achievement["id"] not in existing_ids:
                all_achievements[category].append(achievement)
    # Initialize achievements structure if not exists
    if "achievements" not in user_data:
        user_data["achievements"] = {
            "unlocked": [],
            "progress": {
                "monsters_killed": 0,
                "items_crafted": 0,
                "dungeons_completed": 0,
                "crops_harvested": 0,
                "bosses_defeated": 0,
                "quests_completed": 0,
                "areas_visited": set(),
                "max_damage_dealt": 0,
                "total_gold_earned": 0,
                "rare_items_found": 0,
                "critical_hits": 0,
                "combo_finishers": 0,
                "skills_used": 0,
                "items_collected": 0,
                "potions_used": 0,
                "deaths": 0,
                "enemies_dodged": 0,
                "gold_spent": 0,
                "distance_traveled": 0,
                "treasure_chests_opened": 0
            }
        }

    # Update current achievement progress based on user_data
    update_achievement_progress()

    # Define all achievements with requirements, rewards, and categories
    ACHIEVEMENTS = [
        # Combat Achievements - Tier 1
        {
            "id": "first_blood",
            "name": "First Blood",
            "description": "Defeat your first monster",
            "category": "Combat",
            "tier": 1,
            "requirement": {"monsters_killed": 1},
            "reward": {"gold": 50, "exp": 100},
            "icon": "🗡️"
        },
        {
            "id": "monster_hunter",
            "name": "Monster Hunter",
            "description": "Defeat 100 monsters",
            "category": "Combat",
            "tier": 2,
            "requirement": {"monsters_killed": 100},
            "reward": {"gold": 500, "exp": 500, "stat_bonus": {"attack": 2}},
            "icon": "⚔️"
        },
        {
            "id": "monster_slayer",
            "name": "Monster Slayer",
            "description": "Defeat 500 monsters",
            "category": "Combat",
            "tier": 3,
            "requirement": {"monsters_killed": 500},
            "reward": {"gold": 2000, "exp": 2000, "stat_bonus": {"attack": 5}},
            "icon": "🛡️"
        },
        {
            "id": "legendary_hunter",
            "name": "Legendary Hunter",
            "description": "Defeat 1000 monsters",
            "category": "Combat",
            "tier": 4,
            "requirement": {"monsters_killed": 1000},
            "reward": {"gold": 5000, "exp": 5000, "stat_bonus": {"attack": 10, "defense": 5}, "item": "Hunter's Trophy"},
            "icon": "🏆"
        },

        # Boss Achievements
        {
            "id": "boss_challenge",
            "name": "Boss Challenger",
            "description": "Defeat your first boss",
            "category": "Combat",
            "tier": 1,
            "requirement": {"bosses_defeated": 1},
            "reward": {"gold": 200, "exp": 300},
            "icon": "👺"
        },
        {
            "id": "boss_slayer",
            "name": "Boss Slayer",
            "description": "Defeat 5 different bosses",
            "category": "Combat",
            "tier": 2,
            "requirement": {"bosses_defeated": 5},
            "reward": {"gold": 1000, "exp": 1500, "stat_bonus": {"attack": 3, "defense": 3}},
            "icon": "👹"
        },
        {
            "id": "boss_master",
            "name": "Boss Master",
            "description": "Defeat 15 different bosses",
            "category": "Combat",
            "tier": 3,
            "requirement": {"bosses_defeated": 15},
            "reward": {"gold": 3000, "exp": 4000, "stat_bonus": {"attack": 7, "defense": 7}, "item": "Boss Master's Crown"},
            "icon": "👑"
        },

        # Skill Achievements
        {
            "id": "skill_novice",
            "name": "Skill Novice",
            "description": "Use skills 50 times",
            "category": "Combat",
            "tier": 1,
            "requirement": {"skills_used": 50},
            "reward": {"exp": 200, "stat_bonus": {"intellect": 2}},
            "icon": "✨"
        },
        {
            "id": "skill_adept",
            "name": "Skill Adept",
            "description": "Use skills 200 times",
            "category": "Combat",
            "tier": 2,
            "requirement": {"skills_used": 200},
            "reward": {"exp": 800, "stat_bonus": {"intellect": 5}},
            "icon": "💫"
        },
        {
            "id": "skill_master",
            "name": "Skill Master",
            "description": "Use skills 500 times",
            "category": "Combat",
            "tier": 3,
            "requirement": {"skills_used": 500},
            "reward": {"exp": 2000, "stat_bonus": {"intellect": 10}, "item": "Spellbinder's Tome"},
            "icon": "🌟"
        },

        # Combo Achievements
        {
            "id": "combo_striker",
            "name": "Combo Striker",
            "description": "Perform 10 combo finishers",
            "category": "Combat",
            "tier": 1,
            "requirement": {"combo_finishers": 10},
            "reward": {"exp": 300, "stat_bonus": {"speed": 2}},
            "icon": "🔄"
        },
        {
            "id": "combo_artist",
            "name": "Combo Artist",
            "description": "Perform 50 combo finishers",
            "category": "Combat",
            "tier": 2,
            "requirement": {"combo_finishers": 50},
            "reward": {"exp": 1000, "stat_bonus": {"speed": 5, "attack": 3}},
            "icon": "⚡"
        },
        {
            "id": "combo_master",
            "name": "Combo Master",
            "description": "Perform 150 combo finishers",
            "category": "Combat",
            "tier": 3,
            "requirement": {"combo_finishers": 150},
            "reward": {"exp": 3000, "stat_bonus": {"speed": 10, "attack": 7}, "item": "Combo Master's Gloves"},
            "icon": "🌪️"
        },

        # Critical Hit Achievements
        {
            "id": "critical_striker",
            "name": "Critical Striker",
            "description": "Land 25 critical hits",
            "category": "Combat",
            "tier": 1,
            "requirement": {"critical_hits": 25},
            "reward": {"exp": 200, "stat_bonus": {"critical_chance": 0.02}},
            "icon": "❗"
        },
        {
            "id": "critical_expert",
            "name": "Critical Expert",
            "description": "Land 100 critical hits",
            "category": "Combat",
            "tier": 2,
            "requirement": {"critical_hits": 100},
            "reward": {"exp": 800, "stat_bonus": {"critical_chance": 0.05}},
            "icon": "💢"
        },
        {
            "id": "critical_master",
            "name": "Critical Master",
            "description": "Land 250 critical hits",
            "category": "Combat",
            "tier": 3,
            "requirement": {"critical_hits": 250},
            "reward": {"exp": 2000, "stat_bonus": {"critical_chance": 0.1}, "item": "Precision Scope"},
            "icon": "💥"
        },

        # Wealth Achievements
        {
            "id": "gold_collector",
            "name": "Gold Collector",
            "description": "Earn 1,000 gold",
            "category": "Wealth",
            "tier": 1,
            "requirement": {"total_gold_earned": 1000},
            "reward": {"exp": 200, "stat_bonus": {"charisma": 2}},
            "icon": "💰"
        },
        {
            "id": "wealthy",
            "name": "Wealthy",
            "description": "Earn 10,000 gold",
            "category": "Wealth",
            "tier": 2,
            "requirement": {"total_gold_earned": 10000},
            "reward": {"exp": 1000, "stat_bonus": {"charisma": 5}},
            "icon": "💎"
        },
        {
            "id": "rich",
            "name": "Rich",
            "description": "Earn 50,000 gold",
            "category": "Wealth",
            "tier": 3,
            "requirement": {"total_gold_earned": 50000},
            "reward": {"exp": 3000, "stat_bonus": {"charisma": 10}, "item": "Golden Monocle"},
            "icon": "👑"
        },
        {
            "id": "millionaire",
            "name": "Millionaire",
            "description": "Earn 100,000 gold",
            "category": "Wealth",
            "tier": 4,
            "requirement": {"total_gold_earned": 100000},
            "reward": {"exp": 10000, "stat_bonus": {"charisma": 20}, "item": "Midas Touch Gloves"},
            "icon": "🏛️"
        },

        # Experience Achievements
        {
            "id": "level_up",
            "name": "Level Up",
            "description": "Reach level 5",
            "category": "Experience",
            "tier": 1,
            "requirement": lambda: user_data["level"] >= 5,
            "reward": {"gold": 100, "stat_bonus": {"health": 10}},
            "icon": "📈"
        },
        {
            "id": "adventurer",
            "name": "Adventurer",
            "description": "Reach level 10",
            "category": "Experience",
            "tier": 2,
            "requirement": lambda: user_data["level"] >= 10,
            "reward": {"gold": 500, "stat_bonus": {"health": 20, "attack": 2, "defense": 2}},
            "icon": "🌄"
        },
        {
            "id": "hero",
            "name": "Hero",
            "description": "Reach level 25",
            "category": "Experience",
            "tier": 3,
            "requirement": lambda: user_data["level"] >= 25,
            "reward": {"gold": 2000, "stat_bonus": {"health": 50, "attack": 5, "defense": 5}},
            "icon": "🦸"
        },
        {
            "id": "legend",
            "name": "Legend",
            "description": "Reach level 50",
            "category": "Experience",
            "tier": 4,
            "requirement": lambda: user_data["level"] >= 50,
            "reward": {"gold": 5000, "stat_bonus": {"health": 100, "attack": 10, "defense": 10}, "item": "Legendary Cape"},
            "icon": "🌟"
        },

        # Exploration Achievements
        {
            "id": "explorer_novice",
            "name": "Explorer Novice",
            "description": "Visit 3 different locations",
            "category": "Exploration",
            "tier": 1,
            "requirement": lambda: len(user_data.get("visited_locations", [])) >= 3,
            "reward": {"exp": 200, "stat_bonus": {"speed": 1}},
            "icon": "🧭"
        },
        {
            "id": "traveler",
            "name": "Traveler",
            "description": "Visit 7 different locations",
            "category": "Exploration",
            "tier": 2,
            "requirement": lambda: len(user_data.get("visited_locations", [])) >= 7,
            "reward": {"exp": 500, "gold": 300, "stat_bonus": {"speed": 3}},
            "icon": "🗺️"
        },
        {
            "id": "explorer",
            "name": "Explorer",
            "description": "Visit 12 different locations",
            "category": "Exploration",
            "tier": 3,
            "requirement": lambda: len(user_data.get("visited_locations", [])) >= 12,
            "reward": {"exp": 1500, "gold": 800, "stat_bonus": {"speed": 6}, "item": "Explorer's Boots"},
            "icon": "🌍"
        },
        {
            "id": "world_traveler",
            "name": "World Traveler",
            "description": "Visit all locations in the world",
            "category": "Exploration",
            "tier": 4,
            "requirement": lambda: len(user_data.get("visited_locations", [])) >= 20,  # Assuming 20 total locations
            "reward": {"exp": 3000, "gold": 2000, "stat_bonus": {"speed": 10, "charisma": 5}, "item": "World Map"},
            "icon": "🌐"
        },

        # Collection Achievements
        {
            "id": "collector",
            "name": "Item Collector",
            "description": "Collect 25 different items",
            "category": "Collection",
            "tier": 1,
            "requirement": lambda: len(set(user_data.get("all_collected_items", []))) >= 25,
            "reward": {"gold": 200, "exp": 300},
            "icon": "🧰"
        },
        {
            "id": "treasure_hunter",
            "name": "Treasure Hunter",
            "description": "Open 10 treasure chests",
            "category": "Collection",
            "tier": 2,
            "requirement": {"treasure_chests_opened": 10},
            "reward": {"gold": 500, "exp": 700},
            "icon": "🗝️"
        },
        {
            "id": "hoarder",
            "name": "Hoarder",
            "description": "Collect 100 different items",
            "category": "Collection",
            "tier": 3,
            "requirement": lambda: len(set(user_data.get("all_collected_items", []))) >= 100,
            "reward": {"gold": 1500, "exp": 2000, "item": "Collector's Bag"},
            "icon": "🎒"
        },

        # Crafting Achievements
        {
            "id": "apprentice_crafter",
            "name": "Apprentice Crafter",
            "description": "Craft 10 items",
            "category": "Crafting",
            "tier": 1,
            "requirement": {"items_crafted": 10},
            "reward": {"exp": 200, "stat_bonus": {"crafting": 2}},
            "icon": "🔨"
        },
        {
            "id": "skilled_artisan",
            "name": "Skilled Artisan",
            "description": "Craft 25 items",
            "category": "Crafting",
            "tier": 2,
            "requirement": {"items_crafted": 25},
            "reward": {"exp": 500, "stat_bonus": {"crafting": 5}},
            "icon": "⚒️"
        },
        {
            "id": "master_crafter",
            "name": "Master Crafter",
            "description": "Craft 50 items",
            "category": "Crafting",
            "tier": 3,
            "requirement": {"items_crafted": 50},
            "reward": {"exp": 1500, "stat_bonus": {"crafting": 10}, "item": "Artisan's Tools"},
            "icon": "🛠️"
        },

        # Quest Achievements
        {
            "id": "quest_beginner",
            "name": "Quest Beginner",
            "description": "Complete 3 quests",
            "category": "Quests",
            "tier": 1,
            "requirement": {"quests_completed": 3},
            "reward": {"exp": 300},
            "icon": "📜"
        },
        {
            "id": "quest_taker",
            "name": "Quest Taker",
            "description": "Complete 10 quests",
            "category": "Quests",
            "tier": 2,
            "requirement": {"quests_completed": 10},
            "reward": {"exp": 800, "gold": 500},
            "icon": "📝"
        },
        {
            "id": "quest_master",
            "name": "Quest Master",
            "description": "Complete 25 quests",
            "category": "Quests",
            "tier": 3,
            "requirement": {"quests_completed": 25},
            "reward": {"exp": 2000, "gold": 1500, "item": "Quest Master's Journal"},
            "icon": "📚"
        },

        # Dungeon Achievements
        {
            "id": "dungeon_novice",
            "name": "Dungeon Novice",
            "description": "Complete your first dungeon",
            "category": "Dungeons",
            "tier": 1,
            "requirement": {"dungeons_completed": 1},
            "reward": {"exp": 300, "gold": 200},
            "icon": "🏰"
        },
        {
            "id": "dungeon_explorer",
            "name": "Dungeon Explorer",
            "description": "Complete 5 different dungeons",
            "category": "Dungeons",
            "tier": 2,
            "requirement": {"dungeons_completed": 5},
            "reward": {"exp": 1000, "gold": 800, "stat_bonus": {"defense": 3}},
            "icon": "🔍"
        },
        {
            "id": "dungeon_master",
            "name": "Dungeon Master",
            "description": "Complete 15 different dungeons",
            "category": "Dungeons",
            "tier": 3,
            "requirement": {"dungeons_completed": 15},
            "reward": {"exp": 3000, "gold": 2000, "stat_bonus": {"defense": 8}, "item": "Dungeon Key"},
            "icon": "🔑"
        },

        # Survival Achievements
        {
            "id": "survivor",
            "name": "Survivor",
            "description": "Survive 10 near-death experiences (below 10% health)",
            "category": "Survival",
            "tier": 2,
            "requirement": lambda: user_data.get("near_death_escapes", 0) >= 10,
            "reward": {"exp": 1000, "stat_bonus": {"health": 10, "defense": 3}},
            "icon": "❤️‍🩹"
        },
        {
            "id": "potion_master",
            "name": "Potion Master",
            "description": "Use 50 potions",
            "category": "Survival",
            "tier": 2,
            "requirement": {"potions_used": 50},
            "reward": {"exp": 500, "stat_bonus": {"health": 5}},
            "icon": "🧪"
        },
        {
            "id": "dodge_expert",
            "name": "Dodge Expert",
            "description": "Dodge 100 enemy attacks",
            "category": "Survival",
            "tier": 3,
            "requirement": {"enemies_dodged": 100},
            "reward": {"exp": 2000, "stat_bonus": {"speed": 8}, "item": "Shadow Step Boots"},
            "icon": "💨"
        }
    ]

    # Check each achievement
    newly_unlocked = []

    for achievement in ACHIEVEMENTS:
        achievement_id = achievement["id"]

        # Skip if already unlocked
        if achievement_id in user_data["achievements"]["unlocked"]:
            continue

        # Check if achievement is unlocked based on requirement
        requirement_met = False

        # Handle lambda requirements (custom conditions)
        if callable(achievement.get("requirement")):
            requirement_met = achievement["requirement"]()
        # Handle dict requirements (stat-based conditions)
        elif isinstance(achievement.get("requirement"), dict):
            requirement_met = True
            for stat, required_value in achievement["requirement"].items():
                # Handle set-type stats (like areas_visited)
                if stat == "areas_visited" and isinstance(user_data["achievements"]["progress"].get(stat), set):
                    if len(user_data["achievements"]["progress"].get(stat, set())) < required_value:
                        requirement_met = False
                        break
                # Handle regular numeric stats
                elif user_data["achievements"]["progress"].get(stat, 0) < required_value:
                    requirement_met = False
                    break

        # If requirement is met, unlock achievement
        if requirement_met:
            # Unlock the achievement
            user_data["achievements"]["unlocked"].append(achievement_id)
            newly_unlocked.append(achievement)

            # Apply rewards
            grant_achievement_rewards(achievement)

    # Display newly unlocked achievements with fancy UI
    if newly_unlocked:
        print_animated(f"\n{BG_YELLOW}{BLACK} ACHIEVEMENTS UNLOCKED! {ENDC}", delay=0.05)
        for achievement in newly_unlocked:
            icon = achievement.get("icon", "🏆")
            tier = achievement.get("tier", 1)
            tier_color = [WHITE, LIGHTGREEN, LIGHTBLUE, LIGHTMAGENTA, LIGHTYELLOW][min(tier, 4)]

            print_animated(f"{tier_color}{icon} {achievement['name']}{ENDC} - {achievement['description']}", delay=0.03)

            # Show rewards
            if "reward" in achievement:
                reward_str = "Rewards: "
                reward = achievement["reward"]
                if "gold" in reward:
                    reward_str += f"{LIGHTYELLOW}{reward['gold']} Gold{ENDC}, "
                if "exp" in reward:
                    reward_str += f"{LIGHTGREEN}{reward['exp']} XP{ENDC}, "
                if "item" in reward:
                    reward_str += f"{LIGHTMAGENTA}{reward['item']}{ENDC}, "
                if "stat_bonus" in reward:
                    for stat, value in reward["stat_bonus"].items():
                        reward_str += f"{LIGHTCYAN}+{value} {stat.capitalize()}{ENDC}, "
                # Remove trailing comma and space
                reward_str = reward_str[:-2]
                print_animated(f"  {reward_str}", delay=0.02)

def update_achievement_progress() -> None:
    """Update and track progress towards achievements"""

    # Check literature-related achievements
    if "literature" in user_data:
        lit_data = user_data["literature"]

        # Count read literature
        read_items = len(lit_data.get("read", []))
        if read_items > 0:
            unlock_achievement("Novice Reader", "Read your first book or scroll.", "Read 1 book")
        if read_items >= 10:
            unlock_achievement("Bookworm", "Read 10 different books and scrolls.", "Read 10 texts")
        if read_items >= 25:
            unlock_achievement("Scholar", "Read 25 different books and scrolls.", "Read 25 texts")

        # Count owned literature
        owned_items = len(lit_data.get("owned", []))
        if owned_items >= 15:
            unlock_achievement("Collector of Knowledge", "Own 15 different books and scrolls in your collection.", "Collect 15 texts")

        # Check for diverse reading
        if read_items > 0:
            read_categories = set()
            for item_id in lit_data.get("read", []):
                try:
                    item_type, category, _ = item_id.split(":", 2)
                    read_categories.add(f"{item_type}:{category}")
                except ValueError:
                    continue

            # If player has read from at least 5 different categories
            if len(read_categories) >= 5:
                unlock_achievement("Master of Lore", "Read at least one book from every category.", "Read diverse texts")

    # Check archaeology-related achievements
    if "archaeology" in user_data:
        arch_data = user_data["archaeology"]

        # Count discovered sites
        discovered_sites = len(arch_data.get("discovered_sites", []))
        if discovered_sites > 0:
            unlock_achievement("Novice Archaeologist", "Discover your first archaeological site.", "Discover 1 site")
        if discovered_sites >= 3:
            unlock_achievement("Amateur Archaeologist", "Discover 3 archaeological sites.", "Discover 3 sites")
        if discovered_sites >= len(ARCHAEOLOGICAL_SITES):
            unlock_achievement("Professional Archaeologist", "Discover all archaeological sites.", "Discover all sites")

        # Count completed artifact sets
        completed_sets = len(arch_data.get("completed_sets", []))
        if completed_sets >= 1:
            unlock_achievement("Artifact Collector", "Complete your first artifact set.", "Complete 1 artifact set")
        if completed_sets >= 3:
            unlock_achievement("Master Collector", "Complete 3 artifact sets.", "Complete 3 artifact sets")

        # Count acquired knowledge
        knowledge_count = len(arch_data.get("knowledge", []))
        if knowledge_count >= 1:
            unlock_achievement("Knowledge Seeker", "Acquire your first piece of ancient knowledge.", "Acquire 1 ancient knowledge")
        if knowledge_count >= len(ANCIENT_KNOWLEDGE):
            unlock_achievement("Ancient Scholar", "Acquire all pieces of ancient knowledge.", "Acquire all ancient knowledge")

        # Count museum exhibits
        museum_exhibits = len(arch_data.get("museum_exhibits", []))
        if museum_exhibits >= 5:
            unlock_achievement("Museum Curator", "Display 5 artifacts in your museum.", "Display 5 artifacts")
        if museum_exhibits >= 10:
            unlock_achievement("Master Curator", "Display 10 artifacts in your museum.", "Display 10 artifacts")
    # Update achievement stats based on user_data
    user_stats = user_data["achievements"]["progress"]

    # Combat stats
    user_stats["monsters_killed"] = user_data.get("monsters_killed", 0)
    user_stats["bosses_defeated"] = user_data.get("bosses_defeated", 0)
    user_stats["critical_hits"] = user_data.get("critical_hits", 0)
    user_stats["combo_finishers"] = user_data.get("combo_finishers", 0)
    user_stats["skills_used"] = user_data.get("skills_used", 0)

    # Wealth stats
    user_stats["total_gold_earned"] = user_data.get("total_gold_earned", user_data.get("gold", 0))
    user_stats["gold_spent"] = user_data.get("gold_spent", 0)

    # Experience stats (level is directly accessed)

    # Exploration stats
    if "visited_locations" not in user_stats:
        user_stats["visited_locations"] = set()
    if "current_area" in user_data:
        user_stats["visited_locations"].add(user_data["current_area"])
    user_stats["distance_traveled"] = user_data.get("distance_traveled", 0)

    # Collection stats
    user_stats["items_collected"] = len(user_data.get("inventory", []))
    user_stats["treasure_chests_opened"] = user_data.get("treasure_chests_opened", 0)

    # Crafting stats
    user_stats["items_crafted"] = user_data.get("items_crafted", 0)

    # Quest stats
    user_stats["quests_completed"] = len(user_data.get("completed_quests", []))

    # Dungeon stats
    user_stats["dungeons_completed"] = len(user_data.get("completed_dungeons", []))

    # Other stats
    user_stats["potions_used"] = user_data.get("potions_used", 0)
    user_stats["deaths"] = user_data.get("deaths", 0)
    user_stats["enemies_dodged"] = user_data.get("enemies_dodged", 0)

    # Ensure all_collected_items exists for tracking unique items
    if "all_collected_items" not in user_data:
        user_data["all_collected_items"] = []
        # Initialize with current inventory
        user_data["all_collected_items"].extend(user_data.get("inventory", []))

def grant_achievement_rewards(achievement: Dict[str, Any]) -> None:
    """Apply rewards from unlocking an achievement"""
    global user_data

    if "reward" not in achievement:
        return

    reward = achievement["reward"]

    # Apply gold reward
    if "gold" in reward:
        user_data["gold"] += reward["gold"]
        print_animated(f"  {LIGHTYELLOW}+{reward['gold']} Gold{ENDC}", delay=0.02)

    # Apply experience reward
    if "exp" in reward:
        old_level = user_data["level"]
        user_data["exp"] += reward["exp"]
        print_animated(f"  {LIGHTGREEN}+{reward['exp']} XP{ENDC}", delay=0.02)
        # Check for level up
        check_level_up()
        # Note if level up occurred
        if user_data["level"] > old_level:
            print_animated(f"  {BG_GREEN}{BLACK} LEVEL UP! {ENDC} You are now level {user_data['level']}!", delay=0.03)

    # Add item reward
    if "item" in reward:
        item_name = reward["item"]
        user_data["inventory"].append(item_name)
        print_animated(f"  {LIGHTMAGENTA}Received {item_name}{ENDC}", delay=0.02)

        # Track item collection for achievement tracking
        if "all_collected_items" not in user_data:
            user_data["all_collected_items"] = []
        user_data["all_collected_items"].append(item_name)

    # Apply stat bonuses
    if "stat_bonus" in reward:
        for stat, value in reward["stat_bonus"].items():
            if stat == "critical_chance":
                # Special handling for percentage-based stats
                if "critical_chance_bonus" not in user_data:
                    user_data["critical_chance_bonus"] = 0
                user_data["critical_chance_bonus"] += value
                print_animated(f"  {LIGHTCYAN}+{value*100}% Critical Chance{ENDC}", delay=0.02)
            elif stat == "health":
                # Increase both current and max health
                user_data["max_health"] += value
                user_data["health"] += value
                print_animated(f"  {LIGHTGREEN}+{value} Max Health{ENDC}", delay=0.02)
            else:
                # Standard stat increase
                if stat not in user_data:
                    user_data[stat] = 0
                user_data[stat] += value
                print_animated(f"  {LIGHTCYAN}+{value} {stat.capitalize()}{ENDC}", delay=0.02)

def show_achievements() -> None:
    """Display achievements screen with progress tracking"""
    if "achievements" not in user_data:
        user_data["achievements"] = {
            "unlocked": [],
            "progress": {}
        }

    # Update achievement progress before showing
    update_achievement_progress()

    # Get all achievements organized by category
    all_achievements = {
        "Combat": [],
        "Wealth": [],
        "Experience": [],
        "Exploration": [],
        "Collection": [],
        "Crafting": [],
        "Quests": [],
        "Dungeons": [],
        "Survival": []
    }

    # Dynamically generate the achievements list based on the ACHIEVEMENTS constant
    for achievement in ACHIEVEMENTS:
        # Ensure we have proper dictionary objects for achievements
        if not isinstance(achievement, dict):
            # Skip non-dictionary achievements to prevent typing errors
            continue

        # Explicitly cast to proper types to avoid LSP errors
        achievement_dict = achievement  # Type hint now recognizes this as a dictionary

        # Get category with a safer approach using get()
        category = achievement_dict.get("category", "Other")

        if category in all_achievements:
            all_achievements[category].append(achievement_dict)

    # Count total and unlocked achievements
    total_achievements = len(ACHIEVEMENTS)
    unlocked_count = len(user_data["achievements"]["unlocked"])
    completion_pct = unlocked_count / total_achievements * 100 if total_achievements > 0 else 0

    # Display achievements screen
    print_header("Achievements")

    # Show completion summary
    print(f"{BOLD}Achievements Unlocked:{ENDC} {LIGHTCYAN}{unlocked_count}/{total_achievements}{ENDC} ({completion_pct:.1f}%)")

    # Show achievement progress bar
    progress_bar = create_progress_bar(completion_pct/100, 40)
    print(f"{progress_bar}\n")

    # Show achievement categories
    categories = list(all_achievements.keys())

    # Ask which category to display
    print(f"{BOLD}Categories:{ENDC}")
    for i, category in enumerate(categories, 1):
        cat_achievements = all_achievements[category]
        if not cat_achievements:
            continue

        cat_unlocked = len([a for a in cat_achievements if a["id"] in user_data["achievements"]["unlocked"]])
        cat_total = len(cat_achievements)
        cat_pct = cat_unlocked / cat_total * 100 if cat_total > 0 else 0
        cat_color = get_completion_color(cat_pct)

        print(f"{i}. {cat_color}{category}{ENDC} - {cat_unlocked}/{cat_total} ({cat_pct:.1f}%)")

    # Add option to show all
    all_option = len(categories) + 1
    print(f"{all_option}. {CYAN}Show All{ENDC}")
    print(f"{all_option + 1}. {YELLOW}Back{ENDC}")

    # Get user choice
    try:
        choice = input(f"\n{YELLOW}Choose category (1-{all_option + 1}): {ENDC}")
        choice = int(choice)

        if choice == all_option + 1:  # Back
            return
        elif choice == all_option:  # Show all
            show_all_achievements(all_achievements)
        elif 1 <= choice <= len(categories):
            category = categories[choice - 1]
            show_category_achievements(category, all_achievements[category])
        else:
            print(f"{RED}Invalid choice.{ENDC}")
    except ValueError:
        print(f"{RED}Invalid input. Please enter a number.{ENDC}")

def show_category_achievements(category: str, achievements: List[Dict[str, Any]]) -> None:
    """Show achievements for a specific category"""
    print_header(f"{category} Achievements")

    # Group by tier
    by_tier = {}
    for achievement in achievements:
        tier = achievement.get("tier", 1)
        if tier not in by_tier:
            by_tier[tier] = []
        by_tier[tier].append(achievement)

    # Display by tier (ascending)
    for tier in sorted(by_tier.keys()):
        tier_name = ["Beginner", "Intermediate", "Advanced", "Expert", "Master"][min(tier - 1, 4)]
        tier_color = [GREEN, CYAN, BLUE, MAGENTA, YELLOW][min(tier - 1, 4)]

        print(f"\n{tier_color}{BOLD}Tier {tier}: {tier_name}{ENDC}")

        for achievement in by_tier[tier]:
            display_achievement(achievement)

    input(f"\n{YELLOW}Press Enter to continue...{ENDC}")

def show_all_achievements(all_achievements: Dict[str, List[Dict[str, Any]]]) -> None:
    """Show all achievements grouped by category"""
    print_header("All Achievements")

    for category, achievements in all_achievements.items():
        if not achievements:
            continue

        cat_unlocked = len([a for a in achievements if a["id"] in user_data["achievements"]["unlocked"]])
        cat_total = len(achievements)

        print(f"\n{BOLD}{CYAN}{category}{ENDC} ({cat_unlocked}/{cat_total})")
        print(f"{CYAN}{'-' * (len(category) + 2)}{ENDC}")

        for achievement in achievements:
            display_achievement(achievement, short=True)

    input(f"\n{YELLOW}Press Enter to continue...{ENDC}")

def display_achievement(achievement: Dict[str, Any], short: bool = False) -> None:
    """Display a single achievement with its status and progress"""
    achievement_id = achievement["id"]
    is_unlocked = achievement_id in user_data["achievements"]["unlocked"]

    # Get achievement details
    name = achievement["name"]
    description = achievement["description"]
    icon = achievement.get("icon", "🏆")
    tier = achievement.get("tier", 1)

    # Determine colors based on tier and unlock status
    if is_unlocked:
        tier_color = [LIGHTGREEN, LIGHTCYAN, LIGHTBLUE, LIGHTMAGENTA, LIGHTYELLOW][min(tier - 1, 4)]
        status_icon = "✓"
    else:
        tier_color = GREY
        status_icon = "☐"

    # Display basic info
    if short:
        print(f"{tier_color}{status_icon} {icon} {name}{ENDC}")
    else:
        print(f"{tier_color}{status_icon} {icon} {name}{ENDC} - {description}")

    # If not unlocked, show progress (if progress tracking is available)
    if not is_unlocked and not short and isinstance(achievement.get("requirement"), dict):
        for stat, required_value in achievement["requirement"].items():
            current_value = 0

            # Handle set-type stats (like areas_visited)
            if stat == "areas_visited" and isinstance(user_data["achievements"]["progress"].get(stat), set):
                current_value = len(user_data["achievements"]["progress"].get(stat, set()))
            else:
                current_value = user_data["achievements"]["progress"].get(stat, 0)

            progress_pct = min(1.0, current_value / required_value)
            progress_bar = create_progress_bar(progress_pct, 20)
            print(f"  Progress: {current_value}/{required_value} {progress_bar}")

    # Show rewards if not short view
    if not short and "reward" in achievement:
        reward = achievement["reward"]
        reward_parts = []

        if "gold" in reward:
            reward_parts.append(f"{LIGHTYELLOW}{reward['gold']} Gold{ENDC}")
        if "exp" in reward:
            reward_parts.append(f"{LIGHTGREEN}{reward['exp']} XP{ENDC}")
        if "item" in reward:
            reward_parts.append(f"{LIGHTMAGENTA}{reward['item']}{ENDC}")
        if "stat_bonus" in reward:
            for stat, value in reward["stat_bonus"].items():
                stat_name = stat.capitalize()
                if stat == "critical_chance":
                    reward_parts.append(f"{LIGHTCYAN}+{value*100}% Crit Chance{ENDC}")
                else:
                    reward_parts.append(f"{LIGHTCYAN}+{value} {stat_name}{ENDC}")

        if reward_parts:
            print(f"  Rewards: {', '.join(reward_parts)}")

def create_progress_bar(percentage: float, length: int = 20) -> str:
    """Create a visual progress bar with gradients"""
    filled_length = int(length * percentage)
    empty_length = length - filled_length

    if percentage < 0.3:
        color = RED
    elif percentage < 0.7:
        color = YELLOW
    else:
        color = GREEN

    bar = f"{color}{'█' * filled_length}{LIGHTGRAY}{'▒' * empty_length}{ENDC}"
    return bar

def get_completion_color(percentage: float) -> str:
    """Return a color based on completion percentage"""
    if percentage < 25:
        return RED
    elif percentage < 50:
        return YELLOW
    elif percentage < 75:
        return CYAN
    else:
        return GREEN

# First calculate_elemental_damage function removed (duplicate)
# Using the more complete version at line ~3038

# Character and Element Synergy System
def apply_character_element_synergy() -> Dict:
    """
    Calculate and apply elemental synergy effects from active character party

    Returns:
        Dictionary of active synergy effects
    """
    # Initialize synergy effects
    synergy_effects = {
        "elemental_damage_bonus": 0,  # % damage bonus for matching elements
        "elemental_resistance_bonus": 0,  # % resistance bonus for matching elements
        "passive_effects": [],  # List of passive effects
        "status_resistance": [],  # List of status effects with increased resistance
    }

    # Check if gacha system is active
    if "gacha" not in user_data:
        return synergy_effects

    current_party = user_data["gacha"]["characters"]
    if not current_party:
        return synergy_effects

    # Count elements in party for resonance effects
    element_count = {}
    character_levels = {}

    for char_name in current_party:
        char_data = GACHA_CHARACTERS.get(char_name, {})
        element = char_data.get("element", "None")
        memory_level = user_data["gacha"]["memory_shards"].get(char_name, 0)

        # Count elements for resonance
        if element not in element_count:
            element_count[element] = 0
        element_count[element] += 1

        # Store character memory levels
        character_levels[char_name] = memory_level

        # Apply individual character Sea of Memory effects based on level
        if memory_level > 0:
            memories = char_data.get("sea_of_memories", [])
            for i in range(min(memory_level, len(memories))):
                memory = memories[i]
                if "damage" in memory.lower() and "increase" in memory.lower():
                    # Parse damage bonus from memory description
                    match = re.search(r"(\d+)%", memory)
                    if match:
                        bonus = int(match.group(1))
                        synergy_effects["elemental_damage_bonus"] += bonus / 100

                if any(status in memory.lower() for status in ["poison", "burn", "freeze", "shock"]):
                    for status in ["poison", "burn", "freeze", "shock"]:
                        if status in memory.lower() and status not in synergy_effects["status_resistance"]:
                            synergy_effects["status_resistance"].append(status)

                # Add passive effect description
                effect_desc = f"{char_name}'s {memory.split(':')[1].strip()}"
                synergy_effects["passive_effects"].append(effect_desc)

    # Apply elemental resonance effects (2+ of same element)
    for element, count in element_count.items():
        if count >= 2:
            # Different resonance effects based on element
            if element == "Fire":
                synergy_effects["elemental_damage_bonus"] += 0.15  # +15% fire damage
                effect_desc = "Fire Resonance: +15% Fire damage"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Water":
                synergy_effects["elemental_resistance_bonus"] += 0.15  # +15% water resistance
                effect_desc = "Water Resonance: +15% Water resistance and healing"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Earth":
                effect_desc = "Earth Resonance: +20% physical defense"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Air":
                effect_desc = "Air Resonance: +10% movement speed and evasion"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Lightning":
                effect_desc = "Lightning Resonance: +10% critical hit chance"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Ice":
                effect_desc = "Ice Resonance: +15% chance to freeze enemies"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Light":
                effect_desc = "Light Resonance: +15% healing effectiveness"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Dark":
                effect_desc = "Dark Resonance: +15% damage against elite enemies"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Nature":
                effect_desc = "Nature Resonance: Regenerate 2% health per minute"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

            elif element == "Arcane":
                effect_desc = "Arcane Resonance: +15% to all elemental damage"
                if effect_desc not in synergy_effects["passive_effects"]:
                    synergy_effects["passive_effects"].append(effect_desc)

    return synergy_effects

# First apply_elemental_effects function removed (duplicate)
# Using the more complete version at line ~3090

# First update_status_effects function removed (duplicate)
# Using the more complete version below

# First get_player_element function removed (duplicate)
# Using the more complete version below with type annotations

# Elemental Combat Functions
def calculate_elemental_damage(attacker_element: str, defender_element: str, base_damage: int, is_player: bool = True) -> Tuple[int, str, Dict]:
    """Calculate damage based on elemental interactions and return elemental reaction if applicable

    Args:
        attacker_element: The element of the attacker
        defender_element: The element of the defender
        base_damage: The base damage amount
        is_player: Whether the attacker is the player (for character synergy bonuses)

    Returns:
        Tuple of (final_damage, reaction_name, reaction_effect)
    """
    damage_multiplier = 1.0
    reaction_name = ""  # Empty string instead of None
    reaction_effect = {}

    # Get character party synergy effects if player is attacking
    synergy_effects = {}
    element_count = {}
    if is_player and "gacha" in user_data and user_data["gacha"].get("current_party"):
        # Get active synergy effects from character party
        synergy_effects = apply_character_element_synergy()

        # Count elements in party for resonance effects
        for char_name in user_data["gacha"]["current_party"]:
            char_data = GACHA_CHARACTERS.get(char_name, {})
            element = char_data.get("element", "None")
            if element not in element_count:
                element_count[element] = 0
            element_count[element] += 1

    # Map simplified character elements to game elements
    element_mapping = {
        "Fire": "Ignis",
        "Water": "Aqua", 
        "Earth": "Gē",
        "Air": "Aer",
        "Lightning": "Fulmen",
        "Ice": "Glacies",
        "Light": "Lux",
        "Dark": "Tenebrae",
        "Nature": "Viridia",
        "Arcane": "Pneuma"
    }

    # Convert character elements to game elements if needed
    game_attacker_element = element_mapping.get(attacker_element, attacker_element)
    game_defender_element = element_mapping.get(defender_element, defender_element)

    # Check for immunity (monster immune to their own element)
    if game_attacker_element == game_defender_element and game_defender_element != "Nullum":
        # Check if character party provides immunity bypass
        immunity_bypass = False
        if is_player and synergy_effects.get("passive_effects"):
            for effect in synergy_effects["passive_effects"]:
                if ("immunity" in effect.lower() and "bypass" in effect.lower()) or "transform" in effect.lower():
                    immunity_bypass = True
                    print_colored("Character ability bypasses elemental immunity!", MAGENTA)
                    break

        if not immunity_bypass:
            print_colored(f"The {defender_element} creature is immune to {attacker_element} damage!", WARNING)
            return 0, "", {}  # Empty string instead of None
        else:
            # Reduced damage but not immune when bypassed
            damage_multiplier *= 0.3
            print_colored("Your characters' abilities allow you to damage it at reduced effectiveness!", CYAN)

    # Apply elemental damage bonus from character synergy
    if is_player and synergy_effects.get("elemental_damage_bonus", 0) > 0:
        elem_bonus = synergy_effects["elemental_damage_bonus"]
        damage_multiplier += elem_bonus

        # Only show message if bonus is significant
        if elem_bonus >= 0.1:  # 10% or higher bonus
            print_colored(f"Party Synergy: +{int(elem_bonus*100)}% elemental damage!", CYAN)

    # Check elemental strengths and weaknesses
    if game_attacker_element in ELEMENTS and game_defender_element in ELEMENTS:
        # Defender is weak to attacker's element
        if game_defender_element in ELEMENTS[game_attacker_element].get("strength", []):
            weakness_multiplier = 1.5

            # Enhanced weakness damage from character party of same element
            if is_player and attacker_element in element_count and element_count[attacker_element] >= 2:
                # +10% per matching character after the first, up to +30%
                weakness_bonus = min(0.3, (element_count[attacker_element] - 1) * 0.1)
                weakness_multiplier += weakness_bonus

                if weakness_bonus > 0:
                    print_colored(f"{attacker_element} Party Resonance: +{int(weakness_bonus*100)}% weakness damage!", CYAN)

            damage_multiplier *= weakness_multiplier
            print_colored(f"{attacker_element} is strong against {defender_element}!", OKGREEN)

        # Attacker's element is weak against defender's element
        elif game_attacker_element in ELEMENTS[game_defender_element].get("strength", []):
            resistance_penalty = 0.5

            # Reduced resistance penalty from character effects
            if is_player and synergy_effects.get("passive_effects"):
                for effect in synergy_effects["passive_effects"]:
                    if "weakness" in effect.lower() and "reduce" in effect.lower():
                        resistance_penalty = 0.7  # Less penalty (0.7x instead of 0.5x)
                        print_colored("Character ability reduces your elemental weakness penalty!", CYAN)
                        break

            damage_multiplier *= resistance_penalty
            print_colored(f"{attacker_element} is weak against {defender_element}!", FAIL)

    # Check for potential elemental reaction
    reaction_key = f"{game_attacker_element}+{game_defender_element}"
    if reaction_key in ELEMENTAL_REACTIONS:
        reaction = ELEMENTAL_REACTIONS[reaction_key]
        reaction_name = reaction["name"]
        reaction_effect = reaction["effect"]
        reaction_multiplier = reaction["damage_multiplier"]

        # Apply elemental reaction multiplier
        damage_multiplier *= reaction_multiplier

        # Enhanced reaction damage from characters with matching elements
        if is_player:
            # Find matching character elements in reaction
            elem1 = game_attacker_element
            elem2 = game_defender_element

            elem1_char_count = element_count.get(element_mapping.get(elem1, elem1), 0)
            elem2_char_count = element_count.get(element_mapping.get(elem2, elem2), 0)

            if elem1_char_count > 0 and elem2_char_count > 0:
                # Both elements in party = +25% reaction damage
                reaction_bonus = 0.25
                damage_multiplier += reaction_bonus
                print_colored(f"Dual Element Resonance: +{int(reaction_bonus*100)}% reaction damage!", MAGENTA)

        print_colored(f"Elemental Reaction: {reaction_name}!", MAGENTA)
        print_colored(f"{reaction['description']}", CYAN)

    # Calculate final damage with appropriate rounding
    final_damage = int(base_damage * damage_multiplier)

    # Check for critical hit enhancements from characters with same element
    if is_player and attacker_element in element_count and element_count[attacker_element] >= 1:
        crit_chance = 0.05  # Base 5% critical chance
        matching_element_bonus = 0.03 * element_count[attacker_element]  # +3% per matching character

        # Calculate final crit chance
        final_crit_chance = min(0.5, crit_chance + matching_element_bonus)  # Cap at 50%

        # Check for critical hit
        if random.random() < final_crit_chance:
            # Critical hit does 2x damage
            final_damage *= 2
            print_colored("CRITICAL HIT!", LIGHTMAGENTA)

    return final_damage, reaction_name, reaction_effect


def apply_elemental_effects(entity_data: Dict, reaction_effect: Dict, is_player: bool = False) -> None:
    """Apply elemental reaction effects to an entity

    Args:
        entity_data: The entity to apply effects to (player or monster)
        reaction_effect: The reaction effect data
        is_player: Whether the entity is the player
    """
    if not reaction_effect:
        return

    # Initialize status effects if not present
    if "status_effects" not in entity_data:
        entity_data["status_effects"] = {}

    duration = reaction_effect.get("duration", 3)

    # Apply each effect
    for effect_type, effect_value in reaction_effect.items():
        if effect_type == "duration":  # Skip the duration itself
            continue

        # Apply damage over time effects
        if effect_type in ["burn", "poison", "shock", "dot"]:
            entity_data["status_effects"][effect_type] = {
                "value": effect_value,
                "duration": duration,
                "description": f"Taking {effect_value} damage per turn"
            }
            entity_type = "You are" if is_player else "Enemy is"
            print_colored(f"{entity_type} suffering from {effect_type} damage for {duration} turns!", WARNING)

        # Apply stat modifications
        elif effect_type in ["attack", "defense", "evasion", "vision", "dodge", "slow", "movement"]:
            entity_data["status_effects"][effect_type] = {
                "value": effect_value,
                "duration": duration,
                "description": f"{effect_type.capitalize()} {'increased' if effect_value > 0 else 'decreased'} by {abs(effect_value)}"
            }
            stat_change = "boosted" if effect_value > 0 else "reduced"
            entity_type = "Your" if is_player else "Enemy's"
            print_colored(f"{entity_type} {effect_type} is {stat_change} by {abs(effect_value)} for {duration} turns!", CYAN if effect_value > 0 else WARNING)

        # Apply healing effects
        elif effect_type == "heal" and effect_value > 0:
            if is_player:
                user_data["health"] = min(user_data["health"] + effect_value, user_data["max_health"])
                print_colored(f"You are healed for {effect_value} HP!", OKGREEN)
            else:
                entity_data["health"] = min(entity_data["health"] + effect_value, entity_data.get("max_health", entity_data["health"]))
                print_colored(f"Enemy is healed for {effect_value} HP!", FAIL)

        # Apply control effects
        elif effect_type in ["immobilize", "stun", "confusion", "entangle"]:
            entity_data["status_effects"][effect_type] = {
                "value": True,
                "duration": duration,
                "description": f"Cannot move due to {effect_type}"
            }
            entity_type = "You are" if is_player else "Enemy is"
            print_colored(f"{entity_type} {effect_type}d for {duration} turns!", WARNING if is_player else OKGREEN)


def update_status_effects(entity_data: Dict, is_player: bool = False) -> None:
    """Update and apply the effects of status conditions

    Args:
        entity_data: The entity to update effects for
        is_player: Whether the entity is the player
    """
    if "status_effects" not in entity_data:
        return

    effects_to_remove = []

    for effect_name, effect_data in entity_data["status_effects"].items():
        # Apply damage over time effects
        if effect_name in ["burn", "poison", "shock", "dot"]:
            damage = effect_data["value"]
            if is_player:
                user_data["health"] = max(0, user_data["health"] - damage)
                print_colored(f"You take {damage} damage from {effect_name}!", FAIL)
                if user_data["health"] <= 0:
                    print_colored("You were defeated by status effects!", FAIL)
            else:
                entity_data["health"] -= damage
                print_colored(f"Enemy takes {damage} damage from {effect_name}!", OKGREEN)

        # Decrement duration and remove expired effects
        effect_data["duration"] -= 1
        if effect_data["duration"] <= 0:
            effects_to_remove.append(effect_name)
            entity_type = "Your" if is_player else "Enemy's"
            print_colored(f"{entity_type} {effect_name} effect has worn off.", CYAN)

    # Clean up expired effects
    for effect_name in effects_to_remove:
        del entity_data["status_effects"][effect_name]


def get_player_element() -> str:
    """Get the player's current element based on equipped items"""
    # Default to physical damage
    element = "Nullum"

    # Check for elemental weapon
    if user_data.get("equipped", {}).get("weapon"):
        weapon_name = user_data["equipped"]["weapon"]["name"]

        # Search through shop items or any available item collections
        # Note: Just check the weapon name for now, assuming we'll add element attributes
        # to weapons in the future
        weapon_elements = {
            "Flame Sword": "Ignis",
            "Ice Sword": "Glacies",
            "Lightning Sword": "Fulmen",
            "Nature Sword": "Viridia",
            "Earth Sword": "Gē",
            "Wind Sword": "Aer",
            "Water Sword": "Aqua",
            "Light Sword": "Lux",
            "Shadow Blade": "Tenebrae",
            "Poison Dagger": "Venēnum",
            "Steel Sword": "Ferrum",
            "Spirit Blade": "Pneuma"
        }

        # Check if the weapon has an elemental type
        if weapon_name in weapon_elements:
            element = weapon_elements[weapon_name]

    return element

# Artifact categories 
ARTIFACT_SLOTS = ["Headset", "Necklace", "Clock", "Flower", "Feather", "Ring"]

# Dimension definitions - alternate realities and planes of existence
DIMENSIONS = {
    "Overworld": {
        "name": "Overworld",
        "description": "The main world where most of your adventure takes place.",
        "access_level": 1,
        "monsters": ["Wolf", "Goblin", "Bandit", "Spider", "Skeleton"],
        "resources": ["Wood", "Stone", "Iron Ore", "Herb", "Water"],
        "special_locations": ["Ancient Ruins", "Forgotten Temple", "Sacred Grove"]
    },
    "Shadowrealm": {
        "name": "Shadowrealm",
        "description": "A dark dimension where shadows come to life and darkness reigns.",
        "access_level": 15,
        "monsters": ["Shadow Wolf", "Void Walker", "Umbral Assassin", "Darkness Elemental"],
        "resources": ["Shadow Essence", "Void Crystal", "Dark Matter", "Umbral Stone", "Night Bloom"],
        "special_locations": ["Void Nexus", "Shadow Temple", "Dark Tower"],
        "unlock_item": "Shadow Key"
    },
    "Celestial Plane": {
        "name": "Celestial Plane",
        "description": "A dimension of light and divine energy, home to celestial beings.",
        "access_level": 25,
        "monsters": ["Light Guardian", "Celestial Protector", "Divine Servant", "Radiant Phoenix"],
        "resources": ["Divine Crystal", "Celestial Dust", "Light Essence", "Holy Water", "Heavenly Ore"],
        "special_locations": ["Ivory Citadel", "Celestial Forge", "Gardens of Eternity"],
        "unlock_item": "Divine Shard"
    },
    "Elemental Chaos": {
        "name": "Elemental Chaos",
        "description": "A chaotic dimension where the fundamental elements clash in perpetual conflict.",
        "access_level": 30,
        "monsters": ["Fire Elemental", "Water Sprite", "Earth Golem", "Air Wisp", "Lightning Fiend"],
        "resources": ["Pure Fire", "Elemental Water", "Living Stone", "Wind Essence", "Lightning Crystal"],
        "special_locations": ["Core of Creation", "Primal Vortex", "The Convergence"],
        "unlock_item": "Elemental Core"
    },
    "Timeless Void": {
        "name": "Timeless Void",
        "description": "A dimension outside of time where past, present, and future exist simultaneously.",
        "access_level": 40,
        "monsters": ["Chrono Wraith", "Temporal Guardian", "Memory Eater", "Future Seer", "Past Walker"],
        "resources": ["Frozen Time", "Future Fragment", "Memory Crystal", "Temporal Sand", "Eternity Shard"],
        "special_locations": ["Clock Tower Eternal", "Hall of Ages", "Paradox Nexus"],
        "unlock_item": "Chronos Crystal"
    }
}

# Home and Camp Structure definitions
HOME_STRUCTURES = {
    "Tent": {
        "name": "Basic Tent",
        "description": "A simple tent that provides basic shelter and rest.",
        "level": 1,
        "materials": {"Cloth": 5, "Wood": 3},
        "effects": {"rest_heal": 20, "storage": 10},
        "category": "shelter"
    },
    "Campfire": {
        "name": "Campfire",
        "description": "A small fire that provides warmth and a place to cook food.",
        "level": 1,
        "materials": {"Wood": 5, "Stone": 3},
        "effects": {"cook_food": True, "light": True},
        "category": "utility"
    },
    "Storage Chest": {
        "name": "Storage Chest",
        "description": "A wooden chest that provides additional storage space.",
        "level": 1,
        "materials": {"Wood": 10, "Iron Ore": 2},
        "effects": {"storage": 20},
        "category": "storage"
    },
    "Workbench": {
        "name": "Workbench",
        "description": "A simple workbench for crafting basic items.",
        "level": 1,
        "materials": {"Wood": 15, "Iron Ore": 5},
        "effects": {"crafting_bonus": 0.1},
        "category": "crafting"
    },
    "Herb Garden": {
        "name": "Herb Garden",
        "description": "A small garden to grow healing herbs.",
        "level": 1,
        "materials": {"Wood": 5, "Herb": 3, "Water": 2},
        "effects": {"herb_production": 1},
        "category": "production"
    },
    "Training Dummy": {
        "name": "Training Dummy",
        "description": "A wooden dummy for combat practice.",
        "level": 1,
        "materials": {"Wood": 10, "Cloth": 5},
        "effects": {"combat_exp_bonus": 0.05},
        "category": "training"
    },
    "Small Hut": {
        "name": "Small Hut",
        "description": "A small wooden hut that provides better shelter than a tent.",
        "level": 2,
        "materials": {"Wood": 20, "Stone": 10, "Cloth": 5},
        "effects": {"rest_heal": 40, "storage": 20},
        "category": "shelter",
        "upgrade_from": "Tent"
    },
    "Cooking Pot": {
        "name": "Cooking Pot",
        "description": "A pot for cooking more complex meals with better effects.",
        "level": 2,
        "materials": {"Iron Ore": 10, "Stone": 5},
        "effects": {"food_quality": 0.2},
        "category": "utility",
        "requires": "Campfire"
    },
    "Reinforced Chest": {
        "name": "Reinforced Chest",
        "description": "A stronger chest with more storage capacity.",
        "level": 2,
        "materials": {"Wood": 15, "Iron Ore": 10, "Stone": 5},
        "effects": {"storage": 40},
        "category": "storage",
        "upgrade_from": "Storage Chest"
    },
    "Alchemy Station": {
        "name": "Alchemy Station",
        "description": "A station for creating potions and elixirs.",
        "level": 2,
        "materials": {"Wood": 10, "Iron Ore": 5, "Herb": 10, "Glass": 5},
        "effects": {"alchemy_bonus": 0.15},
        "category": "crafting"
    },
    "Meditation Shrine": {
        "name": "Meditation Shrine",
        "description": "A quiet place for meditation and mana regeneration.",
        "level": 2,
        "materials": {"Stone": 15, "Divine Crystal": 1},
        "effects": {"mana_regen": 0.1, "meditation_bonus": 0.2},
        "category": "spiritual"
    },
    "Forge": {
        "name": "Forge",
        "description": "A furnace for smelting ores and forging metal items.",
        "level": 3,
        "materials": {"Stone": 30, "Iron Ore": 20, "Wood": 10},
        "effects": {"smithing_bonus": 0.2, "metal_quality": 0.15},
        "category": "crafting",
        "upgrade_from": "Workbench"
    },
    "Enchanting Table": {
        "name": "Enchanting Table",
        "description": "A magical table for enchanting weapons and armor.",
        "level": 3,
        "materials": {"Wood": 20, "Divine Crystal": 5, "Shadow Essence": 3},
        "effects": {"enchant_power": 0.2, "enchant_cost": -0.1},
        "category": "magic"
    },
    "Cabin": {
        "name": "Cabin",
        "description": "A solid wooden cabin with multiple rooms.",
        "level": 3,
        "materials": {"Wood": 50, "Stone": 30, "Iron Ore": 10},
        "effects": {"rest_heal": 60, "storage": 50, "comfort": 0.3},
        "category": "shelter",
        "upgrade_from": "Small Hut"
    },
    "Portal Frame": {
        "name": "Portal Frame",
        "description": "A frame for creating portals to other dimensions.",
        "level": 4,
        "materials": {"Divine Crystal": 5, "Shadow Essence": 5, "Pure Fire": 5, "Elemental Water": 5, "Living Stone": 5},
        "effects": {"dimension_travel": True},
        "category": "magic"
    }
}

# Function for enchanting items with special effects
def enchant_item() -> None:
    """Function to enchant weapons and armor with special effects"""
    print_header("Item Enchantment")

    # Get list of enchantable equipment
    enchantable_items = []
    if "equipment" in user_data:
        for item in user_data["equipment"]:
            # Skip already enchanted items unless they can be re-enchanted
            if item.get("enchantment") and not item.get("can_reenchant", False):
                continue

            # Only weapons, armor, and accessories can be enchanted
            if item.get("type") in ["weapon", "armor", "accessory"]:
                enchantable_items.append(item)

    if not enchantable_items:
        print_animated(f"{YELLOW}You don't have any items that can be enchanted.{ENDC}", delay=0.03)
        return

    # Display enchantable items
    print_animated(f"{CYAN}Select an item to enchant:{ENDC}", delay=0.03)
    for i, item in enumerate(enchantable_items, 1):
        rarity_color = get_rarity_color(item.get("rarity", "Common"))
        enchant_text = ""
        if item.get("enchantment"):
            enchant_text = f" (Currently: {LIGHTMAGENTA}{item['enchantment']['name']}{ENDC})"

        print(f"{i}. {rarity_color}{item['name']}{ENDC}{enchant_text}")

    print(f"{len(enchantable_items) + 1}. {YELLOW}Cancel{ENDC}")

    # Get user selection
    try:
        choice = int(input(f"\n{YELLOW}Choose an item (1-{len(enchantable_items) + 1}): {ENDC}"))
        if choice == len(enchantable_items) + 1:
            print_animated(f"{YELLOW}Enchantment canceled.{ENDC}", delay=0.03)
            return

        if 1 <= choice <= len(enchantable_items):
            selected_item = enchantable_items[choice - 1]

            # Get available enchantments based on item type and player level
            available_enchants = get_available_enchantments(selected_item["type"], user_data["level"])

            if not available_enchants:
                print_animated(f"{YELLOW}No enchantments available for this item.{ENDC}", delay=0.03)
                return

            # Check if player has materials
            required_materials = {
                "Common": {"Magical Dust": 5},
                "Uncommon": {"Magical Dust": 10, "Enchanted Fragment": 2},
                "Rare": {"Magical Dust": 20, "Enchanted Fragment": 5, "Arcane Crystal": 1},
                "Epic": {"Magical Dust": 30, "Enchanted Fragment": 10, "Arcane Crystal": 3, "Ethereal Essence": 1},
                "Legendary": {"Magical Dust": 50, "Enchanted Fragment": 20, "Arcane Crystal": 5, "Ethereal Essence": 3}
            }

            item_rarity = selected_item.get("rarity", "Common")
            materials_needed = required_materials.get(item_rarity, required_materials["Common"])

            # Check if player has the materials
            has_materials = True
            for material, amount in materials_needed.items():
                count = user_data["inventory"].count(material)
                if count < amount:
                    has_materials = False
                    break

            # Display enchantment options
            print_header(f"Enchant {selected_item['name']}")

            # Show required materials
            print_animated(f"{CYAN}Required Materials:{ENDC}", delay=0.02)
            for material, amount in materials_needed.items():
                current = user_data["inventory"].count(material)
                color = GREEN if current >= amount else RED
                print(f"- {material}: {color}{current}/{amount}{ENDC}")

            if not has_materials:
                print_animated(f"\n{RED}You don't have enough materials for enchanting.{ENDC}", delay=0.03)
                return

            print_animated(f"\n{CYAN}Available Enchantments:{ENDC}", delay=0.03)
            for i, enchant in enumerate(available_enchants, 1):
                print(f"{i}. {LIGHTMAGENTA}{enchant['name']}{ENDC} - {enchant['description']}")

            print(f"{len(available_enchants) + 1}. {YELLOW}Cancel{ENDC}")

            # Get enchantment choice
            try:
                enchant_choice = int(input(f"\n{YELLOW}Choose an enchantment (1-{len(available_enchants) + 1}): {ENDC}"))
                if enchant_choice == len(available_enchants) + 1:
                    print_animated(f"{YELLOW}Enchantment canceled.{ENDC}", delay=0.03)
                    return

                if 1 <= enchant_choice <= len(available_enchants):
                    selected_enchant = available_enchants[enchant_choice - 1]

                    # Apply enchantment
                    print_animated(f"{BG_MAGENTA}{WHITE} ENCHANTING... {ENDC}", delay=0.5)
                    print_animated(f"{LIGHTMAGENTA}Mystical energies swirl around the {selected_item['name']}...{ENDC}", delay=0.05)

                    # Calculate success chance based on rarity and player stats
                    success_chance = {
                        "Common": 0.95,
                        "Uncommon": 0.85,
                        "Rare": 0.75,
                        "Epic": 0.65,
                        "Legendary": 0.50
                    }.get(item_rarity, 0.95)

                    # Increase chance based on player stats
                    if "crafting" in user_data:
                        success_chance += min(0.3, user_data["crafting"] * 0.01)

                    # Roll for success
                    if random.random() < success_chance:
                        # Success!
                        selected_item["enchantment"] = {
                            "name": selected_enchant["name"],
                            "effect": selected_enchant["effect"],
                            "effect_value": selected_enchant["value"]
                        }

                        print_animated(f"\n{BG_GREEN}{BLACK} SUCCESS! {ENDC}", delay=0.03)
                        print_animated(f"Your {selected_item['name']} is now enchanted with {LIGHTMAGENTA}{selected_enchant['name']}{ENDC}!", delay=0.03)

                        # Apply the enchantment effect to the item's stats if applicable
                        if selected_enchant["effect"] == "damage":
                            if "effect" not in selected_item:
                                selected_item["effect"] = 0
                            selected_item["effect"] += selected_enchant["value"]
                        elif selected_enchant["effect"] == "defense":
                            if "effect" not in selected_item:
                                selected_item["effect"] = 0
                            selected_item["effect"] += selected_enchant["value"]

                        # Add element if the enchantment adds one
                        if "element" in selected_enchant:
                            selected_item["element"] = selected_enchant["element"]

                        # Update achievement stats
                        if "achievements" in user_data and "progress" in user_data["achievements"]:
                            if "items_enchanted" not in user_data["achievements"]["progress"]:
                                user_data["achievements"]["progress"]["items_enchanted"] = 0
                            user_data["achievements"]["progress"]["items_enchanted"] += 1

                        # Check achievements
                        check_achievements()
                    else:
                        # Failure
                        print_animated(f"\n{BG_RED}{WHITE} FAILURE! {ENDC}", delay=0.03)
                        print_animated("The enchantment failed! The materials were consumed but the item remains unchanged.", delay=0.03)

                    # Consume materials
                    for material, amount in materials_needed.items():
                        for _ in range(amount):
                            user_data["inventory"].remove(material)

                else:
                    print_animated(f"{YELLOW}Invalid enchantment choice.{ENDC}", delay=0.03)
            except ValueError:
                print_animated(f"{RED}Invalid input. Please enter a number.{ENDC}", delay=0.03)
        else:
            print_animated(f"{YELLOW}Invalid item choice.{ENDC}", delay=0.03)
    except ValueError:
        print_animated(f"{RED}Invalid input. Please enter a number.{ENDC}", delay=0.03)

def get_available_enchantments(item_type: str, player_level: int) -> List[Dict[str, Any]]:
    """Get available enchantments based on item type and player level"""
    all_enchantments = {
        # Weapon enchantments
        "weapon": [
            {
                "name": "Sharpness",
                "description": "Increases damage by 5",
                "effect": "damage",
                "value": 5,
                "min_level": 1
            },
            {
                "name": "Fire Aspect",
                "description": "Adds Fire element and deals 3 damage over time",
                "effect": "dot",
                "value": 3,
                "element": "Fire",
                "min_level": 5
            },
            {
                "name": "Frost Bite",
                "description": "Adds Ice element and has 20% chance to slow enemies",
                "effect": "slow",
                "value": 0.2,
                "element": "Ice",
                "min_level": 5
            },
            {
                "name": "Thunder Strike",
                "description": "Adds Lightning element and has 15% chance to stun",
                "effect": "stun",
                "value": 0.15,
                "element": "Lightning",
                "min_level": 10
            },
            {
                "name": "Life Steal",
                "description": "Heals for 10% of damage dealt",
                "effect": "lifesteal",
                "value": 0.1,
                "min_level": 15
            },
            {
                "name": "Critical Edge",
                "description": "Increases critical hit chance by 10%",
                "effect": "critical_chance",
                "value": 0.1,
                "min_level": 10
            },
            {
                "name": "Executioner",
                "description": "Deals 20% more damage to enemies below 30% health",
                "effect": "execute",
                "value": 0.2,
                "min_level": 20
            },
            {
                "name": "Vorpal Edge",
                "description": "Critical hits deal 50% more damage",
                "effect": "critical_damage",
                "value": 0.5,
                "min_level": 25
            }
        ],

        # Armor enchantments
        "armor": [
            {
                "name": "Protection",
                "description": "Increases defense by 5",
                "effect": "defense",
                "value": 5,
                "min_level": 1
            },
            {
                "name": "Flame Ward",
                "description": "Reduces Fire damage by 20%",
                "effect": "fire_resist",
                "value": 0.2,
                "min_level": 5
            },
            {
                "name": "Frost Ward",
                "description": "Reduces Ice damage by 20%",
                "effect": "ice_resist",
                "value": 0.2,
                "min_level": 5
            },
            {
                "name": "Thunder Ward",
                "description": "Reduces Lightning damage by 20%",
                "effect": "lightning_resist",
                "value": 0.2,
                "min_level": 5
            },
            {
                "name": "Vitality",
                "description": "Increases max health by 20",
                "effect": "health",
                "value": 20,
                "min_level": 10
            },
            {
                "name": "Regeneration",
                "description": "Regenerates 2 health per turn",
                "effect": "regen",
                "value": 2,
                "min_level": 15
            },
            {
                "name": "Thorns",
                "description": "Reflects 15% of damage back to attacker",
                "effect": "reflect",
                "value": 0.15,
                "min_level": 20
            },
            {
                "name": "Evasion",
                "description": "Increases dodge chance by 10%",
                "effect": "dodge",
                "value": 0.1,
                "min_level": 25
            }
        ],

        # Accessory enchantments
        "accessory": [
            {
                "name": "Swift",
                "description": "Increases speed by 3",
                "effect": "speed",
                "value": 3,
                "min_level": 1
            },
            {
                "name": "Wise",
                "description": "Increases intellect by 3",
                "effect": "intellect",
                "value": 3,
                "min_level": 1
            },
            {
                "name": "Lucky",
                "description": "Increases item drop chance by 15%",
                "effect": "loot_chance",
                "value": 0.15,
                "min_level": 5
            },
            {
                "name": "Wealth",
                "description": "Increases gold drops by 20%",
                "effect": "gold_bonus",
                "value": 0.2,
                "min_level": 10
            },
            {
                "name": "Experience",
                "description": "Increases XP gain by 10%",
                "effect": "exp_bonus",
                "value": 0.1,
                "min_level": 15
            },
            {
                "name": "Elemental Mastery",
                "description": "Increases elemental damage by 20%",
                "effect": "elemental_damage",
                "value": 0.2,
                "min_level": 20
            },
            {
                "name": "Charisma",
                "description": "Reduces shop prices by 15%",
                "effect": "shop_discount",
                "value": 0.15,
                "min_level": 25
            }
        ]
    }

    # Filter enchantments by level requirement
    available = [enchant for enchant in all_enchantments.get(item_type, []) if enchant["min_level"] <= player_level]

    return available

def upgrade_item() -> None:
    """Function to level up weapons and armor"""
    print_header("Item Upgrade")

    # Get list of upgradable equipment
    upgradable_items = []
    if "equipment" in user_data:
        for item in user_data["equipment"]:
            # Only weapons, armor, and accessories can be upgraded
            if item.get("type") in ["weapon", "armor", "accessory"]:
                upgradable_items.append(item)

    if not upgradable_items:
        print_animated(f"{YELLOW}You don't have any items that can be upgraded.{ENDC}", delay=0.03)
        return

    # Display upgradable items
    print_animated(f"{CYAN}Select an item to upgrade:{ENDC}", delay=0.03)
    for i, item in enumerate(upgradable_items, 1):
        rarity_color = get_rarity_color(item.get("rarity", "Common"))
        level_text = f" (Level {item.get('level', 1)})"
        print(f"{i}. {rarity_color}{item['name']}{ENDC}{level_text}")

    print(f"{len(upgradable_items) + 1}. {YELLOW}Cancel{ENDC}")

    # Get user selection
    try:
        choice = int(input(f"\n{YELLOW}Choose an item (1-{len(upgradable_items) + 1}): {ENDC}"))
        if choice == len(upgradable_items) + 1:
            print_animated(f"{YELLOW}Upgrade canceled.{ENDC}", delay=0.03)
            return

        if 1 <= choice <= len(upgradable_items):
            selected_item = upgradable_items[choice - 1]

            # Get current item level
            current_level = selected_item.get("level", 1)
            max_level = 10

            if current_level >= max_level:
                print_animated(f"{YELLOW}This item is already at maximum level.{ENDC}", delay=0.03)
                return

            # Calculate upgrade costs based on rarity and current level
            upgrade_costs = {
                "Common": {"base_gold": 100, "materials": {"Iron Ingot": 2, "Leather": 1}},
                "Uncommon": {"base_gold": 250, "materials": {"Iron Ingot": 3, "Leather": 2, "Silver Ingot": 1}},
                "Rare": {"base_gold": 500, "materials": {"Silver Ingot": 3, "Leather": 3, "Magical Dust": 2}},
                "Epic": {"base_gold": 1000, "materials": {"Gold Ingot": 2, "Enchanted Fragment": 3, "Magical Dust": 5}},
                "Legendary": {"base_gold": 2500, "materials": {"Gold Ingot": 4, "Enchanted Fragment": 5, "Arcane Crystal": 2}}
            }

            item_rarity = selected_item.get("rarity", "Common")
            base_cost = upgrade_costs.get(item_rarity, upgrade_costs["Common"])

            # Scale gold cost based on level
            gold_cost = base_cost["base_gold"] * current_level

            # Scale material costs
            materials_needed = {}
            for material, amount in base_cost["materials"].items():
                materials_needed[material] = amount * current_level

            # Display upgrade details
            print_header(f"Upgrade {selected_item['name']}")

            print(f"Current Level: {CYAN}{current_level}{ENDC}")
            print(f"New Level: {GREEN}{current_level + 1}{ENDC}")

            # Show stat improvements
            item_type = selected_item.get("type", "weapon")
            current_effect = selected_item.get("effect", 0)

            if item_type == "weapon":
                upgrade_bonus = 2 * current_level
                print(f"Damage: {CYAN}{current_effect}{ENDC} → {GREEN}{current_effect + upgrade_bonus}{ENDC} (+{upgrade_bonus})")
            elif item_type == "armor":
                upgrade_bonus = 1 * current_level
                print(f"Defense: {CYAN}{current_effect}{ENDC} → {GREEN}{current_effect + upgrade_bonus}{ENDC} (+{upgrade_bonus})")
            else:  # accessory
                upgrade_bonus = 1 * current_level
                print(f"Effect: {CYAN}{current_effect}{ENDC} → {GREEN}{current_effect + upgrade_bonus}{ENDC} (+{upgrade_bonus})")

            # Show costs
            print(f"\n{CYAN}Upgrade Cost:{ENDC}")
            print(f"- Gold: {LIGHTYELLOW}{gold_cost}{ENDC}")

            # Check if player has enough gold
            has_gold = user_data["gold"] >= gold_cost
            gold_color = GREEN if has_gold else RED
            print(f"  {gold_color}You have: {user_data['gold']}{ENDC}")

            print(f"{CYAN}Required Materials:{ENDC}")
            has_materials = True
            for material, amount in materials_needed.items():
                current = user_data["inventory"].count(material)
                if current < amount:
                    has_materials = False

                color = GREEN if current >= amount else RED
                print(f"- {material}: {color}{current}/{amount}{ENDC}")

            # Check if player can afford upgrade
            if not has_gold or not has_materials:
                print_animated(f"\n{RED}You don't have enough resources for this upgrade.{ENDC}", delay=0.03)
                return

            # Ask for confirmation
            print()
            confirm = input(f"{YELLOW}Proceed with upgrade? (y/n): {ENDC}").lower()
            if confirm != 'y':
                print_animated(f"{YELLOW}Upgrade canceled.{ENDC}", delay=0.03)
                return

            # Perform upgrade
            print_animated(f"{BG_CYAN}{BLACK} UPGRADING... {ENDC}", delay=0.5)

            # Success chance decreases with higher levels
            success_chance = 1.0 - (current_level * 0.05)

            # Improve chance based on crafting skill
            if "crafting" in user_data:
                success_chance += min(0.3, user_data["crafting"] * 0.01)

            # Cap success chance between 50% and 95%
            success_chance = max(0.5, min(0.95, success_chance))

            # Roll for success
            if random.random() < success_chance:
                # Success!
                # Update item level
                selected_item["level"] = current_level + 1

                # Update item stats based on type
                if item_type == "weapon":
                    if "effect" not in selected_item:
                        selected_item["effect"] = 0
                    selected_item["effect"] += upgrade_bonus
                elif item_type == "armor":
                    if "effect" not in selected_item:
                        selected_item["effect"] = 0
                    selected_item["effect"] += upgrade_bonus
                else:  # accessory
                    if "effect" not in selected_item:
                        selected_item["effect"] = 0
                    selected_item["effect"] += upgrade_bonus

                print_animated(f"\n{BG_GREEN}{BLACK} SUCCESS! {ENDC}", delay=0.03)
                print_animated(f"Your {selected_item['name']} has been upgraded to level {selected_item['level']}!", delay=0.03)

                # Update achievement stats
                if "achievements" in user_data and "progress" in user_data["achievements"]:
                    if "items_upgraded" not in user_data["achievements"]["progress"]:
                        user_data["achievements"]["progress"]["items_upgraded"] = 0
                    user_data["achievements"]["progress"]["items_upgraded"] += 1

                # Check achievements
                check_achievements()
            else:
                # Failure - item remains the same but resources are consumed
                print_animated(f"\n{BG_RED}{WHITE} FAILURE! {ENDC}", delay=0.03)
                print_animated("The upgrade failed! The materials were consumed but the item remains unchanged.", delay=0.03)

                # Critical failure chance increases with level (small chance to downgrade or break)
                critical_failure_chance = 0.05 * current_level
                if random.random() < critical_failure_chance and current_level > 1:
                    # 50% chance to downgrade, 50% chance to lose enchantment
                    if random.random() < 0.5 and current_level > 1:
                        selected_item["level"] = current_level - 1
                        print_animated(f"{RED}The item was downgraded to level {selected_item['level']}!{ENDC}", delay=0.03)
                    elif "enchantment" in selected_item:
                        del selected_item["enchantment"]
                        print_animated(f"{RED}The enchantment was lost in the failed upgrade attempt!{ENDC}", delay=0.03)

            # Consume resources
            user_data["gold"] -= gold_cost
            for material, amount in materials_needed.items():
                for _ in range(amount):
                    user_data["inventory"].remove(material)
        else:
            print_animated(f"{YELLOW}Invalid item choice.{ENDC}", delay=0.03)
    except ValueError:
        print_animated(f"{RED}Invalid input. Please enter a number.{ENDC}", delay=0.03)

def open_chest(tier: str = "Common") -> None:
    """Open a treasure chest and get random loot

    Args:
        tier: The rarity tier of the chest (Common, Uncommon, Rare, Epic, Legendary)
    """
    print_header(f"Opening {tier} Chest")

    # Add visual effects based on chest rarity
    rarity_color = get_rarity_color(tier)
    print_animated(f"{BG_CYAN}{BLACK} OPENING CHEST... {ENDC}", delay=0.5)
    print_animated(f"{rarity_color}The {tier} chest creaks open, revealing its contents...{ENDC}", delay=0.05)

    # Define loot tables for different chest tiers
    chest_contents = {
        # Standard rarity-based chests
        "Common": {
            "gold_range": (25, 100),
            "item_count": (1, 3),
            "material_count": (2, 4),
            "equipment_chance": 0.2,
            "rare_material_chance": 0.1,
            "rarity_weights": {"Common": 80, "Uncommon": 20, "Rare": 0, "Epic": 0, "Legendary": 0},
            "artifact_chance": 0.05,
            "special_item_chance": 0.01
        },
        "Uncommon": {
            "gold_range": (100, 300),
            "item_count": (2, 4),
            "material_count": (3, 6),
            "equipment_chance": 0.4,
            "rare_material_chance": 0.25,
            "rarity_weights": {"Common": 50, "Uncommon": 40, "Rare": 10, "Epic": 0, "Legendary": 0},
            "artifact_chance": 0.1,
            "special_item_chance": 0.05
        },
        "Rare": {
            "gold_range": (300, 750),
            "item_count": (3, 5),
            "material_count": (4, 8),
            "equipment_chance": 0.6,
            "rare_material_chance": 0.5,
            "rarity_weights": {"Common": 20, "Uncommon": 50, "Rare": 25, "Epic": 5, "Legendary": 0},
            "artifact_chance": 0.2,
            "special_item_chance": 0.1
        },
        "Epic": {
            "gold_range": (750, 1500),
            "item_count": (3, 6),
            "material_count": (5, 10),
            "equipment_chance": 0.8,
            "rare_material_chance": 0.75,
            "rarity_weights": {"Common": 5, "Uncommon": 25, "Rare": 45, "Epic": 20, "Legendary": 5},
            "artifact_chance": 0.4,
            "special_item_chance": 0.2
        },
        "Legendary": {
            "gold_range": (1500, 3000),
            "item_count": (4, 8),
            "material_count": (6, 12),
            "equipment_chance": 1.0,
            "rare_material_chance": 1.0,
            "rarity_weights": {"Common": 0, "Uncommon": 10, "Rare": 40, "Epic": 35, "Legendary": 15},
            "artifact_chance": 0.75,
            "special_item_chance": 0.5
        },

        # Specialized chests with themed contents
        "Weather": {
            "gold_range": (200, 800),
            "item_count": (2, 4),
            "material_count": (3, 6),
            "equipment_chance": 0.5,
            "rare_material_chance": 0.6,
            "rarity_weights": {"Common": 10, "Uncommon": 40, "Rare": 35, "Epic": 10, "Legendary": 5},
            "artifact_chance": 0.5,
            "special_item_chance": 0.3,
            "weather_artifact_chance": 0.8,  # High chance for weather-themed artifacts
            "special_resources": ["Storm Crystal", "Mist Essence", "Sunlight Fragment", "Rain Drop", "Snow Flake", "Wind Whisper", "Cloud Fragment"],
            "description": "A chest that seems to change with the weather, containing items attuned to natural forces."
        },
        "Seasonal": {
            "gold_range": (300, 1000),
            "item_count": (2, 5),
            "material_count": (4, 8),
            "equipment_chance": 0.6,
            "rare_material_chance": 0.7,
            "rarity_weights": {"Common": 5, "Uncommon": 30, "Rare": 40, "Epic": 20, "Legendary": 5},
            "artifact_chance": 0.6,
            "special_item_chance": 0.4,
            "seasonal_artifact_chance": 0.8,  # High chance for season-themed artifacts
            "special_resources": ["Spring Essence", "Summer Heat", "Autumn Leaf", "Winter Frost"],
            "description": "A chest that changes with the seasons, containing seasonal items and artifacts."
        },
        "Farming": {
            "gold_range": (100, 500),
            "item_count": (3, 6),
            "material_count": (5, 10),
            "equipment_chance": 0.3,
            "rare_material_chance": 0.5,
            "rarity_weights": {"Common": 20, "Uncommon": 45, "Rare": 30, "Epic": 5, "Legendary": 0},
            "artifact_chance": 0.4,
            "special_item_chance": 0.2,
            "seed_chance": 1.0,  # Always contains seeds
            "rare_seed_chance": 0.5,  # Good chance for rare seeds
            "special_resources": ["Fertilizer", "Premium Soil", "Magic Water", "Growth Tonic", "Season Extender"],
            "description": "A chest filled with farming supplies, seeds, and agricultural artifacts."
        },
        "Artifact": {
            "gold_range": (500, 1200),
            "item_count": (1, 3),
            "material_count": (2, 5),
            "equipment_chance": 0.2,
            "rare_material_chance": 0.4,
            "rarity_weights": {"Common": 5, "Uncommon": 15, "Rare": 40, "Epic": 30, "Legendary": 10},
            "artifact_chance": 1.0,  # Always contains at least one artifact
            "multi_artifact_chance": 0.5,  # 50% chance for multiple artifacts
            "special_item_chance": 0.6,
            "special_resources": ["Artifact Fragment", "Ancient Power", "Mystic Essence", "Divine Spark"],
            "description": "A mysterious chest radiating powerful energy, containing magical artifacts."
        },
        "Void": {
            "gold_range": (1000, 3000),
            "item_count": (3, 6),
            "material_count": (4, 8),
            "equipment_chance": 0.8,
            "rare_material_chance": 0.9,
            "rarity_weights": {"Common": 0, "Uncommon": 5, "Rare": 25, "Epic": 45, "Legendary": 25},
            "artifact_chance": 0.8,
            "special_item_chance": 0.7,
            "unique_item_chance": 0.3,  # Chance for dimension-specific unique items
            "special_resources": ["Void Fragment", "Chaos Crystal", "Reality Shard", "Dimensional Essence", "Cosmic Dust"],
            "description": "A chest that seems to exist between dimensions, containing items beyond normal reality."
        }
    }

    # Default to Common if tier not found
    chest_config = chest_contents.get(tier, chest_contents["Common"])

    # Generate gold
    gold_min, gold_max = chest_config["gold_range"]
    gold_amount = random.randint(gold_min, gold_max)

    # Generate items
    min_items, max_items = chest_config["item_count"]
    item_count = random.randint(min_items, max_items)

    # Generate materials
    min_materials, max_materials = chest_config["material_count"]
    material_count = random.randint(min_materials, max_materials)

    # Prepare lists for different types of loot
    loot_items = []
    loot_equipment = []
    loot_materials = []

    # Common items pool
    common_items = [
        "Healing Potion", "Mana Potion", "Strength Potion", "Defense Potion", 
        "Speed Potion", "Antidote", "Torch", "Rope", "Bandage", "Food Ration"
    ]

    # Material pools
    common_materials = [
        "Wood", "Stone", "Iron Ore", "Leather", "Cloth", "Bone", "Plant Fiber",
        "Coal", "Sand", "Clay"
    ]

    uncommon_materials = [
        "Silver Ore", "Iron Ingot", "Silk", "Fur", "Feather", "Gem Shard", 
        "Hardwood", "Glass", "Saltpeter", "Hardened Leather"
    ]

    rare_materials = [
        "Gold Ore", "Silver Ingot", "Gold Ingot", "Magical Dust", "Crystal Shard",
        "Enchanted Fragment", "Rare Herb", "Monster Essence", "Mystic Oil", "Rune Fragment"
    ]

    epic_materials = [
        "Arcane Crystal", "Mythril Ore", "Dragon Scale", "Phoenix Feather",
        "Ethereal Essence", "Void Fragment", "Cosmic Dust", "Elemental Core",
        "Ancient Relic Piece", "Abyssal Pearl"
    ]

    # Weapon types
    weapon_types = ["Sword", "Axe", "Dagger", "Staff", "Bow", "Wand", "Hammer", "Spear"]

    # Armor types
    armor_types = ["Helmet", "Chestplate", "Leggings", "Boots", "Gauntlets", "Shield"]

    # Accessory types
    accessory_types = ["Ring", "Amulet", "Charm", "Bracelet", "Belt", "Earring"]

    # Add gold
    user_data["gold"] += gold_amount

    # Add common items
    for _ in range(item_count):
        loot_items.append(random.choice(common_items))

    # Add materials
    for _ in range(material_count):
        # Determine rarity of material
        if random.random() < chest_config["rare_material_chance"]:
            if tier == "Legendary":
                loot_materials.append(random.choice(epic_materials))
            elif tier in ["Epic", "Rare"]:
                loot_materials.append(random.choice(rare_materials))
            else:
                loot_materials.append(random.choice(uncommon_materials))
        else:
            loot_materials.append(random.choice(common_materials))

    # Add equipment
    if random.random() < chest_config["equipment_chance"]:
        # Determine equipment type
        equip_type = random.choice(["weapon", "armor", "accessory"])

        # Choose specific equipment
        if equip_type == "weapon":
            equip_name = random.choice(weapon_types)
        elif equip_type == "armor":
            equip_name = random.choice(armor_types)
        else:  # accessory
            equip_name = random.choice(accessory_types)

        # Determine rarity based on chest tier
        rarities = list(chest_config["rarity_weights"].keys())
        weights = list(chest_config["rarity_weights"].values())
        rarity = random.choices(rarities, weights=weights, k=1)[0]

        # Generate prefix based on rarity
        prefixes = {
            "Common": ["Basic", "Simple", "Standard", "Plain", "Ordinary"],
            "Uncommon": ["Fine", "Strong", "Sturdy", "Keen", "Reinforced"],
            "Rare": ["Exceptional", "Valuable", "Quality", "Refined", "Pristine"],
            "Epic": ["Magnificent", "Heroic", "Superior", "Masterful", "Elite"],
            "Legendary": ["Ancient", "Mythical", "Godly", "Supreme", "Ultimate"]
        }

        prefix = random.choice(prefixes[rarity])

        # Determine if item has an element
        elements = ["Fire", "Water", "Earth", "Air", "Lightning", "Ice", "Light", "Dark"]
        has_element = random.random() < 0.3
        element = random.choice(elements) if has_element else None

        # Build the full item name
        if element:
            full_name = f"{prefix} {element} {equip_name}"
        else:
            full_name = f"{prefix} {equip_name}"

        # Calculate effect value based on rarity
        effect_value = {
            "Common": random.randint(1, 5),
            "Uncommon": random.randint(5, 10),
            "Rare": random.randint(10, 20),
            "Epic": random.randint(20, 30),
            "Legendary": random.randint(30, 50)
        }.get(rarity, 1)

        # Create equipment object
        equipment = {
            "name": full_name,
            "type": equip_type,
            "rarity": rarity,
            "effect": effect_value,
            "level": 1
        }

        if element:
            equipment["element"] = element

        loot_equipment.append(equipment)

    # Update global tracker for achievements
    if "treasure_chests_opened" not in user_data:
        user_data["treasure_chests_opened"] = 0
    user_data["treasure_chests_opened"] += 1

    # Update achievement progress
    if "achievements" in user_data and "progress" in user_data["achievements"]:
        if "treasure_chests_opened" not in user_data["achievements"]["progress"]:
            user_data["achievements"]["progress"]["treasure_chests_opened"] = 0
        user_data["achievements"]["progress"]["treasure_chests_opened"] += 1

    # Display loot
    print_animated(f"\n{LIGHTYELLOW}You found {gold_amount} gold!{ENDC}", delay=0.03)

    # Show equipment (most exciting first)
    if loot_equipment:
        print_animated(f"\n{CYAN}Equipment:{ENDC}", delay=0.03)
        for equip in loot_equipment:
            rarity_color = get_rarity_color(equip["rarity"])
            print_animated(f"- {rarity_color}{equip['name']}{ENDC} ({equip['rarity']} {equip['type'].capitalize()})", delay=0.03)

            # Add to player's equipment
            if "equipment" not in user_data:
                user_data["equipment"] = []
            user_data["equipment"].append(equip)

    # Show materials
    if loot_materials:
        print_animated(f"\n{GREEN}Materials:{ENDC}", delay=0.03)
        # Count duplicates
        material_counts = {}
        for material in loot_materials:
            material_counts[material] = material_counts.get(material, 0) + 1

        for material, count in material_counts.items():
            print_animated(f"- {material} x{count}", delay=0.02)

            # Add to inventory
            for _ in range(count):
                user_data["inventory"].append(material)

    # Show items
    if loot_items:
        print_animated(f"\n{LIGHTBLUE}Items:{ENDC}", delay=0.03)
        # Count duplicates
        item_counts = {}
        for item in loot_items:
            item_counts[item] = item_counts.get(item, 0) + 1

        for item, count in item_counts.items():
            print_animated(f"- {item} x{count}", delay=0.02)

            # Add to inventory
            for _ in range(count):
                user_data["inventory"].append(item)

    # For tracking unique items for achievements
    new_items = set(loot_items + loot_materials + [equip["name"] for equip in loot_equipment])
    if "all_collected_items" not in user_data:
        user_data["all_collected_items"] = []
    user_data["all_collected_items"].extend(list(new_items))

    common_materials = [
        "Wood", "Stone", "Iron Ore", "Leather", "Cloth", "Bone", "Plant Fiber",
        "Coal", "Sand", "Clay"
    ]

    uncommon_materials = [
        "Silver Ore", "Iron Ingot", "Silk", "Fur", "Feather", "Gem Shard", 
        "Hardwood", "Glass", "Saltpeter", "Hardened Leather"
    ]

    rare_materials = [
        "Gold Ore", "Silver Ingot", "Gold Ingot", "Magical Dust", "Crystal Shard",
        "Enchanted Fragment", "Rare Herb", "Monster Essence", "Mystic Oil", "Rune Fragment"
    ]

    epic_materials = [
        "Arcane Crystal", "Mythril Ore", "Dragon Scale", "Phoenix Feather",
        "Ethereal Essence", "Void Fragment", "Cosmic Dust", "Elemental Core",
        "Ancient Relic Piece", "Abyssal Pearl"
    ]

    # Weapon types
    weapon_types = ["Sword", "Axe", "Dagger", "Staff", "Bow", "Wand", "Hammer", "Spear"]

    # Armor types
    armor_types = ["Helmet", "Chestplate", "Leggings", "Boots", "Gauntlets", "Shield"]

    # Accessory types
    accessory_types = ["Ring", "Amulet", "Charm", "Bracelet", "Belt", "Earring"]

    # Add gold
    user_data["gold"] += gold_amount

    # Add common items
    for _ in range(item_count):
        loot_items.append(random.choice(common_items))

    # Add materials
    for _ in range(material_count):
        # Determine rarity of material
        if random.random() < chest_config["rare_material_chance"]:
            if tier == "Legendary":
                loot_materials.append(random.choice(epic_materials))
            elif tier in ["Epic", "Rare"]:
                loot_materials.append(random.choice(rare_materials))
            else:
                loot_materials.append(random.choice(uncommon_materials))
        else:
            loot_materials.append(random.choice(common_materials))

    # Add equipment
    if random.random() < chest_config["equipment_chance"]:
        # Determine equipment type
        equip_type = random.choice(["weapon", "armor", "accessory"])

        # Choose specific equipment
        if equip_type == "weapon":
            equip_name = random.choice(weapon_types)
        elif equip_type == "armor":
            equip_name = random.choice(armor_types)
        else:  # accessory
            equip_name = random.choice(accessory_types)

        # Determine rarity based on chest tier
        rarities = list(chest_config["rarity_weights"].keys())
        weights = list(chest_config["rarity_weights"].values())
        rarity = random.choices(rarities, weights=weights, k=1)[0]

        # Generate prefix based on rarity
        prefixes = {
            "Common": ["Basic", "Simple", "Standard", "Plain", "Ordinary"],
            "Uncommon": ["Fine", "Strong", "Sturdy", "Keen", "Reinforced"],
            "Rare": ["Exceptional", "Valuable", "Quality", "Refined", "Pristine"],
            "Epic": ["Magnificent", "Heroic", "Superior", "Masterful", "Elite"],
            "Legendary": ["Ancient", "Mythical", "Godly", "Supreme", "Ultimate"]
        }

        prefix = random.choice(prefixes[rarity])

        # Determine if item has an element
        elements = ["Fire", "Water", "Earth", "Air", "Lightning", "Ice", "Light", "Dark"]
        has_element = random.random() < 0.3
        element = random.choice(elements) if has_element else None

        # Build the full item name
        if element:
            full_name = f"{prefix} {element} {equip_name}"
        else:
            full_name = f"{prefix} {equip_name}"

        # Calculate effect value based on rarity
        effect_value = {
            "Common": random.randint(1, 5),
            "Uncommon": random.randint(5, 10),
            "Rare": random.randint(10, 20),
            "Epic": random.randint(20, 30),
            "Legendary": random.randint(30, 50)
        }.get(rarity, 1)

        # Create equipment object
        equipment = {
            "name": full_name,
            "type": equip_type,
            "rarity": rarity,
            "effect": effect_value,
            "level": 1
        }

        if element:
            equipment["element"] = element

        loot_equipment.append(equipment)

    # Update global tracker for achievements
    if "treasure_chests_opened" not in user_data:
        user_data["treasure_chests_opened"] = 0
    user_data["treasure_chests_opened"] += 1

    # Update achievement progress
    if "achievements" in user_data and "progress" in user_data["achievements"]:
        if "treasure_chests_opened" not in user_data["achievements"]["progress"]:
            user_data["achievements"]["progress"]["treasure_chests_opened"] = 0
        user_data["achievements"]["progress"]["treasure_chests_opened"] += 1

    # Display loot
    print_animated(f"\n{LIGHTYELLOW}You found {gold_amount} gold!{ENDC}", delay=0.03)

    # Show equipment (most exciting first)
    if loot_equipment:
        print_animated(f"\n{CYAN}Equipment:{ENDC}", delay=0.03)
        for equip in loot_equipment:
            rarity_color = get_rarity_color(equip["rarity"])
            print_animated(f"- {rarity_color}{equip['name']}{ENDC} ({equip['rarity']} {equip['type'].capitalize()})", delay=0.03)

            # Add to player's equipment
            if "equipment" not in user_data:
                user_data["equipment"] = []
            user_data["equipment"].append(equip)

    # Show materials
    if loot_materials:
        print_animated(f"\n{GREEN}Materials:{ENDC}", delay=0.03)
        # Count duplicates
        material_counts = {}
        for material in loot_materials:
            material_counts[material] = material_counts.get(material, 0) + 1

        for material, count in material_counts.items():
            print_animated(f"- {material} x{count}", delay=0.02)

            # Add to inventory
            for _ in range(count):
                user_data["inventory"].append(material)

    # Show items
    if loot_items:
        print_animated(f"\n{LIGHTBLUE}Items:{ENDC}", delay=0.03)
        # Count duplicates
        item_counts = {}
        for item in loot_items:
            item_counts[item] = item_counts.get(item, 0) + 1

        for item, count in item_counts.items():
            print_animated(f"- {item} x{count}", delay=0.02)

            # Add to inventory
            for _ in range(count):
                user_data["inventory"].append(item)

    # For tracking unique items for achievements
    new_items = set(loot_items + loot_materials + [equip["name"] for equip in loot_equipment])
    if "all_collected_items" not in user_data:
        user_data["all_collected_items"] = []
    user_data["all_collected_items"].extend(list(new_items))

    # Check achievements
    check_achievements()

    print_animated(f"\n{GREEN}All items have been added to your inventory!{ENDC}", delay=0.03)

def check_artifact_set_bonuses() -> Dict[str, Dict[int, Dict[str, Any]]]:
    """Check for artifact set bonuses based on equipped artifacts"""
    equipped_artifacts = []

    # Get all equipped artifacts
    for slot in ARTIFACT_SLOTS:
        slot_key = f"artifact_{slot.lower()}"
        if user_data.get("equipped", {}).get(slot_key):
            equipped_artifacts.append(user_data["equipped"][slot_key]["name"])

    # Check each set for bonuses
    active_bonuses = {}
    for set_name, set_info in ARTIFACT_SETS.items():
        pieces = set_info.get("pieces", [])
        equipped_count = sum(1 for artifact in equipped_artifacts if artifact in pieces)

        # Check if any set bonuses are active
        for piece_count, bonus in set_info.get("bonuses", {}).items():
            if equipped_count >= piece_count:
                if set_name not in active_bonuses:
                    active_bonuses[set_name] = {}
                active_bonuses[set_name][piece_count] = bonus

    # Store active bonuses in user data
    user_data["active_set_bonuses"] = active_bonuses

    # Print active bonuses
    if active_bonuses:
        print_colored("\nActive Artifact Set Bonuses:", YELLOW)
        for set_name, bonuses in active_bonuses.items():
            for piece_count, bonus in bonuses.items():
                print(f"{set_name} ({piece_count}-piece): " + ", ".join([f"{stat}: {value}" for stat, value in bonus.items()]))

    return active_bonuses


# Function to use potions (elemental immunities, damage boosters, etc.)
def use_potion(potion_name: str) -> None:
    """Use a potion from inventory

    Args:
        potion_name: The name of the potion to use
    """
    # Check if we have the potion
    if potion_name not in user_data["inventory"]:
        print_colored(f"You don't have a {potion_name}.", FAIL)
        return

    # Check if it's a valid potion
    if potion_name not in POTION_RECIPES:
        print_colored(f"{potion_name} is not a usable potion.", FAIL)
        return

    potion_info = POTION_RECIPES[potion_name]
    effect = potion_info.get("effect", {})

    # Handle different potion effects
    if "immunity" in effect:
        element = effect["immunity"]

        # Initialize immunities if not present
        if "active_immunities" not in user_data:
            user_data["active_immunities"] = {}

        # Add immunity
        user_data["active_immunities"][element] = True
        print_colored(f"You are now immune to {element} damage for your next battle!", OKGREEN)

    elif "damage_boost" in effect:
        element = effect["damage_boost"]

        # Initialize boosters if not present
        if "element_boosters" not in user_data:
            user_data["element_boosters"] = {}

        # Add damage boost
        user_data["element_boosters"][element] = 2.0  # Double damage
        print_colored(f"Your {element} damage is doubled for your next battle!", OKGREEN)

    # Remove the potion from inventory
    user_data["inventory"].remove(potion_name)

# Artifact rarities
ARTIFACT_RARITIES = {
    "Common": {
        "color": Fore.CYAN,  # CYAN
        "stat_multiplier": 1.0,
        "drop_chance": 0.5
    },
    "Uncommon": {
        "color": Fore.GREEN,  # GREEN
        "stat_multiplier": 1.2,
        "drop_chance": 0.3
    },
    "Rare": {
        "color": Fore.BLUE,  # BLUE
        "stat_multiplier": 1.5,
        "drop_chance": 0.15
    },
    "Epic": {
        "color": Fore.MAGENTA,  # MAGENTA
        "stat_multiplier": 1.8,
        "drop_chance": 0.04
    },
    "Legendary": {
        "color": Fore.YELLOW,  # YELLOW
        "stat_multiplier": 2.0,
        "drop_chance": 0.01
    }
}

# Elemental potion recipes
POTION_RECIPES = {
    # Immunity Potions
    "Elixir of Cold": {
        "materials": {"Ice Crystal": 2, "Water Essence": 3, "Magical Herb": 1},
        "effect": {"immunity": "Ignis"},
        "description": "Grants immunity to Ignis (fire) damage for one battle",
        "type": "potion"
    },
    "Liquor Levitas": {
        "materials": {"Wind Crystal": 2, "Feather": 3, "Magical Herb": 1},
        "effect": {"immunity": "Gē"},
        "description": "Grants immunity to Gē (earth) damage for one battle",
        "type": "potion"
    },
    "Aura of Lightning": {
        "materials": {"Thunder Crystal": 2, "Metal Shard": 3, "Magical Herb": 1},
        "effect": {"immunity": "Aqua"},
        "description": "Grants immunity to Aqua (water) damage for one battle",
        "type": "potion"
    },
    "Essence of Drought": {
        "materials": {"Fire Crystal": 2, "Sand": 3, "Magical Herb": 1},
        "effect": {"immunity": "Aqua"},
        "description": "Grants immunity to Aqua (water) damage for one battle",
        "type": "potion"
    },
    "Potion of Grounding": {
        "materials": {"Earth Crystal": 2, "Iron Ore": 3, "Magical Herb": 1},
        "effect": {"immunity": "Fulmen"},
        "description": "Grants immunity to Fulmen (lightning) damage for one battle",
        "type": "potion"
    },
    "Essence of Heat": {
        "materials": {"Fire Crystal": 2, "Coal": 3, "Magical Herb": 1},
        "effect": {"immunity": "Glacies"},
        "description": "Grants immunity to Glacies (ice) damage for one battle",
        "type": "potion"
    },
    "Veil of Shadows": {
        "materials": {"Shadow Essence": 2, "Night Flower": 3, "Magical Herb": 1},
        "effect": {"immunity": "Lux"},
        "description": "Grants immunity to Lux (light) damage for one battle",
        "type": "potion"
    },
    "Radiant Elixir": {
        "materials": {"Light Crystal": 2, "Sun Petal": 3, "Magical Herb": 1},
        "effect": {"immunity": "Tenebrae"},
        "description": "Grants immunity to Tenebrae (darkness) damage for one battle",
        "type": "potion"
    },
    "Antidote Supreme": {
        "materials": {"Pure Water": 2, "Cleansing Herb": 3, "Magical Herb": 1},
        "effect": {"immunity": "Venēnum"},
        "description": "Grants immunity to Venēnum (poison) damage for one battle",
        "type": "potion"
    },
    "Rust Solution": {
        "materials": {"Acid Extract": 2, "Plant Root": 3, "Magical Herb": 1},
        "effect": {"immunity": "Ferrum"},
        "description": "Grants immunity to Ferrum (metal) damage for one battle",
        "type": "potion"
    },
    "Spirit Ward": {
        "materials": {"Soul Fragment": 2, "Holy Water": 3, "Magical Herb": 1},
        "effect": {"immunity": "Pneuma"},
        "description": "Grants immunity to Pneuma (spirit) damage for one battle",
        "type": "potion"
    },
    "Herbicide Mixture": {
        "materials": {"Toxic Extract": 2, "Mushroom Spore": 3, "Magical Herb": 1},
        "effect": {"immunity": "Viridia"},
        "description": "Grants immunity to Viridia (plant) damage for one battle",
        "type": "potion"
    },

    # Damage Booster Potions
    "Blazing Catalyst": {
        "materials": {"Fire Crystal": 3, "Dragon Scale": 1, "Magical Herb": 2},
        "effect": {"damage_boost": "Ignis"},
        "description": "Doubles your Ignis (fire) damage for one battle",
        "type": "potion"
    },
    "Tsunami Extract": {
        "materials": {"Water Essence": 3, "Sea Shell": 1, "Magical Herb": 2},
        "effect": {"damage_boost": "Aqua"},
        "description": "Doubles your Aqua (water) damage for one battle",
        "type": "potion"
    },
    "Earthen Might": {
        "materials": {"Earth Crystal": 3, "Mountain Stone": 1, "Magical Herb": 2},
        "effect": {"damage_boost": "Gē"},
        "description": "Doubles your Gē (earth) damage for one battle",
        "type": "potion"
    },
    "Tempest Brew": {
        "materials": {"Wind Crystal": 3, "Cloud Essence": 1, "Magical Herb": 2},
        "effect": {"damage_boost": "Aer"},
        "description": "Doubles your Aer (air) damage for one battle",
        "type": "potion"
    },
    "Voltaic Solution": {
        "materials": {"Thunder Crystal": 3, "Charged Core": 1, "Magical Herb": 2},
        "effect": {"damage_boost": "Fulmen"},
        "description": "Doubles your Fulmen (lightning) damage for one battle",
        "type": "potion"
    },
    "Frost Amplifier": {
        "materials": {"Ice Crystal": 3, "Frozen Heart": 1, "Magical Herb": 2},
        "effect": {"damage_boost": "Glacies"},
        "description": "Doubles your Glacies (ice) damage for one battle",
        "type": "potion"
    }
}

# Cooking recipes and their effects
COOKING_RECIPES = {
    "Hearty Stew": {
        "ingredients": {"Meat": 2, "Vegetables": 3, "Herbs": 1},
        "difficulty": "easy",
        "fail_chance": 0.1,
        "cook_time": 2,  # In game ticks
        "health_restore": 40,
        "stamina_restore": 30,
        "buffs": {"strength": 2},
        "buff_duration": 60,  # In game ticks
        "experience": 15,
        "description": "A filling meat stew that restores health and provides strength."
    },
    "Fish Soup": {
        "ingredients": {"Fish": 2, "Vegetables": 2, "Water": 1},
        "difficulty": "easy",
        "fail_chance": 0.15,
        "cook_time": 2,
        "health_restore": 30,
        "stamina_restore": 25,
        "buffs": {"agility": 2},
        "buff_duration": 50,
        "experience": 12,
        "description": "A light fish soup that increases agility."
    },
    "Forest Salad": {
        "ingredients": {"Vegetables": 3, "Mushrooms": 2, "Herbs": 1},
        "difficulty": "easy",
        "fail_chance": 0.05,
        "cook_time": 1,
        "health_restore": 20,
        "stamina_restore": 40,
        "buffs": {"perception": 3},
        "buff_duration": 70,
        "experience": 10,
        "description": "A fresh salad that sharpens your senses."
    },
    "Miner's Pie": {
        "ingredients": {"Meat": 1, "Vegetables": 3, "Wheat": 2},
        "difficulty": "medium",
        "fail_chance": 0.2,
        "cook_time": 3,
        "health_restore": 45,
        "stamina_restore": 35,
        "buffs": {"endurance": 3},
        "buff_duration": 90,
        "experience": 20,
        "description": "A hearty pie that improves endurance for mining."
    },
    "Warrior's Feast": {
        "ingredients": {"Meat": 3, "Fish": 1, "Vegetables": 2, "Herbs": 2},
        "difficulty": "medium",
        "fail_chance": 0.25,
        "cook_time": 4,
        "health_restore": 60,
        "stamina_restore": 50,
        "buffs": {"strength": 4, "endurance": 2},
        "buff_duration": 100,
        "experience": 30,
        "description": "A feast fit for warriors, providing significant combat bonuses."
    },
    "Wizard's Delight": {
        "ingredients": {"Mushrooms": 3, "Magic Herbs": 2, "Fruits": 2},
        "difficulty": "hard",
        "fail_chance": 0.3,
        "cook_time": 3,
        "health_restore": 30,
        "stamina_restore": 30,
        "mana_restore": 50,
        "buffs": {"intelligence": 5},
        "buff_duration": 120,
        "experience": 35,
        "description": "A magical dish that enhances spellcasting abilities."
    },
    "Dragon Breath Curry": {
        "ingredients": {"Meat": 2, "Dragon Fruit": 1, "Ghost Pepper": 3},
        "difficulty": "very hard",
        "fail_chance": 0.4,
        "cook_time": 5,
        "health_restore": 70,
        "stamina_restore": 60,
        "buffs": {"fire_resistance": 5, "strength": 3},
        "buff_duration": 150,
        "experience": 50,
        "description": "An extremely spicy curry that grants fire resistance."
    },
    "Frost Lotus Tea": {
        "ingredients": {"Frost Lotus": 2, "Water": 1, "Honey": 1},
        "difficulty": "medium",
        "fail_chance": 0.2,
        "cook_time": 2,
        "health_restore": 25,
        "stamina_restore": 20,
        "mana_restore": 40,
        "buffs": {"ice_resistance": 4},
        "buff_duration": 100,
        "experience": 25,
        "description": "A cooling tea that grants resistance to ice damage."
    },
    "Thunder Root Broth": {
        "ingredients": {"Thunderroot": 2, "Meat": 1, "Water": 1, "Herbs": 1},
        "difficulty": "hard",
        "fail_chance": 0.35,
        "cook_time": 4,
        "health_restore": 40,
        "stamina_restore": 35,
        "buffs": {"lightning_resistance": 4, "agility": 2},
        "buff_duration": 120,
        "experience": 40,
        "description": "A tingling broth that protects against lightning damage."
    },
    "Seasonal Harvest": {
        "ingredients": {"Spring Tulips": 1, "Summer Melon": 1, "Autumn Squash": 1, "Winter Mint": 1},
        "difficulty": "very hard",
        "fail_chance": 0.45,
        "cook_time": 6,
        "health_restore": 80,
        "stamina_restore": 80,
        "mana_restore": 80,
        "buffs": {"all_stats": 2},
        "buff_duration": 200,
        "experience": 60,
        "description": "A rare dish combining all seasons' bounty, providing resistance to all elements."
    }
}

# Failed cooking results
FAILED_COOKING = {
    "easy": {
        "name": "Burned Mess", 
        "health_restore": 5, 
        "description": "Slightly burned but still edible."
    },
    "medium": {
        "name": "Charred Disaster", 
        "health_restore": 0, 
        "description": "Completely ruined and barely edible."
    },
    "hard": {
        "name": "Inedible Catastrophe", 
        "health_restore": -5, 
        "description": "This might make you sick if you eat it."
    },
    "very hard": {
        "name": "Toxic Concoction", 
        "health_restore": -10, 
        "description": "This definitely looks dangerous to consume."
    }
}

# Enchantment types and their effects
ENCHANTMENTS = {
    # Weapon enchantments
    "Sharpness": {
        "description": "Increases weapon damage by 10% per level",
        "max_level": 5,
        "applicable_to": ["weapon"],
        "materials_per_level": {"Sharpening Stone": 2, "Magic Dust": 1}
    },
    "Elemental Fury": {
        "description": "Increases elemental damage by 10% per level", 
        "max_level": 5,
        "applicable_to": ["weapon"],
        "materials_per_level": {"Elemental Essence": 2, "Magic Crystal": 1}
    },
    "Giant Slayer": {
        "description": "Deals 15% more damage per level to large monsters",
        "max_level": 3,
        "applicable_to": ["weapon"],
        "materials_per_level": {"Giant's Tooth": 1, "Magic Dust": 2}
    },
    "Soul Stealer": {
        "description": "Has a 5% chance per level to steal health on hit",
        "max_level": 3,
        "applicable_to": ["weapon"],
        "materials_per_level": {"Spirit Essence": 2, "Blood Crystal": 1}
    },
    "Critical Eye": {
        "description": "Increases critical hit chance by a 5% per level",
        "max_level": 5,
        "applicable_to": ["weapon"],
        "materials_per_level": {"Hawk's Eye": 1, "Magic Dust": 2}
    },

    # Armor enchantments
    "Protection": {
        "description": "Reduces damage taken by 5% per level",
        "max_level": 5,
        "applicable_to": ["armor"],
        "materials_per_level": {"Steel Plate": 2, "Magic Dust": 1}
    },
    "Elemental Resist": {
        "description": "Reduces elemental damage by 10% per level",
        "max_level": 5,
        "applicable_to": ["armor"],
        "materials_per_level": {"Elemental Barrier": 2, "Magic Crystal": 1}
    },
    "Health Boost": {
        "description": "Increases maximum health by 10 per level",
        "max_level": 5,
        "applicable_to": ["armor"],
        "materials_per_level": {"Vitality Crystal": 1, "Magic Dust": 2}
    },
    "Thorns": {
        "description": "Deals 5% of damage back to attackers per level",
        "max_level": 3,
        "applicable_to": ["armor"],
        "materials_per_level": {"Thorned Vine": 2, "Magic Dust": 1}
    },
    "Evasion": {
        "description": "Increases dodge chance by 3% per level",
        "max_level": 5,
        "applicable_to": ["armor"],
        "materials_per_level": {"Swift Feather": 2, "Magic Dust": 1}
    }
}

# Random chest tiers and their potential contents
CHEST_TIERS = {
    "Common": {
        "gold_range": (10, 50),
        "item_count_range": (1, 2),
        "item_chances": {
            "material": 0.7,
            "potion": 0.2,
            "equipment": 0.1
        },
        "equipment_rarity_chances": {
            "Common": 0.8,
            "Uncommon": 0.2
        }
    },
    "Uncommon": {
        "gold_range": (30, 100),
        "item_count_range": (1, 3),
        "item_chances": {
            "material": 0.6,
            "potion": 0.3,
            "equipment": 0.1
        },
        "equipment_rarity_chances": {
            "Common": 0.6,
            "Uncommon": 0.3,
            "Rare": 0.1
        }
    },
    "Rare": {
        "gold_range": (75, 200),
        "item_count_range": (2, 4),
        "item_chances": {
            "material": 0.5,
            "potion": 0.3,
            "equipment": 0.15,
            "artifact": 0.05
        },
        "equipment_rarity_chances": {
            "Common": 0.3,
            "Uncommon": 0.5,
            "Rare": 0.2
        },
        "artifact_rarity_chances": {
            "Common": 0.6,
            "Uncommon": 0.3,
            "Rare": 0.1
        }
    },
    "Epic": {
        "gold_range": (150, 350),
        "item_count_range": (3, 5),
        "item_chances": {
            "material": 0.4,
            "potion": 0.3,
            "equipment": 0.2,
            "artifact": 0.1
        },
        "equipment_rarity_chances": {
            "Uncommon": 0.4,
            "Rare": 0.4,
            "Epic": 0.2
        },
        "artifact_rarity_chances": {
            "Uncommon": 0.5,
            "Rare": 0.3,
            "Epic": 0.2
        }
    },
    "Legendary": {
        "gold_range": (300, 800),
        "item_count_range": (4, 6),
        "item_chances": {
            "material": 0.3,
            "potion": 0.2,
            "equipment": 0.3,
            "artifact": 0.2
        },
        "equipment_rarity_chances": {
            "Rare": 0.4,
            "Epic": 0.4,
            "Legendary": 0.2
        },
        "artifact_rarity_chances": {
            "Rare": 0.5,
            "Epic": 0.3,
            "Legendary": 0.2
        }
    }
}

# Artifact set bonuses
ARTIFACT_SETS = {
    "Wisdom of the Ancients": {
        "pieces": ["Crown of Wisdom", "Timekeeper's Watch", "Band of Power"],
        "bonuses": {
            2: {"intelligence": 15, "cooldown_reduction": 0.1},
            3: {"intelligence": 30, "cooldown_reduction": 0.2, "max_mana": 50}
        }
    },
    "Eternal Flame": {
        "pieces": ["Ember Pendant", "Phoenix Plume", "Ring of Fire"],
        "bonuses": {
            2: {"fire_damage": 0.15, "fire_resistance": 0.15},
            3: {"fire_damage": 0.3, "fire_resistance": 0.3, "revival_chance": 0.5}
        }
    },
    "Nature's Embrace": {
        "pieces": ["Leaf Crown", "Eternal Bloom", "Vine Bracelet"],
        "bonuses": {
            2: {"health_regen": 10, "mana_regen": 5},
            3: {"health_regen": 20, "mana_regen": 10, "nature_control": True}
        }
    },

    # Weather Artifact Sets
    "Storm Chaser": {
        "pieces": ["Lightning Headpiece", "Thunder Pendant", "Cyclone Ring", "Storm Feather"],
        "bonuses": {
            2: {"lightning_damage": 0.15, "movement_speed": 0.1},
            3: {"lightning_damage": 0.25, "dodge_chance": 0.15},
            4: {"lightning_damage": 0.4, "weather_control": "Stormy", "special_ability": "Lightning Strike"}
        },
        "theme": "weather",
        "weather": "Stormy",
        "description": "Artifacts infused with the raw power of thunderstorms."
    },
    "Mist Walker": {
        "pieces": ["Ghostly Crown", "Shrouded Pendant", "Ethereal Clock", "Fog Essence"],
        "bonuses": {
            2: {"stealth": 0.2, "ghost_vision": True},
            3: {"critical_chance": 0.2, "phantom_step": True},
            4: {"stealth": 0.5, "weather_control": "Foggy", "special_ability": "Phantom Form"}
        },
        "theme": "weather",
        "weather": "Foggy",
        "description": "Artifacts that allow one to slip between the veil of mist and reality."
    },
    "Winter's Grasp": {
        "pieces": ["Frost Crown", "Blizzard Pendant", "Frozen Timepiece", "Ice Crystal"],
        "bonuses": {
            2: {"ice_damage": 0.15, "cold_resistance": 0.2},
            3: {"ice_damage": 0.3, "freeze_chance": 0.15},
            4: {"ice_damage": 0.4, "weather_control": "Snowy", "special_ability": "Freezing Aura"}
        },
        "theme": "weather",
        "weather": "Snowy",
        "description": "Artifacts that harness the biting cold of winter storms."
    },

    # Seasonal Artifact Sets
    "Spring Renewal": {
        "pieces": ["Blossom Crown", "Renewal Pendant", "Growth Timepiece", "Petal Essence"],
        "bonuses": {
            2: {"health_regen": 15, "nature_damage": 0.1},
            3: {"health_regen": 30, "growth_aura": True},
            4: {"health_regen": 50, "special_ability": "Rejuvenation", "season_bonus": "Spring"}
        },
        "theme": "seasonal",
        "season": "Spring",
        "description": "Artifacts that channel the rebirth and growth of springtime."
    },
    "Summer Solstice": {
        "pieces": ["Solar Crown", "Blazing Pendant", "Sundial", "Flame Feather"],
        "bonuses": {
            2: {"fire_damage": 0.15, "light_damage": 0.1},
            3: {"fire_damage": 0.25, "burn_chance": 0.2},
            4: {"fire_damage": 0.4, "special_ability": "Solar Flare", "season_bonus": "Summer"}
        },
        "theme": "seasonal",
        "season": "Summer",
        "description": "Artifacts that harness the intense heat and light of the summer sun."
    },
    "Autumn Harvest": {
        "pieces": ["Harvest Crown", "Amber Pendant", "Falling Leaf Clock", "Wheat Essence"],
        "bonuses": {
            2: {"earth_damage": 0.15, "resource_find": 0.2},
            3: {"earth_damage": 0.25, "abundance_aura": True},
            4: {"earth_damage": 0.4, "special_ability": "Cornucopia", "season_bonus": "Fall"}
        },
        "theme": "seasonal",
        "season": "Fall",
        "description": "Artifacts that embody the abundance and bounty of the harvest season."
    },
    "Winter Solstice": {
        "pieces": ["Frost Crown", "Crystal Pendant", "Frozen Clock", "Snow Essence"],
        "bonuses": {
            2: {"ice_damage": 0.15, "cold_resistance": 0.2},
            3: {"ice_damage": 0.25, "freeze_chance": 0.15},
            4: {"ice_damage": 0.4, "special_ability": "Blizzard", "season_bonus": "Winter"}
        },
        "theme": "seasonal",
        "season": "Winter",
        "description": "Artifacts that contain the quiet power and preservation of winter."
    },

    # Farming Artifact Sets
    "Bountiful Harvest": {
        "pieces": ["Farmer's Hat", "Soil Pendant", "Growth Clock", "Seed Pouch"],
        "bonuses": {
            2: {"farming_yield": 0.15, "growth_speed": 0.1},
            3: {"farming_yield": 0.25, "water_conservation": 0.2},
            4: {"farming_yield": 0.5, "special_ability": "Perfect Harvest"}
        },
        "theme": "farming",
        "description": "Artifacts that enhance one's connection to the soil and growing things."
    },
    "Weather Master": {
        "pieces": ["Cloud Crown", "Rain Pendant", "Sun Dial", "Wind Feather"],
        "bonuses": {
            2: {"weather_resistance": 0.2, "weather_sense": True},
            3: {"weather_resistance": 0.4, "weather_prediction": True},
            4: {"weather_resistance": 0.6, "special_ability": "Weather Shift"}
        },
        "theme": "farming",
        "description": "Artifacts that allow limited control over local weather patterns."
    }
}

# Enhanced crafting recipes with elemental weapons and artifacts
CRAFTING_RECIPES.update({
    # Weather and Season Related Items
    "Weather Amulet": {
        "materials": {"Weather Sample": 5, "Magic Crystal": 2, "Gold Ore": 3},
        "level_required": 10,
        "type": "accessory",
        "effect": 15,
        "special": "Grants a 20% chance to control weather once per day"
    },
    "Rainmaker Staff": {
        "materials": {"Weather Sample": 3, "Wood": 5, "Magic Crystal": 1, "Water Flask": 3},
        "level_required": 12,
        "type": "weapon",
        "effect": 12,
        "element": "Water",
        "special": "Can summon rain in dry areas"
    },
    "Seasonal Harvester": {
        "materials": {"Weather Sample": 2, "Steel Ingot": 3, "Magic Crystal": 1},
        "level_required": 8,
        "type": "tool",
        "special": "Increases harvest yield based on the current season"
    },
    "Farmer's Almanac": {
        "materials": {"Weather Sample": 1, "Paper": 10, "Magic Ink": 2},
        "level_required": 5,
        "type": "accessory",
        "special": "Shows optimal growing conditions for all crops"
    },
    "Weather Vane": {
        "materials": {"Iron Ore": 5, "Magic Crystal": 1},
        "level_required": 7,
        "type": "accessory",
        "special": "Predicts weather changes one day in advance"
    },
    "Storm Cloak": {
        "materials": {"Silk Thread": 10, "Magic Crystal": 2, "Weather Sample": 1},
        "level_required": 15,
        "type": "armor",
        "effect": 12,
        "element": "Lightning",
        "special": "Grants immunity to lightning damage"
    },
    "Fog Lantern": {
        "materials": {"Iron Ore": 2, "Glass": 3, "Magic Crystal": 1},
        "level_required": 10,
        "type": "accessory",
        "special": "Allows clear vision in fog and mist"
    },
    "Seasonal Boots": {
        "materials": {"Leather": 5, "Magic Crystal": 1, "Silk Thread": 3},
        "level_required": 12,
        "type": "armor",
        "effect": 8,
        "special": "Movement speed bonus changes with seasons"
    },
    "Weather Compass": {
        "materials": {"Iron Ore": 2, "Magic Crystal": 1, "Gold Ore": 1},
        "level_required": 6,
        "type": "accessory",
        "special": "Shows direction to nearest area with different weather"
    },
    "Cloudwalker Shoes": {
        "materials": {"Silk Thread": 8, "Magic Crystal": 2, "Weather Sample": 1},
        "level_required": 18,
        "type": "armor",
        "effect": 10,
        "special": "Reduces fall damage by 50%"
    },

    # Farming Equipment
    "Enhanced Hoe": {
        "materials": {"Iron Ore": 5, "Wood": 3, "Magic Crystal": 1},
        "level_required": 5,
        "type": "tool",
        "special": "Increases farming speed by 20%"
    },
    "Irrigation System": {
        "materials": {"Iron Ore": 8, "Clay": 5, "Glass": 2},
        "level_required": 8,
        "type": "tool",
        "special": "Automatically waters crops once per day"
    },
    "Scarecrow": {
        "materials": {"Wood": 5, "Cloth": 3, "Straw": 10},
        "level_required": 4,
        "type": "tool",
        "special": "Protects crops from birds and small pests"
    },
    "Greenhouse Glass": {
        "materials": {"Sand": 10, "Magic Crystal": 2, "Clay": 3},
        "level_required": 12,
        "type": "material",
        "special": "Used to build greenhouses for off-season farming"
    },
    "Crop Rotator": {
        "materials": {"Iron Ore": 3, "Magic Crystal": 1, "Gears": 5},
        "level_required": 15,
        "type": "tool",
        "special": "Automatically cycles crops to prevent soil depletion"
    },

    # Legendary Weapons
    "Void Blade": {
        "materials": {"Void Crystal": 3, "Dark Legion's Heart": 1, "Magic Crystal": 5},
        "level_required": 25,
        "type": "weapon",
        "effect": 60,
        "element": "Tenebrae"
    },
    "Dragon God Armor": {
        "materials": {"Divine Dragon Scale": 5, "Dragon God's Crown": 1, "Gold Ore": 10},
        "level_required": 30,
        "type": "armor",
        "effect": 50
    },
    "Phoenix Wings": {
        "materials": {"Eternal Flame": 3, "Phoenix Crown": 1, "Magic Crystal": 8},
        "level_required": 28,
        "type": "armor",
        "effect": 45
    },

    # Weather-based Equipment
    "Storm Caller": {
        "materials": {"Storm Crystal": 5, "Lightning Wyvern Scale": 2, "Magic Crystal": 3},
        "level_required": 20,
        "type": "weapon",
        "effect": 40,
        "element": "Fulmen",
        "special": "Increased damage during stormy weather",
        "weather_bonus": {"Stormy": 1.5}
    },
    "Mist Veil": {
        "materials": {"Mist Essence": 5, "Ghost Cloth": 3, "Ethereal Essence": 2},
        "level_required": 18,
        "type": "armor",
        "effect": 30,
        "element": "Pneuma",
        "special": "Partial invisibility during foggy weather",
        "weather_bonus": {"Foggy": 1.5}
    },
    "Frost Fang": {
        "materials": {"Frozen Heart": 2, "Ice Crystal": 5, "Wolf Fang": 3},
        "level_required": 22,
        "type": "weapon",
        "effect": 35,
        "element": "Glacies",
        "special": "Chance to freeze enemies during snowy weather",
        "weather_bonus": {"Snowy": 1.5}
    },
    "Solar Flare": {
        "materials": {"Radiant Core": 3, "Bright Crystal": 4, "Gold Ore": 5},
        "level_required": 21,
        "type": "weapon",
        "effect": 32,
        "element": "Lux",
        "special": "Burning effect during sunny weather",
        "weather_bonus": {"Sunny": 1.5}
    },
    "Windwalker Boots": {
        "materials": {"Razor Feather": 6, "Wind Crystal": 3, "Leather": 4},
        "level_required": 19,
        "type": "armor",
        "effect": 25,
        "element": "Aer",
        "special": "Increased movement speed during windy weather",
        "weather_bonus": {"Windy": 1.5}
    },
    "Earthen Shield": {
        "materials": {"Clay Core": 4, "Mud Stone": 3, "Iron Ore": 5},
        "level_required": 20,
        "type": "armor",
        "effect": 35,
        "element": "Gē",
        "special": "Increased defense during rainy weather",
        "weather_bonus": {"Rainy": 1.5}
    },
    "Skyweaver Staff": {
        "materials": {"Cloud Fragment": 5, "Sky Essence": 3, "Ancient Wood": 2},
        "level_required": 19,
        "type": "weapon",
        "effect": 30,
        "element": "Aer",
        "special": "Increased magic power during cloudy weather",
        "weather_bonus": {"Cloudy": 1.5}
    },

    # Seasonal Equipment
    "Winter's Embrace": {
        "materials": {"Frost Crown": 1, "Winter Essence": 5, "Silver Ore": 3},
        "level_required": 25,
        "type": "armor",
        "effect": 40,
        "element": "Glacies",
        "special": "Cold resistance and ice damage during winter",
        "season_bonus": {"Winter": 1.5}
    },
    "Spring Bloom Wand": {
        "materials": {"Petal Crown": 1, "Spring Essence": 5, "Living Wood": 3},
        "level_required": 24,
        "type": "weapon",
        "effect": 38,
        "element": "Viridia",
        "special": "Healing effect during spring",
        "season_bonus": {"Spring": 1.5}
    },
    "Summer Inferno": {
        "materials": {"Burning Scale": 2, "Summer Essence": 5, "Fire Crystal": 3},
        "level_required": 26,
        "type": "weapon",
        "effect": 42,
        "element": "Ignis",
        "special": "Burning aura during summer",
        "season_bonus": {"Summer": 1.5}
    },
    "Autumn Harvester": {
        "materials": {"Harvest Crown": 1, "Autumn Essence": 5, "Ancient Wood": 3},
        "level_required": 25,
        "type": "weapon",
        "effect": 40,
        "element": "Gē",
        "special": "Resource gathering bonus during fall",
        "season_bonus": {"Fall": 1.5}
    },

    # Farming Tools and Equipment
    "Enchanted Hoe": {
        "materials": {"Iron Ingot": 3, "Magic Crystal": 2, "Ancient Wood": 1},
        "level_required": 15,
        "type": "tool",
        "effect": 20,
        "special": "Increases farming yield by 20%"
    },
    "Seasonal Planter": {
        "materials": {"Spring Essence": 1, "Summer Essence": 1, "Autumn Essence": 1, "Winter Essence": 1, "Wood": 5},
        "level_required": 20,
        "type": "tool",
        "effect": 30,
        "special": "Allows growing crops regardless of season"
    },
    "Weather-Resistant Gloves": {
        "materials": {"Storm Crystal": 1, "Sunlight Fragment": 1, "Snow Flake": 1, "Leather": 3},
        "level_required": 18,
        "type": "armor",
        "effect": 15,
        "special": "Protects crops from adverse weather effects"
    },
    "Seed Pouch": {
        "materials": {"Leather": 5, "Cloth": 3, "Magic Crystal": 1},
        "level_required": 10,
        "type": "accessory",
        "effect": 10,
        "special": "Increases seed storage capacity"
    },

    # Artifact Crafting
    "Weather Attunement Crystal": {
        "materials": {"Storm Crystal": 1, "Sunlight Fragment": 1, "Ice Crystal": 1, "Wind Crystal": 1, "Rain Drop": 1},
        "level_required": 25,
        "type": "artifact_component",
        "effect": 0,
        "special": "Used to craft weather-attuned artifacts"
    },
    "Seasonal Essence Blend": {
        "materials": {"Spring Essence": 1, "Summer Essence": 1, "Autumn Essence": 1, "Winter Essence": 1},
        "level_required": 25,
        "type": "artifact_component",
        "effect": 0,
        "special": "Used to craft season-attuned artifacts"
    },

    # New Artifact Pieces
    "Lightning Headpiece": {
        "materials": {"Weather Attunement Crystal": 1, "Storm Crystal": 3, "Gold Ore": 5},
        "level_required": 30,
        "type": "artifact",
        "effect": 25,
        "special": "Part of the Storm Chaser artifact set",
        "slot": "Headset"
    },
    "Thunder Pendant": {
        "materials": {"Weather Attunement Crystal": 1, "Storm Crystal": 2, "Silver Ore": 5},
        "level_required": 30,
        "type": "artifact",
        "effect": 25,
        "special": "Part of the Storm Chaser artifact set",
        "slot": "Necklace"
    },
    "Cyclone Ring": {
        "materials": {"Weather Attunement Crystal": 1, "Wind Crystal": 3, "Gold Ore": 3},
        "level_required": 30,
        "type": "artifact",
        "effect": 25,
        "special": "Part of the Storm Chaser artifact set",
        "slot": "Ring"
    },
    "Storm Feather": {
        "materials": {"Weather Attunement Crystal": 1, "Razor Feather": 3, "Lightning Crystal": 2},
        "level_required": 30,
        "type": "artifact",
        "effect": 25,
        "special": "Part of the Storm Chaser artifact set",
        "slot": "Feather"
    },
    "Blossom Crown": {
        "materials": {"Seasonal Essence Blend": 1, "Spring Essence": 3, "Flower Petal": 5},
        "level_required": 30,
        "type": "artifact",
        "effect": 25,
        "special": "Part of the Spring Renewal artifact set",
        "slot": "Headset"
    },
    "Renewal Pendant": {
        "materials": {"Seasonal Essence Blend": 1, "Spring Essence": 2, "Silver Ore": 5},
        "level_required": 30,
        "type": "artifact",
        "effect": 25,
        "special": "Part of the Spring Renewal artifact set",
        "slot": "Necklace"
    },
    "Chaos Armor": {
        "materials": {"Chaos Crystal": 5, "Chaos Blade": 1, "Gold Ore": 15},
        "level_required": 35,
        "type": "armor",
        "effect": 55
    },
    "Legendary Sword": {
        "materials": {"Dragon Scale": 5, "Magic Crystal": 3, "Gold Ore": 2},
        "level_required": 20,
        "type": "weapon",
        "effect": 50,
        "element": "Ignis"
    },
    "Phoenix Armor": {
        "materials": {"Phoenix Feather": 3, "Magic Crystal": 2, "Gold Ore": 3},
        "level_required": 25,
        "type": "armor",
        "effect": 40
    },
    "Dragon Slayer Bow": {
        "materials": {"Dragon Scale": 3, "Magic Crystal": 2, "Wood": 4},
        "level_required": 22,
        "type": "weapon",
        "effect": 45,
        "element": "Aer"
    },

    # Elemental Weapons
    "Flame Sword": {
        "materials": {"Fire Crystal": 3, "Iron Ore": 5, "Wood": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Ignis"
    },
    "Frost Blade": {
        "materials": {"Ice Crystal": 3, "Iron Ore": 5, "Wood": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Glacies"
    },
    "Lightning Staff": {
        "materials": {"Thunder Crystal": 3, "Magic Wood": 5, "Crystal Shard": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Fulmen"
    },
    "Nature Scythe": {
        "materials": {"Plant Extract": 3, "Strong Wood": 5, "Silk": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Viridia"
    },
    "Earth Mace": {
        "materials": {"Earth Crystal": 3, "Iron Ore": 5, "Leather": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Gē"
    },
    "Wind Bow": {
        "materials": {"Wind Crystal": 3, "Flexible Wood": 5, "Silk": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Aer"
    },
    "Water Trident": {
        "materials": {"Water Essence": 3, "Iron Ore": 5, "Shell": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Aqua"
    },
    "Light Wand": {
        "materials": {"Light Crystal": 3, "Magic Wood": 5, "Gold Ore": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Lux"
    },
    "Shadow Dagger": {
        "materials": {"Shadow Essence": 3, "Dark Metal": 5, "Leather": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Tenebrae"
    },
    "Venomous Blade": {
        "materials": {"Poison Gland": 3, "Iron Ore": 5, "Leather": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Venēnum"
    },
    "Steel Hammer": {
        "materials": {"Steel Ingot": 3, "Iron Ore": 5, "Wood": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Ferrum"
    },
    "Spirit Blade": {
        "materials": {"Soul Fragment": 3, "Magic Crystal": 5, "Pure Metal": 2},
        "level_required": 15,
        "type": "weapon",
        "effect": 35,
        "element": "Pneuma"
    },

    # Artifacts
    "Crown of Wisdom": {
        "materials": {"Magic Crystal": 2, "Gold Ore": 3, "Pure Gem": 1},
        "level_required": 10,
        "type": "artifact",
        "slot": "Headset",
        "effect": {"intelligence": 10},
        "rarity": "Rare"
    },
    "Ember Pendant": {
        "materials": {"Fire Crystal": 2, "Silver Ore": 3, "Red Gem": 1},
        "level_required": 10,
        "type": "artifact",
        "slot": "Necklace",
        "effect": {"fire_resist": 0.15},
        "rarity": "Uncommon"
    },
    "Timekeeper's Watch": {
        "materials": {"Magic Gear": 2, "Gold Ore": 3, "Time Crystal": 1},
        "level_required": 15,
        "type": "artifact",
        "slot": "Clock",
        "effect": {"cooldown_reduction": 0.1},
        "rarity": "Rare"
    },
    "Eternal Bloom": {
        "materials": {"Plant Extract": 2, "Water Essence": 3, "Life Crystal": 1},
        "level_required": 15,
        "type": "artifact",
        "slot": "Flower",
        "effect": {"health_regen": 5},
        "rarity": "Uncommon"
    },
    "Phoenix Plume": {
        "materials": {"Phoenix Feather": 1, "Magic Crystal": 2, "Fire Crystal": 3},
        "level_required": 20,
        "type": "artifact",
        "slot": "Feather",
        "effect": {"revival_chance": 0.2},
        "rarity": "Epic"
    },
    "Band of Power": {
        "materials": {"Magic Metal": 2, "Strength Crystal": 3, "Blue Gem": 1},
        "level_required": 10,
        "type": "artifact",
        "slot": "Ring",
        "effect": {"attack": 8},
        "rarity": "Uncommon"
    }
})

# Add more elemental crafting recipes
CRAFTING_RECIPES.update({
    # Elemental Weapons
    "Flame Sword": {
        "materials": {"Iron Ore": 3, "Magic Crystal": 2, "Fire Essence": 1},
        "level_required": 10,
        "type": "weapon",
        "effect": 15,
        "element": "Fire",
        "special": "Has a 15% chance to inflict Burn status"
    },
    "Frost Axe": {
        "materials": {"Iron Ore": 4, "Magic Crystal": 2, "Water Flask": 2},
        "level_required": 12,
        "type": "weapon",
        "effect": 17,
        "element": "Ice",
        "special": "Has a 15% chance to inflict Freeze status"
    },
    "Thunder Bow": {
        "materials": {"Wood": 5, "Silk Thread": 3, "Magic Crystal": 2},
        "level_required": 14,
        "type": "weapon",
        "effect": 16,
        "element": "Lightning",
        "special": "Has a 15% chance to stun enemies"
    },
    "Earthen Mace": {
        "materials": {"Iron Ore": 5, "Stone": 10, "Magic Crystal": 1},
        "level_required": 10,
        "type": "weapon",
        "effect": 18,
        "element": "Earth",
        "special": "Has a 20% chance to add extra crushing damage"
    },
    "Wind Dagger": {
        "materials": {"Iron Ore": 2, "Silk Thread": 5, "Magic Crystal": 2},
        "level_required": 11,
        "type": "weapon",
        "effect": 12,
        "element": "Wind",
        "special": "Doubles critical hit chance"
    },

    # Elemental Armor
    "Flame-Forged Breastplate": {
        "materials": {"Iron Ore": 8, "Magic Crystal": 3, "Fire Essence": 2},
        "level_required": 15,
        "type": "armor",
        "effect": 20,
        "element": "Fire",
        "special": "Reduces Fire damage by 30%"
    },
    "Frost Mantle": {
        "materials": {"Silk Thread": 10, "Magic Crystal": 3, "Water Flask": 3},
        "level_required": 15,
        "type": "armor",
        "effect": 18,
        "element": "Ice",
        "special": "Reduces Ice damage by 30%"
    },
    "Thunder Plate": {
        "materials": {"Iron Ore": 8, "Magic Crystal": 3, "Weather Sample": 2},
        "level_required": 15,
        "type": "armor",
        "effect": 19,
        "element": "Lightning",
        "special": "Reduces Lightning damage by 30%"
    },
    "Stone Skin Armor": {
        "materials": {"Iron Ore": 6, "Stone": 12, "Magic Crystal": 3},
        "level_required": 15,
        "type": "armor",
        "effect": 22,
        "element": "Earth",
        "special": "Reduces Earth damage by 30%"
    },
    "Windrider Vest": {
        "materials": {"Leather": 8, "Silk Thread": 6, "Magic Crystal": 3},
        "level_required": 15,
        "type": "armor",
        "effect": 16,
        "element": "Wind",
        "special": "Reduces Wind damage by 30% and increases movement speed by 10%"
    },

    # Advanced Farming Tools
    "Weather-Sensitive Plow": {
        "materials": {"Iron Ore": 8, "Wood": 5, "Weather Sample": 2, "Magic Crystal": 1},
        "level_required": 12,
        "type": "tool",
        "special": "Adapts to current weather to optimize tilling"
    },
    "Season Cycler": {
        "materials": {"Magic Crystal": 3, "Gold Ore": 2, "Weather Sample": 1},
        "level_required": 18,
        "type": "tool",
        "special": "Can grow any seasonal crop regardless of current season"
    },
    "Crop Enhancer": {
        "materials": {"Magic Crystal": 2, "Red Herb": 5, "Blue Herb": 5, "Green Herb": 5},
        "level_required": 10,
        "type": "tool",
        "special": "Improves crop quality by one tier"
    }
})

dungeons = [
    # Greenwood Village Dungeons
    {"name": "Goblin's Hideout", "monsters": ["Goblin", "Wolf"], "loot": ["Wooden Sword", "Wolf Pelt", "Gold Coin"]},
    {"name": "Bandit Camp", "monsters": ["Bandit"], "loot": ["Leather Armor", "Gold Coin"]},
    {"name": "Forest Spider Den", "monsters": ["Forest Spider"], "loot": ["Spider Silk", "Gold Coin"]},
    {"name": "Ancient Ruins", "monsters": ["Forest Spider", "Goblin"], "loot": ["Ancient Relic", "Gold Coin"]},
    {"name": "Goblin Fortress", "monsters": ["Goblin", "Dire Wolf"], "loot": ["Goblin Staff", "Gold Coin"]},
    {"name": "Cave of Shadows", "monsters": ["Goblin Shaman"], "loot": ["Gold Coin", "Goblin Staff"]},
    {"name": "Goblin King's castle", "monsters": ["Goblin King"], "loot": ["Goblin King's Crown", "Gold Coin"]},

    # Stormhaven Dungeons
    {"name": "Haunted Crypt", "monsters": ["Skeleton", "Ghost"], "loot": ["Bone Armor", "Spirit Essence", "Gold Coin"]},
    {"name": "Pirate's Cove", "monsters": ["Pirate Scout"], "loot": ["Cutlass", "Gold Coin"]},
    {"name": "Storm Fortress", "monsters": ["Storm Elemental"], "loot": ["Storm Crystal", "Gold Coin"]},
    {"name": "Cursed Shipwreck", "monsters": ["Haunted Armor"], "loot": ["Cursed Shield", "Gold Coin"]},
    {"name": "Ghost Ship", "monsters": ["Sea Serpent"], "loot": ["Serpent Scale", "Gold Coin"]},
    {"name": "Dreadlord's Sunken Ship", "monsters": ["Dreadlord Varkhull, the Crimson Abyss Pirate Captain"], "loot": ["Crimson Cutlass", "Gold Coin"]},
    {"name": "Cursed Lighthouse", "monsters": ["Haunted Armor", "Ghost"], "loot": ["Cursed Shield", "Gold Coin"]},
    {"name": "Cursed Graveyard", "monsters": ["Skeleton", "Ghost"], "loot": ["Bone Armor", "Spirit Essence", "Gold Coin"]},

    # Dragon's Peak Dungeons
    {"name": "Fire Dragon's Lair", "monsters": ["Fire Dragon"], "loot": ["Dragon Scale", "Flame Sword", "Gold Coin"]},
    {"name": "Ice Dragon's Nest", "monsters": ["Ice Dragon"], "loot": ["Dragon Scale", "Ice Sword", "Gold Coin"]},
    {"name": "Electrical Dragon's Roost", "monsters": ["Electrical Dragon"], "loot": ["Dragon Scale", "Lightning Sword", "Gold Coin"]},
    {"name": "Plant Dragon's Grove", "monsters": ["Plant Dragon"], "loot": ["Dragon Scale", "Nature Sword", "Gold Coin"]},
    {"name": "Earth Dragon's Cavern", "monsters": ["Earth Dragon"], "loot": ["Dragon Scale", "Earth Sword", "Gold Coin"]},
    {"name": "Wind Dragon's Summit", "monsters": ["Wind Dragon"], "loot": ["Dragon Scale", "Wind Sword", "Gold Coin"]},
    {"name": "Water Dragon's Abyss", "monsters": ["Water Dragon"], "loot": ["Dragon Scale", "Water Sword", "Gold Coin"]},
    {"name": "Fire Wyvern Nest", "monsters": ["Fire Wyvern"], "loot": ["Wyvern Scale", "Gold Coin"]},
    {"name": "Ice Wyvern Cave", "monsters": ["Ice Wyvern"], "loot": ["Wyvern Scale", "Gold Coin"]},
    {"name": "Thunder Wyvern Peak", "monsters": ["Thunder Wyvern"], "loot": ["Wyvern Scale", "Gold Coin"]},
    {"name": "Earth Wyvern Den", "monsters": ["Earth Wyvern"], "loot": ["Wyvern Scale", "Gold Coin"]},
    {"name": "Dragon Knight's Fortress", "monsters": ["Dragon Knight"], "loot": ["Dragon Armor", "Gold Coin"]},
    {"name": "Water Wyvern Lagoon", "monsters": ["Water Wyvern"], "loot": ["Wyvern Wing", "Gold Coin"]},
    {"name": "Dragon Overlord's Lair", "monsters": ["Dragon Overlord"], "loot": ["Dragon Scale", "Dragonfire Sword", "Gold Coin"]},

    # Crystal Cave Dungeons
    {"name": "Crystal Depths", "monsters": ["Crystal Golem", "Cave Troll"], "loot": ["Crystal Shard", "Troll Hide", "Gold Coin"]},
    {"name": "Cave of Echoes", "monsters": ["Crystal Spider", "Rock Elemental"], "loot": ["Crystal Web", "Earth Stone", "Gold Coin"]},
    {"name": "Crystal Cavern", "monsters": ["Cave Bat", "Crystal Tarantula"], "loot": ["Bat Wing", "Crystal Fang", "Gold Coin"]},
    {"name": "Crystal Golem's Lair", "monsters": ["Crystal Giant Tarantula"], "loot": ["Crystal Eye", "Gold Coin"]},
    {"name": "Serpent's Lair", "monsters": ["Crystal Serpent"], "loot": ["Serpent Scale", "Gold Coin"]},
    {"name": "Corrupted Miner's Hideout", "monsters": ["Corrupted Miner"], "loot": ["Miner's Pickaxe", "Gold Coin"]},
    {"name": "Crystal Cavern", "monsters": ["Crystal Golem", "Cave Troll"], "loot": ["Crystal Shard", "Troll Hide", "Gold Coin"]},

    # Shadowmere Dungeons
    {"name": "Shadow Keep", "monsters": ["Shadow Beast", "Dark Knight"], "loot": ["Shadow Essence", "Dark Armor", "Gold Coin"]},
    {"name": "Wraith's Lair", "monsters": ["Wraith"], "loot": ["Soul Gem", "Gold Coin"]},
    {"name": "Night Stalker Den", "monsters": ["Night Stalker"], "loot": ["Night Blade", "Gold Coin"]},
    {"name": "Assassin's Hideout", "monsters": ["Shadow Assassin"], "loot": ["Assassin's Dagger", "Gold Coin"]},
    {"name": "Dark Fortress", "monsters": ["Dark Knight"], "loot": ["Dark Armor", "Gold Coin"]},
    {"name": "Vampire's Crypt", "monsters": ["Vampire"], "loot": ["Vampire Fang", "Gold Coin"]},
    {"name": "Undead Fortress", "monsters": ["Undead Knight"], "loot": ["Undead Blade", "Gold Coin"]},
    {"name": "Undead Army Base", "monsters": ["Undead Army General","Undead Army Commander"], "loot": ["Undead Armor", "Gold Coin"]},

    # Frostvale Dungeons
    {"name": "Frozen Halls", "monsters": ["Ice Troll", "Frost Giant"], "loot": ["Frozen Heart", "Giant's Club", "Gold Coin"]},
    {"name": "Snowy Cavern", "monsters": ["Snow Wolf", "Ice Elemental"], "loot": ["Frost Pelt", "Ice Crystal", "Gold Coin"]},
    {"name": "Frost Wraith's Lair", "monsters": ["Frost Wraith"], "loot": ["Wraith Essence", "Gold Coin"]},
    {"name": "Troll's Den", "monsters": ["Ice Troll"], "loot": ["Frozen Heart", "Gold Coin"]},
    {"name": "Frost Revenant", "monsters": ["Ice Revenant"], "loot": ["Frozen Heart", "Gold Coin"]},
    {"name": "Frozen Eye Cave", "monsters": ["Frost vengeful eye of the snow"], "loot": ["Frost Eye", "Gold Coin"]},

    # Silent Ashes Dungeons
    {"name": "Ash Ruins", "monsters": ["Ash Revenant", "Cursed Wanderer"], "loot": ["Ancient Relic", "Cursed Gem", "Gold Coin"]},
    {"name": "Phoenix Nest", "monsters": ["Phoenix"], "loot": ["Phoenix Feather", "Gold Coin"]},
    {"name": "Ash Wraith's Den", "monsters": ["Ash Wraith"], "loot": ["Wraith Essence", "Gold Coin"]},
    {"name": "Guardian's Ash Fortress", "monsters": ["Burnt Guardian"], "loot": ["Guardian's Ash", "Gold Coin"]},
    {"name": "Magmatic Knight's Lair", "monsters": ["Magmatic Knight,The fallen knight of the ashes"], "loot": ["Knight's Ash", "Gold Coin"]},
    {"name": "Vision of the Thunder Cave", "monsters": ["Vision of the Thunder,the core of the storm"], "loot": ["Storm Eye", "Gold Coin"]},

    # Long Shui Zhen Dungeons
    {"name": "Water Palace", "monsters": ["Water Elemental", "Jade Warrior"], "loot": ["Water Essence", "Jade Sword", "Gold Coin"]},
    {"name": "Dragon Temple", "monsters": ["Dragon Spirit"], "loot": ["Spirit Pearl", "Gold Coin"]},
    {"name": "Jade General's Fortress", "monsters": ["Jade General","Jade Soldier"], "loot": ["Jade Armor", "Gold Coin"]},
    {"name": "Jade Emperor's Chamber", "monsters": ["Jade Emperor", "Jade Emperor's Guard"], "loot": ["Jade Crown", "Gold Coin"]},
    {"name": "Long Shui Zhen's well", "monsters": ["Legendary Dragon"], "loot": ["Dragon Scale", "Legendary Sword"]},

    # Jade Lotus Village Dungeons
    {"name": "Lotus Sanctuary", "monsters": ["Lotus Spirit", "Pond Serpent"], "loot": ["Lotus Petal", "Serpent Scale", "Gold Coin"]},
    {"name": "Garden of Spirits", "monsters": ["Garden Guardian"], "loot": ["Sacred Charm", "Gold Coin"]},
    {"name": "Lotus Shrine", "monsters": ["Lotus Guardian"], "loot": ["Lotus Shield", "Gold Coin"]},
    {"name": "Koi Pond", "monsters": ["Koi Empress"], "loot": ["Koi Scale", "Gold Coin"]},

    # Thundercliff Hold Dungeons
    {"name": "Storm Fortress", "monsters": ["Thunder Elemental", "Rock Wyvern"], "loot": ["Storm Crystal", "Wyvern Scale", "Gold Coin"]},
    {"name": "Thunder Mage's Tower", "monsters": ["Thunder Mage"], "loot": ["Thunder Staff", "Gold Coin"]},
    {"name": "Storm Wyvern Nest", "monsters": ["Storm Wyvern"], "loot": ["Wyvern Wing", "Gold Coin"]},
    {"name": "Storm Guardian's Keep", "monsters": ["Storm Guardian"], "loot": ["Guardian's Storm", "Gold Coin"]},

    # Ember Hollow Dungeons
    {"name": "Lava Cavern", "monsters": ["Lava Hound", "Molten Wraith"], "loot": ["Lava Stone", "Gold Coin"]},
    {"name": "Ember Fortress", "monsters": ["Fire Elemental"], "loot": ["Ember Crystal", "Gold Coin"]},
    {"name": "Ashen Ruins", "monsters": ["Ash Elemental"], "loot": ["Ashen Gem", "Gold Coin"]},
    {"name": "Fire Wyvern Nest", "monsters": ["Fire Wyvern"], "loot": ["Wyvern Scale", "Gold Coin"]},
    {"name": "Ember Dragon's Lair", "monsters": ["Ember Dragon"], "loot": ["Dragon Scale", "Gold Coin"]},

    # Shogunate Of Shirui Dungeons
    {"name": "Shogun's Fortress", "monsters": ["The Shogun", "Shogun's Guard"], "loot": ["Samurai Armor", "Shogun's Blade", "Gold Coin"]},
    {"name": "Kitsune Shrine", "monsters": ["Kitsune Warrior"], "loot": ["Kitsune Mask", "Gold Coin"]},
    {"name": "Jade Temple", "monsters": ["Jade Samurai"], "loot": ["Jade Armor", "Gold Coin"]},
    {"name": "Tengu's Nest", "monsters": ["Tengu Warrior"], "loot": ["Tengu Feather", "Gold Coin"]},
    {"name": "Kappa's Cave", "monsters": ["Kappa Guardian"], "loot": ["Kappa Shell", "Gold Coin"]},
    {"name": "Oni's Lair", "monsters": ["Oni Berserker"], "loot": ["Oni Mask", "Gold Coin"]},
    {"name": "Corrupted Ninja's Hideout", "monsters": ["Corrupted Ninja"], "loot": ["Ninja Star", "Gold Coin"]},
    {"name": "Shadow Samurai's Fortress", "monsters": ["Shadow Samurai"], "loot": ["Shadow Blade", "Gold Coin"]},
    {"name": "Possessed Katana's Lair", "monsters": ["Possessed Katana"], "loot": ["Cursed Katana", "Gold Coin"]},

    # The Iron Caliphate of Al-Khilafah Al-Hadidiyah Dungeons
    {"name": "Caliph's Palace", "monsters": ["Az-Zālim al-Muqaddas,The Caliph of Al-Khilafah Al-Hadidiyah"], "loot": ["Iron Caliph's Crown", "Gold Coin"]},
    {"name": "Guardian's Keep", "monsters": ["Al-Hadidiyah Guardian"], "loot": ["Guardian's Blade", "Gold Coin"]},
    {"name": "Knight's Barracks", "monsters": ["Al-Hadidiyah Knight"], "loot": ["Knight's Shield", "Gold Coin"]},
    {"name": "Mercenary Camp", "monsters": ["Mercenary of the caliphate"], "loot": ["Mercenary's Dagger", "Gold Coin"]},
    {"name": "Loyalist's mosque", "monsters": ["Loyalist of the caliphate", "High Priest of the caliphate"], "loot": ["Loyalist's Blade", "High Priest's Staff", "Gold Coin"]},
    {"name": "Sorcerer's Tower", "monsters": ["Al-Hadidiyah Sorcerer"], "loot": ["Sorcerer's Tome", "Gold Coin"]},
    {"name": "Factory of golems", "monsters": ["Steel Golem"], "loot": ["Steel Core", "Gold Coin"]},
    {"name": "Janissary Barracks", "monsters": ["Royal Janissary"], "loot": ["Janissary's Blade", "Gold Coin"]},
    {"name": "General's Fortress", "monsters": ["Iron Caliphate General", "Al-Hadidiyah Knight","Mercenary of the caliphate"], "loot": ["General's Armor", "Gold Coin"]},

    # Tlācahcāyōtl Tletl Tecpanēcatl/Empire of the Sacred Fire and Chains Dungeons
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Palace", "monsters": ["Tēcpatl Tlamacazqui,The Emperor of the Sacred Fire and Chains", "Secret Police from The Order of the Black Sun (Yohualli Tōnatiuh)","Tlācahcāyōtl Tletl Tecpanēcatl Knight"], "loot": ["Emperor's Crown", "Black Sun Dagger", "Knight's Shield", "Gold Coin"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Guardian's Keep", "monsters": ["Tlācahcāyōtl Tletl Tecpanēcatl Guardian"], "loot": ["Guardian's Blade", "Gold Coin"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Sorcerer's Tower", "monsters": ["Tlācahcāyōtl Tletl Tecpanēcatl Sorcerer"], "loot": ["Sorcerer's Tome", "Gold Coin"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl High Priest's Sanctuary", "monsters": ["Tlācahcāyōtl Tletl Tecpanēcatl High Priest"], "loot": ["High Priest's Staff", "Gold Coin"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Mercenary Camp", "monsters": ["Tlācahcāyōtl Tletl Tecpanēcatl Mercenary"], "loot": ["Mercenary's Dagger", "Gold Coin"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Loyalist Town", "monsters": ["Tlācahcāyōtl Tletl Tecpanēcatl Loyalist"], "loot": ["Loyalist's Blade", "Gold Coin"]},
    {"name": "Tlācahcāyōtl Tletl Tecpanēcatl Royal Guard's Fortress", "monsters": ["Tlācahcāyōtl Tletl Tecpanēcatl Royal Guard"], "loot": ["Royal Guard's Sword", "Gold Coin"]},

    # Crimson Abyss Dungeons
    {"name": "Crimson Abyss Fortress", "monsters": ["Crimson Abyss Demon", "Crimson Abyss Knight"], "loot": ["Demon's Heart", "Knight's Blade", "Gold Coin"]},
    {"name": "Crimson Abyss Sorcerer's Tower", "monsters": ["Crimson Abyss Sorcerer"], "loot": ["Sorcerer's Staff", "Gold Coin"]},
    {"name": "Crimson Abyss Guardian's Keep", "monsters": ["Crimson Abyss Guardian"], "loot": ["Guardian's Shield", "Gold Coin"]},
    {"name": "Abyssal Leviathan's Sunken Palace", "monsters": ["Abyssal Leviathan"], "loot": ["Leviathan Scale", "Gold Coin"]},

    # The Dark Legion Dungeons
    {"name": "Dark Legion Fortress", "monsters": ["Dark Legion Elite", "Dark Legion Warlock"], "loot": ["Dark Legion Armor", "Warlock Staff", "Gold Coin"]},
    {"name": "Dark Legion Citadel", "monsters": ["Dark Legion Elite", "Dark Legion Commander"], "loot": ["Dark Legion Armor", "Commander's Blade", "Gold Coin"]},
    {"name": "Warlock's Dark Spire", "monsters": ["Dark Legion Warlock", "Dark Legion Archpriest"], "loot": ["Warlock Staff", "Dark Tome", "Gold Coin"]},
    {"name": "Shadow Assassin's Den", "monsters": ["Dark Legion's Shadow Assassin"], "loot": ["Shadow Dagger", "Gold Coin"]},
    {"name": "The Eternal Throne", "monsters": ["Dark Legionary Supreme Lord:Noctis, the Obsidian Fallen Eternal"], "loot": ["Eternal Crown", "Obsidian Blade", "Dark Legion's Heart", "Gold Coin"]},

    # Post-game Dungeons
    {"name": "The Void Citadel", "monsters": ["Void Reaper", "Dark Legion Elite"], "loot": ["Void Scythe", "Void Crystal", "Void Armor"], "description": "A fortress suspended in the void between dimensions."},
    {"name": "Dragon God's Sanctuary", "monsters": ["Ancient Dragon God", "Dragon Elite Guard"], "loot": ["Divine Dragon Scale", "Dragon God's Crown", "Divine Armor"], "description": "The sacred realm where the first dragons originated."},
    {"name": "Eternal Phoenix Spire", "monsters": ["Eternal Phoenix", "Phoenix Guardian"], "loot": ["Eternal Flame", "Phoenix Crown", "Phoenix Wings"], "description": "A towering spire of eternal flame where the first phoenix was born."},
    {"name": "Chaos Nexus", "monsters": ["Chaos Incarnate", "Chaos Spawn"], "loot": ["Chaos Blade", "Chaos Crystal", "Chaos Armor"], "description": "The epicenter of all chaos in the universe."},
    {"name": "The Infinite Abyss", "monsters": ["Abyssal Overlord", "Abyss Dweller"], "loot": ["Abyssal Crown", "Infinity Stone", "Abyssal Armor"], "description": "An endless void where reality itself begins to break."},

    # New Elemental Lords dungeons
    {"name": "Blazing Crucible", "monsters": ["Ignis, Lord of Flames", "Phoenix Guardian"], "loot": ["Heart of Fire", "Blazing Crown", "Phoenix Feather"], "description": "A realm of perpetual fire where even the air itself burns with intense heat.", "min_level": 35, "area_type": "postgame"},
    {"name": "Frozen Eternity", "monsters": ["Glacies, Frost Sovereign", "Winter Wolf"], "loot": ["Core of Ice", "Frozen Crown", "Frost Crystal"], "description": "A magnificent ice palace where time stands still in an eternal winter.", "min_level": 35, "area_type": "postgame"},
    {"name": "Thunder Peaks", "monsters": ["Fulmen, Storm Emperor", "Lightning Elemental"], "loot": ["Lightning Heart", "Storm Crown", "Charged Crystal"], "description": "The highest mountain peaks where eternal storms rage and lightning never ceases.", "min_level": 35, "area_type": "postgame"},
    {"name": "Tectonic Depths", "monsters": ["Terra, Earth Colossus", "Stone Golem"], "loot": ["Earth Core", "Mountain Crown", "Ancient Fossil"], "description": "Deep underground caverns where the very earth shifts and breathes.", "min_level": 35, "area_type": "postgame"},
    {"name": "Abyssal Trench", "monsters": ["Aquarius, Tide Master", "Abyssal Leviathan"], "loot": ["Ocean Heart", "Coral Crown", "Leviathan Scale"], "description": "The deepest ocean trenches where pressure crushes all but the mightiest beings.", "min_level": 35, "area_type": "postgame"},

    # Four Horsemen challenge dungeons
    {"name": "Fields of Conquest", "monsters": ["Conquest, The White Rider", "Celestial Warrior"], "loot": ["White Bow", "Victor's Crown", "Celestial Armor"], "description": "A battlefield where victory is always just out of reach.", "min_level": 50, "area_type": "endgame"},
    {"name": "War's Domain", "monsters": ["War, The Red Rider", "Blood Knight"], "loot": ["Bloodthirsty Blade", "Warlord's Crown", "Blood-Stained Armor"], "description": "A realm where conflict never ends and peace is unknown.", "min_level": 52, "area_type": "endgame"},
    {"name": "Barren Wastelands", "monsters": ["Famine, The Black Rider", "Withered Guardian"], "loot": ["Scales of Balance", "Crown of Hunger", "Life Essence"], "description": "A desolate landscape where nothing grows and hunger is eternal.", "min_level": 54, "area_type": "endgame"},
    {"name": "Death's Dominion", "monsters": ["Death, The Pale Rider", "Reaper's Assistant"], "loot": ["Soul Scythe", "Pale Crown", "Final Judgment"], "description": "The final resting place for all mortal souls.", "min_level": 58, "area_type": "endgame"},

    # Special challenge dungeons
    {"name": "The Void Between Worlds", "monsters": ["Void Dragon", "Dimensional Horror"], "loot": ["Void Dragon Scale", "Void Crown", "Horror Essence"], "description": "A place that exists between realities, where the laws of physics break down.", "min_level": 45, "area_type": "dimensional"},
    {"name": "Chronos Sanctum", "monsters": ["Time Keeper", "Temporal Guardian"], "loot": ["Chronos Crystal", "Time Keeper's Staff", "Paradox Shard"], "description": "A sanctuary where past, present, and future converge into one.", "min_level": 42, "area_type": "dimensional"},
    {"name": "Astral Nexus", "monsters": ["Celestial Titan", "Astral Entity"], "loot": ["Celestial Heart", "Titan's Crown", "Star Fragment"], "description": "The convergence point of all celestial bodies and cosmic energies.", "min_level": 46, "area_type": "dimensional"}
]


# Note: All color constants are defined at the top of the file using colorama for cross-platform compatibility

def print_colored(text: str, color_code: str = "", end: str = "\n") -> None:
    """
    Print text with color formatting.

    Args:
        text: The text to print
        color_code: Optional color code from colorama
        end: String appended after the last character, default a newline
    """
    # Reset any previous colors
    sys.stdout.write("\033[0m")
    sys.stdout.flush()

    # If text already contains color codes, extract them
    if ENDC in text and not color_code:
        extracted_color, clean_text = extract_color_and_text(text)
        if extracted_color:
            color_code = extracted_color
            text = clean_text

    # Print with explicit color control for more consistent display
    if color_code:
        sys.stdout.write(f"{color_code}{text}{ENDC}")
    else:
        sys.stdout.write(text)

    sys.stdout.write(end)
    sys.stdout.flush()

def extract_color_and_text(text: str) -> Tuple[str, str]:
    """
    Extract color codes and clean text from a string that might contain ANSI color codes.

    Args:
        text: Text with potential color codes

    Returns:
        Tuple of (extracted_color_code, clean_text)
    """
    if ENDC not in text:
        return "", text

    # Check for common color patterns
    all_colors = [
        OKBLUE, OKGREEN, WARNING, FAIL, BOLD, LIGHTGRAY, LIGHTCYAN, MAGENTA, 
        UNDERLINE, SUCCESS, HEADER, CYAN, YELLOW, RED, GREEN, BLUE, WHITE, 
        BLACK, GREY, DARKGRAY, PURPLE, LIGHTYELLOW, LIGHTRED, LIGHTGREEN, 
        LIGHTBLUE, LIGHTMAGENTA, BG_BLACK, BG_RED, BG_GREEN, BG_YELLOW, 
        BG_BLUE, BG_MAGENTA, BG_CYAN, BG_WHITE
    ]

    # Search for color codes at the beginning of the text
    found_color = ""
    clean_text = text

    # Handle BOLD + COLOR combinations first
    for color in all_colors:
        if BOLD + color in text:
            found_color = BOLD + color
            clean_text = text.replace(found_color, "").replace(ENDC, "")
            return found_color, clean_text

    # Handle single color codes
    for color in all_colors:
        if color in text:
            found_color = color
            clean_text = text.replace(found_color, "").replace(ENDC, "")
            return found_color, clean_text

    # If no specific color found but ENDC exists, just strip it
    return "", text.replace(ENDC, "")

def print_animated(text: str, color_code: str = "", delay: Optional[float] = None) -> None:
    """
    Print text character by character with an animation effect.

    Args:
        text: The text to print
        color_code: Optional color code from colorama
        delay: Time delay between characters (or None for auto-calculation)
    """
    # If text contains color codes, extract them
    if ENDC in text:
        extracted_color, clean_text = extract_color_and_text(text)
        if extracted_color:
            color_code = extracted_color
            text = clean_text

    # Ensure colors are displayed properly in all environments
    if color_code:
        # Some environments need this explicit reset
        sys.stdout.write("\033[0m")  # Reset any previous color
        sys.stdout.flush()

    # Calculate appropriate delay based on text length
    length = len(text)
    actual_delay = 0.01  # Default delay
    if delay is not None:
        actual_delay = delay
    else:
        actual_delay = max(0.005, min(0.03, 1.0 / (length * 10)))

    # Print with proper color handling
    if color_code:
        sys.stdout.write(color_code)
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(actual_delay)
    if color_code:
        sys.stdout.write(ENDC)
    sys.stdout.write("\n")
    sys.stdout.flush()

# Function to display headers with color
def print_header(title: str) -> None:
    print("\n" + "=" * 40)
    print(f"{BOLD}{MAGENTA}{title}{ENDC}")
    print("=" * 40)

# Show the help menu
def archaeology() -> None:
    """Main function for the archaeology system - handles excavation, analysis, and museums"""
    global user_data

    # Initialize archaeology data if it doesn't exist
    if "archaeology" not in user_data:
        user_data["archaeology"] = {
            "discovered_sites": [],
            "excavated_artifacts": [],
            "knowledge": [],
            "tools": ["Basic Trowel"],
            "museum_exhibits": [],
            "excavation_skill": 1,
            "analysis_skill": 1
        }

    print_header("Archaeology")
    print_colored("Explore ancient ruins, recover artifacts, and gain knowledge of lost civilizations.", CYAN)
    print()

    # Main archaeology menu
    print_colored("1. View Discovered Sites", YELLOW)
    print_colored("2. Excavate at Current Location", YELLOW)
    print_colored("3. Analyze Artifacts", YELLOW)
    print_colored("4. View Your Museum", YELLOW)
    print_colored("5. View Ancient Knowledge", YELLOW)
    print_colored("6. Purchase Excavation Tools", YELLOW)
    print_colored("7. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-7): {ENDC}"))

        if choice == 1:
            view_archaeological_sites()
        elif choice == 2:
            excavate_site()
        elif choice == 3:
            analyze_artifacts()
        elif choice == 4:
            view_museum()
        elif choice == 5:
            view_ancient_knowledge()
        elif choice == 6:
            purchase_excavation_tools()
        elif choice == 7:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    # Return to archaeology menu after completing action
    archaeology()

def wait_for_input() -> None:
    """Wait for user to press Enter to continue"""
    input(f"\n{YELLOW}Press Enter to continue...{ENDC}")

def unlock_achievement(name: str, description: str, condition: str) -> None:
    """Unlock an achievement for the player"""
    if "achievements" not in user_data:
        user_data["achievements"] = {
            "unlocked": [],
            "progress": {}
        }

    # Create achievement ID from name
    achievement_id = name.lower().replace(" ", "_")

    # Check if already unlocked
    if achievement_id in user_data["achievements"]["unlocked"]:
        return

    # Add to unlocked achievements
    user_data["achievements"]["unlocked"].append(achievement_id)

    # Display achievement unlocked message
    print_colored("\n╔══════════════════════════════════╗", YELLOW)
    print_colored("║         ACHIEVEMENT UNLOCKED      ║", YELLOW)
    print_colored("╚══════════════════════════════════╝", YELLOW)
    print_colored(f"{CYAN}{name}{ENDC}: {description}", LIGHTYELLOW)

    # Add XP reward
    user_data["exp"] += 50
    print_colored("Reward: +50 XP", LIGHTGREEN)

    # Check for level up
    check_level_up()

def view_archaeological_sites() -> None:
    """Display discovered archaeological sites and their details"""
    arch_data = user_data.get("archaeology", {})
    discovered_sites = arch_data.get("discovered_sites", [])

    print_header("Discovered Archaeological Sites")

    if not discovered_sites:
        print_colored("You haven't discovered any archaeological sites yet.", YELLOW)
        print_colored("Explore the world to find ancient ruins and dig sites!", CYAN)
        wait_for_input()
        return

    for i, site_name in enumerate(discovered_sites, 1):
        if site_name in ARCHAEOLOGICAL_SITES:
            site = ARCHAEOLOGICAL_SITES[site_name]

            # Calculate how many artifacts have been found at this site
            excavated_count = 0
            for artifact in arch_data.get("excavated_artifacts", []):
                if artifact.get("site") == site_name:
                    excavated_count += 1

            total_artifacts = len(site.get("artifacts", []))

            # Display site info with progress
            print_colored(f"{i}. {site_name}", CYAN + BOLD)
            print_colored(f"   Location: {site['location']}", BLUE)
            print_colored(f"   {site['description']}", WHITE)
            print_colored(f"   Difficulty: {site['difficulty']}", 
                         YELLOW if site['difficulty'] == "Easy" else 
                         GREEN if site['difficulty'] == "Medium" else
                         RED if site['difficulty'] == "Hard" else MAGENTA)
            print_colored(f"   Required Level: {site['difficulty']}", YELLOW)
            print_colored(f"   Artifacts: {excavated_count}/{total_artifacts}", GREEN)
            print()

    wait_for_input()

def excavate_site() -> None:
    """Excavate at the current location to find artifacts"""
    # Check if current location has an archaeological site
    current_location = user_data.get("current_location", "Greenwood Village")

    # Find sites at this location
    sites_here = []
    for site_name, site_data in ARCHAEOLOGICAL_SITES.items():
        if site_data["location"] == current_location:
            sites_here.append((site_name, site_data))

    if not sites_here:
        print_colored(f"There are no archaeological sites at {current_location}.", YELLOW)
        print_colored("Travel to different areas to find ancient ruins and dig sites.", CYAN)
        wait_for_input()
        return

    # If there are multiple sites here, let player choose
    site_name, site_data = sites_here[0]  # Default to first site
    if len(sites_here) > 1:
        print_colored(f"You found multiple archaeological sites at {current_location}:", CYAN)
        for i, (name, data) in enumerate(sites_here, 1):
            print_colored(f"{i}. {name} ({data['difficulty']})", YELLOW)

        try:
            choice = int(input(f"\n{YELLOW}Choose a site to excavate (1-{len(sites_here)}): {ENDC}"))
            if 1 <= choice <= len(sites_here):
                site_name, site_data = sites_here[choice-1]
            else:
                print_colored("Invalid choice. Defaulting to first site.", RED)
        except ValueError:
            print_colored("Invalid input. Defaulting to first site.", RED)

    # Check player level requirement
    if user_data["level"] < site_data["required_level"]:
        print_colored(f"This site requires level {site_data['required_level']} to excavate.", RED)
        print_colored(f"You are only level {user_data['level']}. Come back when you're stronger.", YELLOW)
        wait_for_input()
        return

    # Add site to discovered sites if not already there
    if site_name not in user_data["archaeology"]["discovered_sites"]:
        user_data["archaeology"]["discovered_sites"].append(site_name)
        print_colored(f"You've discovered a new archaeological site: {site_name}!", GREEN)

    # Get player's excavation tool
    tools = user_data["archaeology"].get("tools", ["Basic Trowel"])
    current_tool = tools[0] if tools else "Basic Trowel"  # Default to basic tool

    if len(tools) > 1:
        print_colored("Choose an excavation tool:", CYAN)
        for i, tool_name in enumerate(tools, 1):
            tool = ARCHAEOLOGICAL_EXCAVATION_TOOLS.get(tool_name, {})
            print_colored(f"{i}. {tool_name} - Efficiency: {tool.get('efficiency', 1.0)}, Preservation: {tool.get('preservation_chance', 0.8)*100}%", YELLOW)

        try:
            choice = int(input(f"\n{YELLOW}Choose a tool (1-{len(tools)}): {ENDC}"))
            if 1 <= choice <= len(tools):
                current_tool = tools[choice-1]
            else:
                print_colored("Invalid choice. Using first tool.", RED)
        except ValueError:
            print_colored("Invalid input. Using first tool.", RED)

    # Get tool stats
    tool_data = ARCHAEOLOGICAL_EXCAVATION_TOOLS.get(current_tool, {
        "efficiency": 1.0,
        "preservation_chance": 0.8,
        "value": 50
    })

    # Check which artifacts are already found
    found_artifacts = []
    for artifact in user_data["archaeology"].get("excavated_artifacts", []):
        if artifact.get("site") == site_name:
            found_artifacts.append(artifact.get("name"))

    # Get potential artifacts at this site that haven't been found yet
    available_artifacts = [a for a in site_data.get("artifacts", []) if a not in found_artifacts]

    if not available_artifacts:
        print_colored(f"You've already found all artifacts at {site_name}!", GREEN)
        print_colored("Visit another archaeological site to find more artifacts.", CYAN)
        wait_for_input()
        return

    # Start excavation process
    print_animated(f"Excavating at {site_name} with {current_tool}...", CYAN, delay=0.03)
    time.sleep(1)  # Simulate excavation time

    # Calculate success chance based on difficulty, tool efficiency, and player skill
    difficulty_modifier = {
        "Easy": 0.9,
        "Medium": 0.7,
        "Hard": 0.5,
        "Very Hard": 0.3,
        "Expert": 0.2
    }.get(site_data["difficulty"], 0.5)

    excavation_skill = user_data["archaeology"].get("excavation_skill", 1)

    # Calculate final success chance
    success_chance = min(0.95, difficulty_modifier * tool_data["efficiency"] * (1 + (excavation_skill - 1) * 0.1))

    # Determine if excavation is successful
    if random.random() < success_chance:
        # Choose a random artifact from available ones
        artifact_name = random.choice(available_artifacts)
        artifact_data = ARCHAEOLOGICAL_ARTIFACTS.get(artifact_name, {})

        # Check if artifact is preserved based on tool and skill
        preservation_chance = tool_data["preservation_chance"] * (1 + (excavation_skill - 1) * 0.05)

        if random.random() < preservation_chance:
            # Success! Add artifact to player's collection
            print_animated(f"Success! You found: {artifact_name}", GREEN, delay=0.02)
            print_colored(f"Rarity: {artifact_data.get('rarity', 'Common')}", YELLOW)
            print_colored(f"Set: {artifact_data.get('set', 'None')}", CYAN)
            print_colored(f"{artifact_data.get('description', 'An ancient artifact.')}", WHITE)

            # Add to excavated artifacts
            user_data["archaeology"]["excavated_artifacts"].append({
                "name": artifact_name,
                "site": site_name,
                "analyzed": False,
                "displayed": False
            })

            # Gain experience for successful find
            rarity_exp = {
                "Common": 10,
                "Uncommon": 20,
                "Rare": 35,
                "Epic": 50,
                "Legendary": 100
            }.get(artifact_data.get("rarity", "Common"), 10)

            exp_gain = rarity_exp * (1 + (user_data["level"] - 1) * 0.1)
            user_data["exp"] += exp_gain
            print_colored(f"You gained {exp_gain} experience!", LIGHTGREEN)

            # Check for level up
            check_level_up()

            # Small chance to increase excavation skill
            if random.random() < 0.2:
                user_data["archaeology"]["excavation_skill"] += 1
                print_colored(f"Your excavation skill increased to {user_data['archaeology']['excavation_skill']}!", MAGENTA)

            # Check for completing a set
            check_artifact_set_completion(artifact_data.get('set', ''))
        else:
            # Artifact damaged during excavation
            print_colored("You found something, but it was damaged during excavation.", YELLOW)
            print_colored("A more careful approach or better tools might help next time.", CYAN)
    else:
        # Failed excavation
        print_colored("You didn't find anything valuable this time.", RED)
        print_colored("Keep trying or try another site!", CYAN)

    wait_for_input()

def analyze_artifacts() -> None:
    """Analyze discovered artifacts to learn more about them"""
    arch_data = user_data.get("archaeology", {})
    artifacts = arch_data.get("excavated_artifacts", [])

    # Filter for unanalyzed artifacts
    unanalyzed = [a for a in artifacts if not a.get("analyzed", False)]

    if not unanalyzed:
        if not artifacts:
            print_colored("You don't have any artifacts to analyze.", YELLOW)
            print_colored("Excavate archaeological sites to find artifacts first!", CYAN)
        else:
            print_colored("All your artifacts have already been analyzed.", GREEN)
            print_colored("Find more artifacts to analyze them!", CYAN)
        wait_for_input()
        return

    print_header("Analyze Artifacts")
    print_colored("Select an artifact to analyze and learn more about its history:", CYAN)

    for i, artifact in enumerate(unanalyzed, 1):
        artifact_name = artifact.get("name", "Unknown Artifact")
        artifact_data = ARCHAEOLOGICAL_ARTIFACTS.get(artifact_name, {})
        print_colored(f"{i}. {artifact_name} - {artifact_data.get('rarity', 'Common')}", YELLOW)
        print_colored(f"   Found at: {artifact.get('site', 'Unknown')}", BLUE)
        print_colored(f"   {artifact_data.get('description', 'An ancient artifact.')}", WHITE)
        print()

    print_colored(f"{len(unanalyzed)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an artifact to analyze (1-{len(unanalyzed)+1}): {ENDC}"))

        if choice == len(unanalyzed)+1:
            return

        if 1 <= choice <= len(unanalyzed):
            selected = unanalyzed[choice-1]
            artifact_name = selected.get("name", "Unknown Artifact")
            site_name = selected.get("site", "Unknown Site")

            # Start analysis process
            print_animated(f"Analyzing {artifact_name}...", CYAN, delay=0.03)
            time.sleep(1.5)  # Simulate analysis time

            # Mark as analyzed
            for artifact in artifacts:
                if artifact.get("name") == artifact_name and artifact.get("site") == site_name:
                    artifact["analyzed"] = True

            # Get artifact data
            artifact_data = ARCHAEOLOGICAL_ARTIFACTS.get(artifact_name, {})

            # Check if this gives access to ancient knowledge
            site_data = ARCHAEOLOGICAL_SITES.get(site_name, {})
            knowledge_name = site_data.get("knowledge_reward")

            # Check if all artifacts from this site have been analyzed
            site_artifacts = site_data.get("artifacts", [])
            all_analyzed = True

            for site_artifact in site_artifacts:
                found = False
                for player_artifact in artifacts:
                    if player_artifact.get("name") == site_artifact and player_artifact.get("analyzed", False):
                        found = True
                        break
                if not found:
                    all_analyzed = False
                    break

            # Display analysis results
            print_header(f"Analysis Results: {artifact_name}")
            print_colored(f"Rarity: {artifact_data.get('rarity', 'Common')}", YELLOW)
            print_colored(f"Set: {artifact_data.get('set', 'None')}", CYAN)
            print_colored(f"Value: {artifact_data.get('value', 100)} gold", LIGHTYELLOW)
            print()
            print_colored("Historical Analysis:", LIGHTCYAN)

            # Generate a more detailed description based on artifact and site
            detailed_description = generate_artifact_lore(artifact_name, site_name)
            print_colored(detailed_description, WHITE)
            print()

            # Show effects
            if "effect" in artifact_data:
                print_colored("Special Effects:", MAGENTA)
                for stat, value in artifact_data["effect"].items():
                    print_colored(f"  {stat.replace('_', ' ').title()}: +{value}", GREEN)
                print()

            # If all artifacts from this site have been analyzed, grant knowledge
            if all_analyzed and knowledge_name and knowledge_name not in arch_data.get("knowledge", []):
                print_colored(f"You've analyzed all artifacts from {site_name}!", GREEN)
                print_colored(f"You've gained new knowledge: {knowledge_name}", MAGENTA + BOLD)

                # Add knowledge to player's collection
                user_data["archaeology"]["knowledge"].append(knowledge_name)

                # Integrate with other systems when gaining new knowledge
                integrate_all_systems()

                # Check if this unlocks literature
                if "literature" in user_data and random.random() < 0.6:  # 60% chance
                    literature_ids = list(user_data["literature"]["books"].keys())
                    undiscovered_books = [book_id for book_id in literature_ids 
                                         if not user_data["literature"]["books"][book_id].get("discovered", False)]

                    if undiscovered_books:
                        discovered_book_id = random.choice(undiscovered_books)
                        user_data["literature"]["books"][discovered_book_id]["discovered"] = True
                        book_title = user_data["literature"]["books"][discovered_book_id].get("title", "Unknown Text")
                        print_colored(f"\nYour discoveries revealed an ancient text: {book_title}", MAGENTA)
                        print_colored("This book has been added to your literature collection!", GREEN)

                # Apply knowledge bonuses
                if knowledge_name in ANCIENT_KNOWLEDGE:
                    knowledge_data = ANCIENT_KNOWLEDGE[knowledge_name]
                    print_colored(f"{knowledge_data.get('description', '')}", CYAN)

                    if "stat_bonus" in knowledge_data:
                        print_colored("You gained the following stat bonuses:", YELLOW)
                        for stat, value in knowledge_data["stat_bonus"].items():
                            print_colored(f"  {stat.replace('_', ' ').title()}: +{value}", GREEN)

                            # Apply stat bonus to player
                            if stat not in user_data:
                                user_data[stat] = 0
                            user_data[stat] += value

                    if "unlocks" in knowledge_data:
                        print_colored("You unlocked new abilities:", YELLOW)
                        for ability in knowledge_data["unlocks"]:
                            print_colored(f"  {ability}", GREEN)

            # Gain experience for analyzing
            exp_gain = {
                "Common": 5,
                "Uncommon": 10,
                "Rare": 20,
                "Epic": 35,
                "Legendary": 50
            }.get(artifact_data.get("rarity", "Common"), 5)

            user_data["exp"] += exp_gain
            print_colored(f"You gained {exp_gain} experience from analysis!", LIGHTGREEN)

            # Check for level up
            check_level_up()

            # Small chance to increase analysis skill
            # No need to retrieve the current value as we're just incrementing it
            if random.random() < 0.15:
                user_data["archaeology"]["analysis_skill"] += 1
                print_colored(f"Your analysis skill increased to {user_data['archaeology']['analysis_skill']}!", MAGENTA)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def generate_artifact_lore(artifact_name: str, site_name: str) -> str:
    """Generate detailed lore for an artifact based on its origin"""
    artifact_data = ARCHAEOLOGICAL_ARTIFACTS.get(artifact_name, {})
    base_description = artifact_data.get("description", "An ancient artifact of unknown origin.")

    # Site-specific lore fragments
    site_lore = {
        "Ancient Temple Ruins": [
            "Inscriptions suggest it was used in rituals to honor the god of {element}.",
            "Temple records indicate it belonged to a high priest named {name}.",
            "It bears symbols associated with the {season} festival of renewal.",
            "The craftsmanship indicates it was made during the reign of {ruler}."
        ],
        "Abandoned Mine": [
            "Traces of rare minerals suggest it was crafted in the deepest section of the mine.",
            "Markings indicate it belonged to master miner {name}.",
            "It was likely used during the great mineral rush of the {ancient} era.",
            "The design suggests it had both practical and ceremonial purposes."
        ],
        "Sunken Palace": [
            "Despite centuries underwater, the royal craftsmanship remains evident.",
            "Court records mention this was commissioned by {ruler} the {title}.",
            "It's decorated with symbols of the royal family's patron deity.",
            "This piece would have been present during historical diplomatic meetings."
        ],
        "Celestial Observatory": [
            "Star patterns engraved on it match the sky as it appeared {years} years ago.",
            "It was likely used by astronomer {name} to predict {event}.",
            "The material contains traces of stardust, suggesting celestial origin.",
            "Symbols indicate it was used to track the movement of the {celestial} constellation."
        ],
        "Battlefield Grave Site": [
            "Blood stains suggest it was carried during the final battle of the {war}.",
            "It belonged to {rank} {name}, who led the charge against the enemy forces.",
            "Markings indicate it was awarded for exceptional bravery in combat.",
            "Despite its age, it still radiates a warrior's determination."
        ]
    }

    # Random name generation helpers
    ancient_names = ["Azuran", "Thelos", "Mirivian", "Kalindor", "Sythera", "Orindus", "Elyssian", "Dranath"]
    titles = ["Wise", "Brave", "Merciful", "Conqueror", "Visionary", "Mighty", "Blessed", "Feared"]
    elements = ["Fire", "Water", "Earth", "Air", "Light", "Shadow", "Time", "Life"]
    seasons = ["Spring", "Summer", "Autumn", "Winter", "Solstice", "Equinox"]
    ancient_eras = ["Golden", "Silver", "Bronze", "Iron", "Crystal", "Shadow", "Enlightened"]
    years = [500, 1000, 1500, 2000, 3000, 5000]
    celestial_bodies = ["North Star", "Twin Moons", "Seven Sisters", "Dragon's Tail", "Eternal Eye"]
    wars = ["Unification", "Liberation", "Purification", "Reclamation", "Ascension"]
    ranks = ["Commander", "General", "Captain", "Warlord", "Champion", "Guardian"]
    events = ["solar eclipse", "star alignment", "comet passage", "celestial convergence"]

    # Get lore fragments for this site
    lore_fragments = site_lore.get(site_name, ["Its origins remain a mystery."])

    # Choose a random lore fragment and format it
    lore = random.choice(lore_fragments).format(
        element=random.choice(elements),
        name=random.choice(ancient_names),
        season=random.choice(seasons),
        ruler=f"{random.choice(ancient_names)} the {random.choice(titles)}",
        ancient=random.choice(ancient_eras),
        title=random.choice(titles),
        years=random.choice(years),
        celestial=random.choice(celestial_bodies),
        war=f"{random.choice(wars)} War",
        rank=random.choice(ranks),
        event=random.choice(events)
    )

    # Final lore combines base description with site-specific details
    full_lore = f"{base_description} {lore}"

    # Add set-specific details if applicable
    artifact_set = artifact_data.get("set", "")
    if artifact_set:
        set_details = {
            "Temple Collection": "It is part of a sacred collection used in the most important temple rituals.",
            "Mining Collection": "Together with other mining artifacts, it tells the story of an advanced mining civilization.",
            "Royal Collection": "It belonged to the royal collection, with immense historical and cultural significance.",
            "Celestial Collection": "When combined with other astronomical instruments, it reveals secrets of the cosmos.",
            "Warrior Collection": "It is one piece of legendary battle gear carried by the greatest warriors."
        }

        if artifact_set in set_details:
            full_lore += f" {set_details[artifact_set]}"

    return full_lore

def check_artifact_set_completion(set_name: str) -> None:
    """Check if player has completed an artifact set and apply bonuses.
    Creates strong links between archaeology and other systems."""
    if not set_name:
        return

    # Get all artifacts in this set
    set_artifacts = []
    for name, data in ARCHAEOLOGICAL_ARTIFACTS.items():
        if data.get("set") == set_name:
            set_artifacts.append(name)

    # Check if player has all artifacts in the set
    player_artifacts = [a.get("name") for a in user_data["archaeology"].get("excavated_artifacts", [])]

    all_found = True
    for artifact in set_artifacts:
        if artifact not in player_artifacts:
            all_found = False
            break

    # If all found and not already completed, grant set bonus
    completed_sets = user_data["archaeology"].get("completed_sets", [])
    if all_found and set_name not in completed_sets:
        # Add to completed sets
        if "completed_sets" not in user_data["archaeology"]:
            user_data["archaeology"]["completed_sets"] = []
        user_data["archaeology"]["completed_sets"].append(set_name)

        # Track in collections for bonus system
        if "artifact_collections" not in user_data["archaeology"]:
            user_data["archaeology"]["artifact_collections"] = {}

        if set_name not in user_data["archaeology"]["artifact_collections"]:
            user_data["archaeology"]["artifact_collections"][set_name] = []

        for artifact in set_artifacts:
            if artifact not in user_data["archaeology"]["artifact_collections"][set_name]:
                user_data["archaeology"]["artifact_collections"][set_name].append(artifact)

        # Integrate with other systems
        integrate_all_systems()

        # Get set bonus
        if set_name in ARCHAEOLOGICAL_SET_BONUSES:
            set_data = ARCHAEOLOGICAL_SET_BONUSES[set_name]

            print_colored(f"\nCongratulations! You've completed the {set_name}!", GREEN + BOLD)
            print_colored(f"Set Bonus: {set_data['name']}", MAGENTA)
            print_colored(f"{set_data['description']}", CYAN)

            # Apply stat bonuses
            if "bonus" in set_data:
                print_colored("You gained the following permanent bonuses:", YELLOW)
                for stat, value in set_data["bonus"].items():
                    print_colored(f"  {stat.replace('_', ' ').title()}: +{value}", GREEN)

                    # Apply stat bonus to player
                    if stat not in user_data:
                        user_data[stat] = 0
                    user_data[stat] += value

            # Grant achievement
            achievement_text = f"Complete the {set_name}"
            unlock_achievement("Artifact Collector", f"Completed the {set_name} artifact set", achievement_text)

            # Extra XP reward
            user_data["exp"] += 300
            print_colored("You gained 300 bonus experience!", LIGHTGREEN)

            # Check for level up
            check_level_up()

def view_museum() -> None:
    """View and manage your archaeological museum exhibits"""
    arch_data = user_data.get("archaeology", {})
    artifacts = arch_data.get("excavated_artifacts", [])
    museum_exhibits = arch_data.get("museum_exhibits", [])

    print_header("Your Archaeological Museum")

    if not artifacts:
        print_colored("You don't have any artifacts to display in your museum.", YELLOW)
        print_colored("Excavate archaeological sites to find artifacts first!", CYAN)
        wait_for_input()
        return

    # Display current exhibits
    if museum_exhibits:
        print_colored("Current Exhibits:", CYAN)
        for i, exhibit in enumerate(museum_exhibits, 1):
            artifact_name = exhibit.get("artifact")
            artifact_data = ARCHAEOLOGICAL_ARTIFACTS.get(artifact_name, {})

            print_colored(f"{i}. {artifact_name} ({artifact_data.get('rarity', 'Common')})", YELLOW)
            print_colored(f"   {artifact_data.get('description', 'An ancient artifact.')}", WHITE)
            print_colored(f"   Visitors attracted: {exhibit.get('visitors', 0)} per day", GREEN)
            print_colored(f"   Daily income: {exhibit.get('income', 0)} gold", LIGHTYELLOW)
            print()

        # Calculate total museum stats
        total_visitors = sum(exhibit.get("visitors", 0) for exhibit in museum_exhibits)
        total_income = sum(exhibit.get("income", 0) for exhibit in museum_exhibits)

        print_colored(f"Total daily visitors: {total_visitors}", CYAN)
        print_colored(f"Total daily income: {total_income} gold", LIGHTYELLOW)
        print()
    else:
        print_colored("Your museum has no exhibits yet.", YELLOW)
        print_colored("Display some of your artifacts to attract visitors and earn gold!", CYAN)
        print()

    # Museum management options
    print_colored("Museum Management:", CYAN)
    print_colored("1. Add New Exhibit", YELLOW)
    print_colored("2. Remove Exhibit", YELLOW)
    print_colored("3. Collect Daily Income", YELLOW)
    print_colored("4. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-4): {ENDC}"))

        if choice == 1:
            add_museum_exhibit()
        elif choice == 2:
            remove_museum_exhibit()
        elif choice == 3:
            collect_museum_income()
        elif choice == 4:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    # Return to museum menu after action
    view_museum()

def add_museum_exhibit() -> None:
    """Add a new artifact exhibit to your museum"""
    arch_data = user_data.get("archaeology", {})
    artifacts = arch_data.get("excavated_artifacts", [])
    museum_exhibits = arch_data.get("museum_exhibits", [])

    # Filter for analyzed artifacts that aren't already exhibited
    exhibited_names = [exhibit.get("artifact") for exhibit in museum_exhibits]
    available_artifacts = [a for a in artifacts if a.get("analyzed", False) and a.get("name") not in exhibited_names]

    if not available_artifacts:
        print_colored("You don't have any artifacts available to exhibit.", YELLOW)
        print_colored("Find more artifacts or analyze your existing ones first!", CYAN)
        wait_for_input()
        return

    print_colored("Select an artifact to display in your museum:", CYAN)

    for i, artifact in enumerate(available_artifacts, 1):
        artifact_name = artifact.get("name", "Unknown Artifact")
        artifact_data = ARCHAEOLOGICAL_ARTIFACTS.get(artifact_name, {})

        print_colored(f"{i}. {artifact_name} - {artifact_data.get('rarity', 'Common')}", YELLOW)
        print_colored(f"   {artifact_data.get('description', 'An ancient artifact.')}", WHITE)
        print()

    print_colored(f"{len(available_artifacts)+1}. Cancel", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an artifact to exhibit (1-{len(available_artifacts)+1}): {ENDC}"))

        if choice == len(available_artifacts)+1:
            return

        if 1 <= choice <= len(available_artifacts):
            selected = available_artifacts[choice-1]
            artifact_name = selected.get("name", "Unknown Artifact")

            # Calculate exhibit stats based on artifact rarity and analysis skill
            artifact_data = ARCHAEOLOGICAL_ARTIFACTS.get(artifact_name, {})
            rarity = artifact_data.get("rarity", "Common")

            # Base visitors and income by rarity
            rarity_values = {
                "Common": {"visitors": 5, "income": 10},
                "Uncommon": {"visitors": 10, "income": 25},
                "Rare": {"visitors": 20, "income": 50},
                "Epic": {"visitors": 35, "income": 100},
                "Legendary": {"visitors": 50, "income": 200}
            }

            base_stats = rarity_values.get(rarity, {"visitors": 5, "income": 10})

            # Apply analysis skill modifier
            # Use the analysis_skill to calculate museum stats
            analysis_skill = user_data["archaeology"].get("analysis_skill", 1)
            visitors = int(base_stats["visitors"] * (1 + (analysis_skill - 1) * 0.1))
            income = int(base_stats["income"] * (1 + (analysis_skill - 1) * 0.1))

            # Create exhibit
            exhibit = {
                "artifact": artifact_name,
                "visitors": visitors,
                "income": income,
                "last_collected": user_data.get("current_day", 0)
            }

            # Add to museum
            if "museum_exhibits" not in user_data["archaeology"]:
                user_data["archaeology"]["museum_exhibits"] = []

            user_data["archaeology"]["museum_exhibits"].append(exhibit)

            print_colored(f"{artifact_name} is now on display in your museum!", GREEN)
            print_colored(f"It will attract approximately {visitors} visitors per day.", CYAN)
            print_colored(f"Expected daily income: {income} gold", LIGHTYELLOW)

            # Check for achievement
            if len(user_data["archaeology"]["museum_exhibits"]) >= 5:
                unlock_achievement("Museum Curator", "Display 5 artifacts in your museum", "Display 5 artifacts")
            if len(user_data["archaeology"]["museum_exhibits"]) >= 10:
                unlock_achievement("Master Curator", "Display 10 artifacts in your museum", "Display 10 artifacts")
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def view_ancient_knowledge() -> None:
    """View acquired ancient knowledge and their effects"""
    arch_data = user_data.get("archaeology", {})
    knowledge_list = arch_data.get("knowledge", [])

    print_header("Ancient Knowledge")

    if not knowledge_list:
        print_colored("You haven't acquired any ancient knowledge yet.", YELLOW)
        print_colored("Complete archaeological site excavations to learn ancient knowledge!", CYAN)
        wait_for_input()
        return

    for knowledge_name in knowledge_list:
        if knowledge_name in ANCIENT_KNOWLEDGE:
            knowledge_data = ANCIENT_KNOWLEDGE[knowledge_name]

            print_colored(f"{knowledge_name}", MAGENTA + BOLD)
            print_colored(f"{knowledge_data.get('description', 'Ancient knowledge.')}", WHITE)

            # Display stat bonuses
            if "stat_bonus" in knowledge_data:
                print_colored("Stat Bonuses:", YELLOW)
                for stat, value in knowledge_data["stat_bonus"].items():
                    print_colored(f"  {stat.replace('_', ' ').title()}: +{value}", GREEN)

            # Display unlocks
            if "unlocks" in knowledge_data:
                print_colored("Unlocked Abilities:", CYAN)
                for ability in knowledge_data["unlocks"]:
                    print_colored(f"  - {ability}", WHITE)

            print()

    wait_for_input()

def purchase_excavation_tools() -> None:
    """Purchase better excavation tools for archaeology"""
    available_tools = []

    # Get player's current tools
    current_tools = user_data["archaeology"].get("tools", ["Basic Trowel"])

    # Determine which tools are available based on player level
    player_level = user_data.get("level", 1)

    if player_level >= 1:
        available_tools.append("Basic Trowel")
    if player_level >= 5:
        available_tools.append("Archaeologist's Brush Set")
    if player_level >= 10:
        available_tools.append("Surveying Equipment")
    if player_level >= 15:
        available_tools.append("Advanced Detector")
    if player_level >= 25:
        available_tools.append("Master Excavation Kit")

    print_header("Purchase Excavation Tools")
    print_colored(f"Your gold: {user_data.get('gold', 0)}", LIGHTYELLOW)
    print_colored("Better tools improve your excavation success rate and artifact preservation.", CYAN)
    print()

    print_colored("Available Tools:", YELLOW)
    for i, tool_name in enumerate(available_tools, 1):
        tool = ARCHAEOLOGICAL_EXCAVATION_TOOLS.get(tool_name, {})
        price = tool.get("value", 50)
        owned = "✓" if tool_name in current_tools else ""

        print_colored(f"{i}. {tool_name} {owned}", GREEN if owned else YELLOW)
        print_colored(f"   Price: {price} gold", LIGHTYELLOW)
        print_colored(f"   Efficiency: {tool.get('efficiency', 1.0)}", BLUE)
        print_colored(f"   Preservation: {int(tool.get('preservation_chance', 0.8) * 100)}%", CYAN)
        print_colored(f"   {tool.get('description', 'An excavation tool.')}", WHITE)
        print()

    print_colored(f"{len(available_tools)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose a tool to purchase (1-{len(available_tools)+1}): {ENDC}"))

        if choice == len(available_tools)+1:
            return

        if 1 <= choice <= len(available_tools):
            selected_tool = available_tools[choice-1]

            if selected_tool in current_tools:
                print_colored(f"You already own the {selected_tool}.", YELLOW)
            else:
                # Check if player can afford it
                tool_price = ARCHAEOLOGICAL_EXCAVATION_TOOLS.get(selected_tool, {}).get("value", 50)

                if user_data.get("gold", 0) >= tool_price:
                    # Purchase the tool
                    user_data["gold"] -= tool_price
                    user_data["archaeology"]["tools"].append(selected_tool)

                    print_colored(f"You purchased the {selected_tool}!", GREEN)
                    print_colored("It has been added to your archaeology tools.", CYAN)
                else:
                    print_colored(f"You don't have enough gold to buy the {selected_tool}.", RED)
                    print_colored(f"You need {tool_price} gold, but only have {user_data.get('gold', 0)}.", YELLOW)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def collect_museum_income() -> None:
    """Collect daily income from museum exhibits"""
    arch_data = user_data.get("archaeology", {})
    museum_exhibits = arch_data.get("museum_exhibits", [])

    if not museum_exhibits:
        print_colored("You don't have any exhibits in your museum to generate income.", YELLOW)
        wait_for_input()
        return

    current_day = user_data.get("current_day", 0)

    # Check for uncollected income
    uncollected_exhibits = []
    for exhibit in museum_exhibits:
        if exhibit.get("last_collected", 0) < current_day:
            uncollected_exhibits.append(exhibit)

    if not uncollected_exhibits:
        print_colored("You've already collected today's museum income.", YELLOW)
        wait_for_input()
        return

    # Calculate total income
    days_passed = min(7, current_day - min(exhibit.get("last_collected", 0) for exhibit in uncollected_exhibits))
    days_passed = max(1, days_passed)  # At least 1 day

    total_visitors = sum(exhibit.get("visitors", 0) for exhibit in uncollected_exhibits)
    total_income = sum(exhibit.get("income", 0) for exhibit in uncollected_exhibits) * days_passed

    # Add income to player
    user_data["gold"] += total_income

    # Update last collected day
    for exhibit in museum_exhibits:
        exhibit["last_collected"] = current_day

    print_colored(f"You collected {days_passed} days of museum income!", GREEN)
    print_colored(f"Your museum attracted {total_visitors * days_passed} visitors.", CYAN)
    print_colored(f"Total income: {total_income} gold", LIGHTYELLOW)
    print_colored(f"New gold balance: {user_data.get('gold', 0)}", LIGHTYELLOW)

    wait_for_input()

def remove_museum_exhibit() -> None:
    """Remove an artifact from museum display"""
    arch_data = user_data.get("archaeology", {})
    museum_exhibits = arch_data.get("museum_exhibits", [])

    if not museum_exhibits:
        print_colored("You don't have any exhibits to remove.", YELLOW)
        wait_for_input()
        return

    print_colored("Select an exhibit to remove from your museum:", CYAN)

    for i, exhibit in enumerate(museum_exhibits, 1):
        artifact_name = exhibit.get("artifact")
        print_colored(f"{i}. {artifact_name}", YELLOW)
        print_colored(f"   Visitors: {exhibit.get('visitors', 0)} per day, Income: {exhibit.get('income', 0)} gold per day", CYAN)

    print_colored(f"{len(museum_exhibits)+1}. Cancel", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an exhibit to remove (1-{len(museum_exhibits)+1}): {ENDC}"))

        if choice == len(museum_exhibits)+1:
            return

        if 1 <= choice <= len(museum_exhibits):
            removed = museum_exhibits.pop(choice-1)
            print_colored(f"Removed {removed.get('artifact')} from your museum display.", YELLOW)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def literature_system() -> None:
    """Main function for the literature system - manage books, scrolls, and notes"""
    global user_data

    # Initialize literature data if it doesn't exist
    if "literature" not in user_data:
        user_data["literature"] = {
            "discovered": [],
            "read": [],
            "owned": []
        }

    print_header("Literature Collection")
    print_colored("Collect and read books, scrolls, and notes to gain knowledge and special abilities.", CYAN)
    print()

    # Main literature menu
    print_colored("1. View Your Collection", YELLOW)
    print_colored("2. Read Something", YELLOW)
    print_colored("3. Search for Literature", YELLOW)
    print_colored("4. Book Effects", YELLOW)
    print_colored("5. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-5): {ENDC}"))

        if choice == 1:
            view_literature_collection()
        elif choice == 2:
            read_literature()
        elif choice == 3:
            search_literature()
        elif choice == 4:
            view_literature_effects()
        elif choice == 5:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    # Return to literature menu after completing action
    literature_system()

def view_literature_collection() -> None:
    """Display all books, scrolls, and notes the player has discovered or owns with enhanced features"""
    lit_data = user_data.get("literature", {})
    discovered = lit_data.get("discovered", [])
    owned = lit_data.get("owned", [])
    read = lit_data.get("read", [])

    if not discovered and not owned:
        print_colored("You haven't discovered any books, scrolls, or notes yet.", YELLOW)
        print_colored("Explore the world to find literature!", CYAN)
        print_colored("Hint: Visit libraries, archives, and ancient ruins to find rare texts.", CYAN)
        wait_for_input()
        return

    # Calculate collection stats
    total_discovered = len(discovered)
    total_owned = len(owned)
    total_read = len(read)

    # Collection completion percentage
    completion_percentage = int((total_owned / max(total_discovered, 1)) * 100)
    reading_percentage = int((total_read / max(total_owned, 1)) * 100)

    # Collection status titles
    if completion_percentage >= 90:
        collection_status = f"{GREEN}Master Collector{ENDC}"
    elif completion_percentage >= 70:
        collection_status = f"{CYAN}Dedicated Collector{ENDC}"
    elif completion_percentage >= 50:
        collection_status = f"{YELLOW}Aspiring Collector{ENDC}"
    else:
        collection_status = f"{WHITE}Novice Collector{ENDC}"

    # Scholar status based on reading
    if reading_percentage >= 90:
        scholar_status = f"{GREEN}Grand Scholar{ENDC}"
    elif reading_percentage >= 70:
        scholar_status = f"{CYAN}Scholar{ENDC}"
    elif reading_percentage >= 50:
        scholar_status = f"{YELLOW}Student{ENDC}"
    else:
        scholar_status = f"{WHITE}Beginner Reader{ENDC}"

    # Main menu loop for the literature collection
    while True:
        clear_screen()
        print_header("Your Literature Collection")

        # Display collection stats
        print_colored(f"Collection Status: {collection_status} | Scholar Status: {scholar_status}", BLUE + BOLD)
        print_colored(f"Discovered: {total_discovered} | Owned: {total_owned} ({completion_percentage}%) | Read: {total_read} ({reading_percentage}%)", CYAN)
        print()

        # Main options
        print_colored("View Collection By:", YELLOW)
        print_colored("1. Type (Books, Scrolls, Notes)", WHITE)
        print_colored("2. Rarity (Common to Legendary)", WHITE)
        print_colored("3. Reading Status (Read/Unread)", WHITE)
        print_colored("4. Recently Acquired", WHITE)
        print_colored("5. Search Collection", CYAN)
        print_colored("6. View Collection Stats", CYAN)
        print_colored("7. Back to Literature Menu", RED)

        try:
            choice = int(input(f"\n{YELLOW}Choose an option (1-7): {ENDC}"))

            if choice == 1:
                view_by_type(discovered, owned, read)
            elif choice == 2:
                view_by_rarity(discovered, owned, read)
            elif choice == 3:
                view_by_status(discovered, owned, read)
            elif choice == 4:
                view_recent_acquisitions(discovered, owned, read)
            elif choice == 5:
                search_collection(discovered, owned, read)
            elif choice == 6:
                view_collection_stats(discovered, owned, read)
            elif choice == 7:
                return
            else:
                print_colored("Invalid choice. Please select 1-7.", RED)
        except ValueError:
            print_colored("Please enter a number.", RED)

        wait_for_input()

def view_by_type(discovered: Dict[str, Any], owned: Dict[str, Any], read: Dict[str, Any]) -> None:
    """View literature collection sorted by type (Books, Scrolls, Notes)"""
    clear_screen()
    print_header("Literature by Type")

    print_colored("Select a type to view:", CYAN)
    print_colored("1. Books", WHITE)
    print_colored("2. Scrolls", WHITE)
    print_colored("3. Notes", WHITE)
    print_colored("4. All Types", CYAN)
    print_colored("5. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose a type (1-5): {ENDC}"))

        if choice == 5:
            return

        # Organize collection data
        collection = {}

        # Types to display based on choice
        if choice == 1:
            types_to_show = ["Books"]
        elif choice == 2:
            types_to_show = ["Scrolls"]
        elif choice == 3:
            types_to_show = ["Notes"]
        elif choice == 4:
            types_to_show = ["Books", "Scrolls", "Notes"]
        else:
            print_colored("Invalid choice.", RED)
            return

        # Initialize collection structure
        for item_type in types_to_show:
            collection[item_type] = {}

        # Process all items
        all_items = list(set(list(discovered.keys()) + list(owned.keys())))
        for item_id in all_items:
            try:
                item_type, category, title = item_id.split(":", 2)

                if item_type not in types_to_show:
                    continue

                # Initialize category if needed
                if category not in collection[item_type]:
                    collection[item_type][category] = []

                # Get item data
                if item_type == "Books":
                    item_data = LITERATURE_DATA["books"][category][title]
                elif item_type == "Scrolls":
                    item_data = LITERATURE_DATA["scrolls"][category][title]
                elif item_type == "Notes":
                    item_data = LITERATURE_DATA["notes"][category][title]
                else:
                    continue

                # Add to collection with status
                status = "Read" if item_id in read else "Unread"
                ownership = "Owned" if item_id in owned else "Discovered"

                collection[item_type][category].append({
                    "title": title,
                    "data": item_data,
                    "status": status,
                    "ownership": ownership,
                    "item_id": item_id,
                    "rarity": item_data.get("rarity", "Common")
                })
            except (ValueError, KeyError):
                continue

        # Display collection
        clear_screen()
        print_header("Literature Collection")

        # Count items for header
        total_items = 0
        for item_type in types_to_show:
            for category, items in collection[item_type].items():
                total_items += len(items)

        print_colored(f"Found {total_items} items", CYAN)

        # Display items by type
        for item_type in types_to_show:
            if collection[item_type]:
                print_colored(f"\n{item_type}", CYAN + BOLD)

                # Count categories
                total_categories = len(collection[item_type])
                print_colored(f"  {total_categories} categories", BLUE)

                for category, items in collection[item_type].items():
                    if items:
                        # Sort items by rarity (highest first)
                        rarity_values = {"Common": 0, "Uncommon": 1, "Rare": 2, "Epic": 3, "Legendary": 4}
                        items.sort(key=lambda x: (rarity_values.get(x["rarity"], 0), x["title"]), reverse=True)

                        # Count owned items in this category
                        owned_count = sum(1 for item in items if item["ownership"] == "Owned")
                        read_count = sum(1 for item in items if item["status"] == "Read")

                        print_colored(f"  {category} ({owned_count}/{len(items)} owned, {read_count}/{owned_count if owned_count else 1} read)", BLUE + BOLD)

                        for i, item in enumerate(items, 1):
                            title = item["data"].get("title", "Unknown")
                            rarity = item["rarity"]

                            # Get appropriate colors
                            rarity_colors = {
                                "Common": WHITE,
                                "Uncommon": GREEN,
                                "Rare": BLUE,
                                "Epic": MAGENTA,
                                "Legendary": YELLOW
                            }
                            rarity_color = rarity_colors.get(rarity, WHITE)
                            status_color = GREEN if item["status"] == "Read" else YELLOW

                            print_colored(f"    {title} ({rarity_color}{rarity}{ENDC})", WHITE)
                            print_colored(f"      Status: {status_color}{item['status']}{ENDC} | {item['ownership']}", WHITE)

        if total_items == 0:
            if len(types_to_show) == 1:
                print_colored(f"You haven't discovered any {types_to_show[0].lower()} yet.", YELLOW)
            else:
                print_colored("You haven't discovered any literature of the selected types yet.", YELLOW)
    except ValueError:
        print_colored("Please enter a number.", RED)

def view_by_rarity(discovered: Dict[str, Any], owned: Dict[str, Any], read: Dict[str, Any]) -> None:
    """View literature collection sorted by rarity"""
    clear_screen()
    print_header("Literature by Rarity")

    # Define rarities from lowest to highest
    rarities = ["Common", "Uncommon", "Rare", "Epic", "Legendary"]

    print_colored("Select a rarity to view:", CYAN)
    for i, rarity in enumerate(rarities, 1):
        # Color-code rarity options
        rarity_colors = {
            "Common": WHITE,
            "Uncommon": GREEN,
            "Rare": BLUE,
            "Epic": MAGENTA,
            "Legendary": YELLOW
        }
        rarity_color = rarity_colors.get(rarity, WHITE)
        print_colored(f"{i}. {rarity_color}{rarity}{ENDC}", WHITE)

    print_colored(f"{len(rarities)+1}. All Rarities", CYAN)
    print_colored(f"{len(rarities)+2}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose a rarity (1-{len(rarities)+2}): {ENDC}"))

        if choice == len(rarities)+2:
            return

        # Determine which rarities to show
        if 1 <= choice <= len(rarities):
            rarities_to_show = [rarities[choice-1]]
        elif choice == len(rarities)+1:
            rarities_to_show = rarities
        else:
            print_colored("Invalid choice.", RED)
            return

        # Collect items by rarity
        items_by_rarity = {rarity: [] for rarity in rarities_to_show}

        # Process all items
        all_items = list(set(list(discovered.keys()) + list(owned.keys())))
        for item_id in all_items:
            try:
                item_type, category, title = item_id.split(":", 2)

                # Get item data
                if item_type == "Books":
                    item_data = LITERATURE_DATA["books"][category][title]
                elif item_type == "Scrolls":
                    item_data = LITERATURE_DATA["scrolls"][category][title]
                elif item_type == "Notes":
                    item_data = LITERATURE_DATA["notes"][category][title]
                else:
                    continue

                # Get rarity and check if it should be shown
                rarity = item_data.get("rarity", "Common")
                if rarity not in rarities_to_show:
                    continue

                # Add to collection
                status = "Read" if item_id in read else "Unread"
                ownership = "Owned" if item_id in owned else "Discovered"

                items_by_rarity[rarity].append({
                    "title": title,
                    "type": item_type,
                    "category": category,
                    "data": item_data,
                    "status": status,
                    "ownership": ownership,
                    "item_id": item_id
                })
            except (ValueError, KeyError):
                continue

        # Display items by rarity
        clear_screen()
        print_header("Literature by Rarity")

        total_items = sum(len(items) for items in items_by_rarity.values())
        print_colored(f"Found {total_items} items", CYAN)

        for rarity in rarities_to_show:
            if items_by_rarity[rarity]:
                # Get rarity color
                rarity_colors = {
                    "Common": WHITE,
                    "Uncommon": GREEN,
                    "Rare": BLUE,
                    "Epic": MAGENTA,
                    "Legendary": YELLOW
                }
                rarity_color = rarity_colors.get(rarity, WHITE)

                print_colored(f"\n{rarity_color}{rarity}{ENDC} Items ({len(items_by_rarity[rarity])})", BOLD)

                # Group by type for better organization
                items_by_type = {}
                for item in items_by_rarity[rarity]:
                    item_type = item["type"]
                    if item_type not in items_by_type:
                        items_by_type[item_type] = []
                    items_by_type[item_type].append(item)

                for item_type, items in items_by_type.items():
                    print_colored(f"  {item_type}", BLUE + BOLD)

                    # Sort by category and title
                    items.sort(key=lambda x: (x["category"], x["title"]))

                    for item in items:
                        title = item["data"].get("title", "Unknown")
                        status_color = GREEN if item["status"] == "Read" else YELLOW

                        print_colored(f"    {title} ({item['category']})", WHITE)
                        print_colored(f"      Status: {status_color}{item['status']}{ENDC} | {item['ownership']}", WHITE)

        if total_items == 0:
            if len(rarities_to_show) == 1:
                print_colored(f"You haven't discovered any {rarities_to_show[0].lower()} literature yet.", YELLOW)
            else:
                print_colored("You haven't discovered any literature of the selected rarities yet.", YELLOW)
    except ValueError:
        print_colored("Please enter a number.", RED)

def view_by_status(discovered: Dict[str, Any], owned: Dict[str, Any], read: Dict[str, Any]) -> None:
    """View literature collection by reading status"""
    clear_screen()
    print_header("Literature by Reading Status")

    print_colored("Select status to view:", CYAN)
    print_colored("1. Read", GREEN)
    print_colored("2. Unread", YELLOW)
    print_colored("3. Owned", BLUE)
    print_colored("4. Discovered (But Not Owned)", MAGENTA)
    print_colored("5. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose a status (1-5): {ENDC}"))

        if choice == 5:
            return

        # Filter items based on choice
        filtered_items = []

        # Process all items
        all_items = list(set(list(discovered.keys()) + list(owned.keys())))
        for item_id in all_items:
            try:
                item_type, category, title = item_id.split(":", 2)

                # Get item data
                if item_type == "Books":
                    item_data = LITERATURE_DATA["books"][category][title]
                elif item_type == "Scrolls":
                    item_data = LITERATURE_DATA["scrolls"][category][title]
                elif item_type == "Notes":
                    item_data = LITERATURE_DATA["notes"][category][title]
                else:
                    continue

                # Determine if this item should be included
                status = "Read" if item_id in read else "Unread"
                ownership = "Owned" if item_id in owned else "Discovered"

                include_item = False
                if choice == 1 and status == "Read":
                    include_item = True
                elif choice == 2 and status == "Unread" and ownership == "Owned":
                    include_item = True
                elif choice == 3 and ownership == "Owned":
                    include_item = True
                elif choice == 4 and ownership == "Discovered":
                    include_item = True

                if include_item:
                    filtered_items.append({
                        "title": title,
                        "type": item_type,
                        "category": category,
                        "data": item_data,
                        "status": status,
                        "ownership": ownership,
                        "item_id": item_id,
                        "rarity": item_data.get("rarity", "Common")
                    })
            except (ValueError, KeyError):
                continue

        # Display filtered items
        clear_screen()
        status_labels = {1: "Read", 2: "Unread", 3: "Owned", 4: "Discovered"}
        print_header(f"Literature - {status_labels.get(choice, '')} Items")

        if not filtered_items:
            print_colored(f"No {status_labels.get(choice, '').lower()} literature found.", YELLOW)
            return

        print_colored(f"Found {len(filtered_items)} items", CYAN)

        # Sort items by rarity (highest first) then by type
        rarity_values = {"Common": 0, "Uncommon": 1, "Rare": 2, "Epic": 3, "Legendary": 4}
        filtered_items.sort(key=lambda x: (-rarity_values.get(x["rarity"], 0), x["type"], x["category"], x["title"]))

        # Group by type for display
        items_by_type = {}
        for item in filtered_items:
            item_type = item["type"]
            if item_type not in items_by_type:
                items_by_type[item_type] = []
            items_by_type[item_type].append(item)

        for item_type, items in items_by_type.items():
            print_colored(f"\n{item_type}", CYAN + BOLD)

            # Group by category
            items_by_category = {}
            for item in items:
                category = item["category"]
                if category not in items_by_category:
                    items_by_category[category] = []
                items_by_category[category].append(item)

            for category, cat_items in items_by_category.items():
                print_colored(f"  {category}", BLUE + BOLD)

                for item in cat_items:
                    title = item["data"].get("title", "Unknown")
                    rarity = item["rarity"]

                    # Get appropriate colors
                    rarity_colors = {
                        "Common": WHITE,
                        "Uncommon": GREEN,
                        "Rare": BLUE,
                        "Epic": MAGENTA,
                        "Legendary": YELLOW
                    }
                    rarity_color = rarity_colors.get(rarity, WHITE)
                    status_color = GREEN if item["status"] == "Read" else YELLOW

                    print_colored(f"    {title} ({rarity_color}{rarity}{ENDC})", WHITE)
                    if choice != 1 and choice != 2:  # Only show status if not filtering by it
                        print_colored(f"      Status: {status_color}{item['status']}{ENDC}", WHITE)
                    if choice != 3 and choice != 4:  # Only show ownership if not filtering by it
                        print_colored(f"      {item['ownership']}", WHITE)
    except ValueError:
        print_colored("Please enter a number.", RED)

def view_recent_acquisitions(discovered: Dict[str, Any], owned: Dict[str, Any], read: Dict[str, Any]) -> None:
    """View recently acquired literature (placeholder - would need timestamp data)"""
    clear_screen()
    print_header("Recent Acquisitions")

    print_colored("This feature will show your most recently acquired literature items.", CYAN)
    print_colored("Feature coming soon in a future update!", YELLOW)

    # This would require adding timestamp data to the literature items
    # For now, just show the last 5 items alphabetically as a demonstration

    # Get owned items
    owned_items = []
    for item_id in owned:
        try:
            item_type, category, title = item_id.split(":", 2)

            # Get item data
            if item_type == "Books":
                item_data = LITERATURE_DATA["books"][category][title]
            elif item_type == "Scrolls":
                item_data = LITERATURE_DATA["scrolls"][category][title]
            elif item_type == "Notes":
                item_data = LITERATURE_DATA["notes"][category][title]
            else:
                continue

            status = "Read" if item_id in read else "Unread"

            owned_items.append({
                "title": title,
                "type": item_type,
                "category": category,
                "data": item_data,
                "status": status,
                "item_id": item_id,
                "rarity": item_data.get("rarity", "Common")
            })
        except (ValueError, KeyError):
            continue

    # Sort alphabetically and take the last 5 (as if they were most recent)
    owned_items.sort(key=lambda x: x["title"])
    recent_items = owned_items[-5:] if len(owned_items) > 5 else owned_items

    if recent_items:
        print_colored("\nYour most recent acquisitions:", CYAN)

        for item in recent_items:
            title = item["data"].get("title", "Unknown")
            rarity = item["rarity"]

            # Get appropriate colors
            rarity_colors = {
                "Common": WHITE,
                "Uncommon": GREEN,
                "Rare": BLUE,
                "Epic": MAGENTA,
                "Legendary": YELLOW
            }
            rarity_color = rarity_colors.get(rarity, WHITE)
            status_color = GREEN if item["status"] == "Read" else YELLOW

            print_colored(f"  {title} ({rarity_color}{rarity}{ENDC})", WHITE)
            print_colored(f"    Type: {item['type']} | Category: {item['category']}", BLUE)
            print_colored(f"    Status: {status_color}{item['status']}{ENDC}", WHITE)
    else:
        print_colored("You don't own any literature yet.", YELLOW)

def search_collection(discovered: Dict[str, Any], owned: Dict[str, Any], read: Dict[str, Any]) -> None:
    """Search for specific literature in your collection"""
    clear_screen()
    print_header("Search Literature Collection")

    search_term = input(f"{YELLOW}Enter search term: {ENDC}").strip().lower()

    if not search_term:
        print_colored("Search canceled.", YELLOW)
        return

    # Search for items matching the term
    matches = []

    all_items = list(set(list(discovered.keys()) + list(owned.keys())))
    for item_id in all_items:
        try:
            item_type, category, title = item_id.split(":", 2)

            # Get item data
            if item_type == "Books":
                item_data = LITERATURE_DATA["books"][category][title]
            elif item_type == "Scrolls":
                item_data = LITERATURE_DATA["scrolls"][category][title]
            elif item_type == "Notes":
                item_data = LITERATURE_DATA["notes"][category][title]
            else:
                continue

            # Check for matches in title, description, or content
            found = False
            title_text = item_data.get("title", "").lower()
            description = item_data.get("description", "").lower()

            if search_term in title_text or search_term in description:
                found = True
            else:
                # Check content (which could be string or list)
                content = item_data.get("content", "")
                if isinstance(content, str) and search_term in content.lower():
                    found = True
                elif isinstance(content, list):
                    # Check each section in the content
                    for section in content:
                        if isinstance(section, str) and search_term in section.lower():
                            found = True
                            break

            if found:
                status = "Read" if item_id in read else "Unread"
                ownership = "Owned" if item_id in owned else "Discovered"

                matches.append({
                    "title": title,
                    "type": item_type,
                    "category": category,
                    "data": item_data,
                    "status": status,
                    "ownership": ownership,
                    "item_id": item_id,
                    "rarity": item_data.get("rarity", "Common")
                })
        except (ValueError, KeyError):
            continue

    # Display search results
    clear_screen()
    print_header("Search Results")

    if not matches:
        print_colored(f"No literature found matching '{search_term}'.", YELLOW)
        return

    print_colored(f"Found {len(matches)} items matching '{search_term}':", CYAN)

    # Sort by type then title
    matches.sort(key=lambda x: (x["type"], x["category"], x["title"]))

    # Group by type for better organization
    results_by_type = {}
    for item in matches:
        item_type = item["type"]
        if item_type not in results_by_type:
            results_by_type[item_type] = []
        results_by_type[item_type].append(item)

    for item_type, items in results_by_type.items():
        print_colored(f"\n{item_type}", CYAN + BOLD)

        # Group by category
        items_by_category = {}
        for item in items:
            category = item["category"]
            if category not in items_by_category:
                items_by_category[category] = []
            items_by_category[category].append(item)

        for category, cat_items in items_by_category.items():
            print_colored(f"  {category}", BLUE + BOLD)

            for item in cat_items:
                title = item["data"].get("title", "Unknown")
                rarity = item["rarity"]

                # Get appropriate colors
                rarity_colors = {
                    "Common": WHITE,
                    "Uncommon": GREEN,
                    "Rare": BLUE,
                    "Epic": MAGENTA,
                    "Legendary": YELLOW
                }
                rarity_color = rarity_colors.get(rarity, WHITE)
                status_color = GREEN if item["status"] == "Read" else YELLOW

                print_colored(f"    {title} ({rarity_color}{rarity}{ENDC})", WHITE)
                print_colored(f"      Status: {status_color}{item['status']}{ENDC} | {item['ownership']}", WHITE)

                # Display a snippet that contains the search term
                description = item["data"].get("description", "")
                if search_term in description.lower():
                    # Show snippet around the match
                    pos = description.lower().find(search_term)
                    start = max(0, pos - 20)
                    end = min(len(description), pos + len(search_term) + 20)

                    # Add ellipsis if snippet doesn't include beginning/end
                    prefix = "..." if start > 0 else ""
                    suffix = "..." if end < len(description) else ""

                    snippet = prefix + description[start:end] + suffix
                    # Highlight the search term
                    highlighted = snippet.replace(search_term, f"{CYAN}{search_term}{ENDC}")
                    print_colored(f"      \"{highlighted}\"", WHITE)

def view_collection_stats(discovered: Dict[str, Any], owned: Dict[str, Any], read: Dict[str, Any]) -> None:
    """View detailed statistics about your literature collection"""
    clear_screen()
    print_header("Literature Collection Statistics")

    if not discovered:
        print_colored("You haven't discovered any literature yet.", YELLOW)
        return

    # Calculate statistics
    total_discovered = len(discovered)
    total_owned = len(owned)
    total_read = len(read)

    # Collection percentages
    owned_percent = int((total_owned / total_discovered) * 100)
    read_percent = int((total_read / max(total_owned, 1)) * 100)

    print_colored("Overall Collection", BLUE + BOLD)
    print_colored(f"  Discovered: {total_discovered} items", CYAN)
    print_colored(f"  Owned: {total_owned} items ({owned_percent}% of discovered)", CYAN)
    print_colored(f"  Read: {total_read} items ({read_percent}% of owned)", CYAN)

    # Count by type
    types = {"Books": 0, "Scrolls": 0, "Notes": 0}
    owned_by_type = {"Books": 0, "Scrolls": 0, "Notes": 0}
    read_by_type = {"Books": 0, "Scrolls": 0, "Notes": 0}

    for item_id in discovered:
        try:
            item_type, _, _ = item_id.split(":", 2)
            if item_type in types:
                types[item_type] += 1

                if item_id in owned:
                    owned_by_type[item_type] += 1

                    if item_id in read:
                        read_by_type[item_type] += 1
        except ValueError:
            continue

    print_colored("\nCollection by Type", BLUE + BOLD)
    for item_type, count in types.items():
        if count > 0:
            owned_count = owned_by_type[item_type]
            read_count = read_by_type[item_type]
            owned_percent = int((owned_count / count) * 100)
            read_percent = int((read_count / max(owned_count, 1)) * 100)

            print_colored(f"  {item_type}:", CYAN)
            print_colored(f"    Discovered: {count} items", WHITE)
            print_colored(f"    Owned: {owned_count} items ({owned_percent}%)", WHITE)
            print_colored(f"    Read: {read_count} items ({read_percent}% of owned)", WHITE)

    # Count by rarity
    rarities = {"Common": 0, "Uncommon": 0, "Rare": 0, "Epic": 0, "Legendary": 0}
    owned_by_rarity = {"Common": 0, "Uncommon": 0, "Rare": 0, "Epic": 0, "Legendary": 0}

    for item_id in discovered:
        try:
            item_type, category, title = item_id.split(":", 2)

            # Get item data
            if item_type == "Books":
                item_data = LITERATURE_DATA["books"][category][title]
            elif item_type == "Scrolls":
                item_data = LITERATURE_DATA["scrolls"][category][title]
            elif item_type == "Notes":
                item_data = LITERATURE_DATA["notes"][category][title]
            else:
                continue

            rarity = item_data.get("rarity", "Common")
            if rarity in rarities:
                rarities[rarity] += 1

                if item_id in owned:
                    owned_by_rarity[rarity] += 1
        except (ValueError, KeyError):
            continue

    print_colored("\nCollection by Rarity", BLUE + BOLD)
    # Rarity colors
    rarity_colors = {
        "Common": WHITE,
        "Uncommon": GREEN,
        "Rare": BLUE,
        "Epic": MAGENTA,
        "Legendary": YELLOW
    }

    for rarity, count in rarities.items():
        if count > 0:
            owned_count = owned_by_rarity[rarity]
            owned_percent = int((owned_count / count) * 100)
            rarity_color = rarity_colors.get(rarity, WHITE)

            print_colored(f"  {rarity_color}{rarity}{ENDC}:", CYAN)
            print_colored(f"    Discovered: {count} items", WHITE)
            print_colored(f"    Owned: {owned_count} items ({owned_percent}%)", WHITE)

    # Categories with most items
    categories = {}

    for item_id in discovered:
        try:
            _, category, _ = item_id.split(":", 2)
            if category not in categories:
                categories[category] = 0
            categories[category] += 1
        except ValueError:
            continue

    print_colored("\nTop Categories", BLUE + BOLD)
    sorted_categories = sorted(categories.items(), key=lambda x: x[1], reverse=True)
    for i, (category, count) in enumerate(sorted_categories[:5], 1):
        print_colored(f"  {i}. {category}: {count} items", CYAN)

def read_literature() -> None:
    """Read a book, scroll, or note from your collection with enhanced user experience"""
    lit_data = user_data.get("literature", {})
    owned = lit_data.get("owned", [])

    if not owned:
        print_colored("You don't own any literature to read.", YELLOW)
        print_colored("Explore the world to find and collect books and scrolls!", CYAN)
        print_colored("Hint: Try visiting libraries, archives, or special locations.", CYAN)
        wait_for_input()
        return

    print_header("Your Literary Collection")

    # Get all readable items and their data
    readable_items = get_readable_items(owned)

    # Filter and sort options - initial view shows all items
    filtered_items = readable_items
    while True:
        # Use print statements and newlines instead of clear_screen for compatibility
        print("\n" * 50)
        print_header("Your Literary Collection")
        print_colored(f"You have {len(readable_items)} items in your collection.", CYAN)

        # Create a menu of filter options
        print_colored("Filter options:", BLUE)
        print_colored("1. All Items", WHITE)
        print_colored("2. Books Only", WHITE)
        print_colored("3. Scrolls Only", WHITE)
        print_colored("4. Notes Only", WHITE)
        print_colored("5. Unread Items", YELLOW)
        print_colored("6. Read Items", GREEN)
        print_colored("7. Sort by Name", WHITE)
        print_colored("8. Sort by Rarity", WHITE)
        print_colored("9. Read an Item", GREEN + BOLD)
        print_colored("0. Back to Menu", RED)

        try:
            choice = input(f"\n{YELLOW}Choose an option (0-9): {ENDC}")

            if choice == "0":
                return
            elif choice == "1":
                # Show all items
                filtered_items = readable_items
            elif choice == "2":
                # Show only books
                filtered_items = [item for item in readable_items if item["type"] == "Books"]
            elif choice == "3":
                # Show only scrolls
                filtered_items = [item for item in readable_items if item["type"] == "Scrolls"]
            elif choice == "4":
                # Show only notes
                filtered_items = [item for item in readable_items if item["type"] == "Notes"]
            elif choice == "5":
                # Show only unread items
                filtered_items = [item for item in readable_items if not item["read"]]
            elif choice == "6":
                # Show only read items
                filtered_items = [item for item in readable_items if item["read"]]
            elif choice == "7":
                # Sort by name
                filtered_items.sort(key=lambda x: x["title"])
            elif choice == "8":
                # Sort by rarity
                rarity_order = {"Common": 0, "Uncommon": 1, "Rare": 2, "Epic": 3, "Legendary": 4}
                filtered_items.sort(key=lambda x: (
                    rarity_order.get(x["data"].get("rarity", "Common"), 0),
                    x["title"]
                ), reverse=True)
            elif choice == "9":
                # Read an item
                choose_and_read_item(filtered_items, lit_data)
                # Refresh the list after reading
                readable_items = get_readable_items(owned)
                filtered_items = readable_items
                continue
            else:
                print_colored("Invalid option.", RED)
                wait_for_input()
                continue

            # Display the filtered/sorted items
            print("\n" * 50)
            print_header("Your Literary Collection")

            if not filtered_items:
                print_colored("No items match your filter criteria.", YELLOW)
                wait_for_input()
                continue

            # Show the filtered items
            print_colored(f"Showing {len(filtered_items)} items:", CYAN)
            for i, item in enumerate(filtered_items, 1):
                title = item["data"].get("title", "Unknown")
                item_type = item["type"][:-1]  # Remove 's' from end (Books -> Book)
                read_status = "(Read)" if item["read"] else "(Unread)"
                status_color = GREEN if item["read"] else YELLOW
                rarity = item["data"].get("rarity", "Common")

                print_colored(f"{i}. {title}", WHITE)
                print_colored(f"   Type: {item_type} | {rarity} | {read_status}", status_color)

            wait_for_input()

        except ValueError:
            print_colored("Please enter a valid number.", RED)
            wait_for_input()

def get_readable_items(owned_items: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Helper function to get all readable items with their data"""
    lit_data = user_data.get("literature", {})
    readable_items = []

    for item_id in owned_items:
        try:
            item_type, category, title = item_id.split(":", 2)

            # Get item data based on type
            if item_type == "Books":
                item_data = LITERATURE_DATA["books"][category][title]
            elif item_type == "Scrolls":
                item_data = LITERATURE_DATA["scrolls"][category][title]
            elif item_type == "Notes":
                item_data = LITERATURE_DATA["notes"][category][title]
            else:
                continue

            readable_items.append({
                "title": title,
                "type": item_type,
                "category": category,
                "data": item_data,
                "item_id": item_id,
                "read": item_id in lit_data.get("read", [])
            })
        except (ValueError, KeyError):
            continue

    # Sort by read status (unread first), then by type and title
    readable_items.sort(key=lambda x: (x["read"], x["type"], x["title"]))
    return readable_items

def choose_and_read_item(items: List[Dict[str, Any]], lit_data: Dict[str, Any]) -> None:
    """Helper function to choose and read a literary item"""
    print("\n" * 50)
    print_header("Choose an Item to Read")

    if not items:
        print_colored("No items available to read.", YELLOW)
        wait_for_input()
        return

    # Display items with numbers
    for i, item in enumerate(items, 1):
        title = item["data"].get("title", "Unknown")
        item_type = item["type"][:-1]  # Remove 's' from end (Books -> Book)
        read_status = "(Read)" if item["read"] else "(Unread)"
        status_color = GREEN if item["read"] else YELLOW

        print_colored(f"{i}. {title} - {item_type} {read_status}", status_color)

    print_colored(f"{len(items)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose something to read (1-{len(items)+1}): {ENDC}"))

        if choice == len(items)+1:
            return

        if 1 <= choice <= len(items):
            selected = items[choice-1]
            print("\n" * 50)
            display_literature_content(selected["item_id"], selected["data"])

            # Mark as read if not already
            if selected["item_id"] not in lit_data.get("read", []):
                if "read" not in lit_data:
                    lit_data["read"] = []
                lit_data["read"].append(selected["item_id"])

                # Apply effects when read for the first time
                apply_literature_effect(selected["item_id"], selected["data"])
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def display_literature_content(item_id: str, item_data: Dict) -> None:
    """Display the content of a book, scroll, or note in a reader-friendly format"""
    item_type, category, title = item_id.split(":", 2)

    # Prepare title and author section
    title_text = item_data.get("title", "Untitled")
    author = item_data.get("author", "Unknown Author")
    if author:
        title_display = f"{title_text}\nby {author}"
    else:
        title_display = title_text

    print_header(title_display)

    # Display item description
    description = item_data.get("description", "")
    if description:
        print_colored(description, CYAN)
        print()

    # Display content based on format
    content = item_data.get("content", "")
    if isinstance(content, list):
        # Chapter/section format
        for section in content:
            # Detect if this is a chapter/section header
            if len(section) < 100 and not section.endswith('.'):
                print_colored(section, YELLOW + BOLD)
            else:
                # Wrap and print normal paragraphs
                wrapped_text = textwrap.fill(section, width=80)
                print_colored(wrapped_text, WHITE)
            print()
    elif isinstance(content, str):
        # Single text content
        # Handle line breaks in the content
        paragraphs = content.split('\n')
        for paragraph in paragraphs:
            wrapped_text = textwrap.fill(paragraph, width=80)
            print_colored(wrapped_text, WHITE)
            print()

    # Display item metadata
    print()
    rarity = item_data.get("rarity", "Common")

    # Get rarity color and display
    rarity_color = get_rarity_color(rarity)
    print_colored(f"Rarity: {rarity}", rarity_color)

    # Show effects if they exist
    effect = item_data.get("effect", {})
    if effect:
        effect_type = effect.get("type", "")
        if effect_type:
            print_colored("Special Effect:", GREEN)
            if effect_type == "stat_increase":
                stat = effect.get("stat", "")
                value = effect.get("value", 0)
                print_colored(f"  Increases {stat.replace('_', ' ').title()} by {value}", GREEN)
            elif effect_type == "skill_increase":
                skill = effect.get("skill", "")
                value = effect.get("value", 0)
                print_colored(f"  Increases {skill.replace('_', ' ').title()} by {value}", GREEN)
            elif effect_type == "quest_unlock":
                quest = effect.get("quest", "")
                print_colored(f"  Unlocks the quest: {quest}", GREEN)
            elif effect_type == "area_unlock":
                area = effect.get("area", "")
                print_colored(f"  Reveals the location: {area}", GREEN)
            elif effect_type == "crafting_unlock":
                recipes = effect.get("recipes", [])
                print_colored("  Teaches new recipes:", GREEN)
                for recipe in recipes:
                    print_colored(f"    - {recipe}", CYAN)
            elif effect_type == "one_time_spell":
                print_colored("  One-time use spell", GREEN)
            elif effect_type == "special_ability":
                ability = effect.get("ability", "")
                effect_description = effect.get("description", "")
                print_colored(f"  Grants ability: {ability}", GREEN)
                print_colored(f"  {effect_description}", CYAN)

def search_literature() -> None:
    """Search for literature in the current location"""
    current_location = user_data.get("current_location", "Greenwood Village")

    # Check if searching for literature costs time
    print_colored(f"Searching for literature in {current_location}...", CYAN)
    time.sleep(1)  # Simulate search time

    # Find available literature at this location
    available_items = []

    # Check books
    for category in LITERATURE_DATA.get("books", {}):
        for title, book_data in LITERATURE_DATA["books"][category].items():
            if book_data.get("location", "") == current_location:
                item_id = f"Books:{category}:{title}"
                available_items.append((item_id, book_data))

    # Check scrolls
    for category in LITERATURE_DATA.get("scrolls", {}):
        for title, scroll_data in LITERATURE_DATA["scrolls"][category].items():
            if scroll_data.get("location", "") == current_location:
                item_id = f"Scrolls:{category}:{title}"
                available_items.append((item_id, scroll_data))

    # Check notes
    for category in LITERATURE_DATA.get("notes", {}):
        for title, note_data in LITERATURE_DATA["notes"][category].items():
            if note_data.get("location", "") == current_location:
                item_id = f"Notes:{category}:{title}"
                available_items.append((item_id, note_data))

    if not available_items:
        print_colored(f"You didn't find any literature in {current_location}.", YELLOW)
        print_colored("Try searching in different locations!", CYAN)
        wait_for_input()
        return

    # Found some literature
    print_colored(f"You found {len(available_items)} items in {current_location}!", GREEN)

    lit_data = user_data.get("literature", {})
    discovered = lit_data.get("discovered", [])
    owned = lit_data.get("owned", [])

    for item_id, item_data in available_items:
        title = item_data.get("title", "Unknown")

        if item_id in owned:
            print_colored(f"You already own: {title}", BLUE)
        elif item_id in discovered:
            # Option to collect the item
            print_colored(f"You've seen this before: {title}", YELLOW)
            if input(f"{YELLOW}Do you want to collect it? (y/n): {ENDC}").lower() == 'y':
                if "owned" not in lit_data:
                    lit_data["owned"] = []
                lit_data["owned"].append(item_id)
                print_colored(f"Added {title} to your collection!", GREEN)
        else:
            # New discovery
            if "discovered" not in lit_data:
                lit_data["discovered"] = []
            lit_data["discovered"].append(item_id)

            rarity = item_data.get("rarity", "Common")

            # Use the get_rarity_color function for consistent coloring
            print_colored(f"You discovered: {title} ({rarity})", GREEN)
            print_colored(f"Description: {item_data.get('description', '')}", CYAN)

            # Option to collect the item
            if input(f"{YELLOW}Do you want to collect it? (y/n): {ENDC}").lower() == 'y':
                if "owned" not in lit_data:
                    lit_data["owned"] = []
                lit_data["owned"].append(item_id)
                print_colored(f"Added {title} to your collection!", GREEN)

    wait_for_input()

def apply_literature_effect(item_id: str, item_data: Dict) -> None:
    """Apply the effect of reading a piece of literature for the first time"""
    effect = item_data.get("effect", {})
    if not effect:
        return

    effect_type = effect.get("type", "")
    if not effect_type:
        return

    title = item_data.get("title", "Unknown")
    print_colored(f"\nGained effect from reading {title}:", GREEN + BOLD)

    # Check if this literature unlocks any quests from the literature quest system
    check_literature_quest_unlocks(item_id)

    if effect_type == "stat_increase":
        stat = effect.get("stat", "")
        value = effect.get("value", 0)

        if stat and value > 0:
            if stat not in user_data:
                user_data[stat] = 0
            user_data[stat] += value
            print_colored(f"Your {stat.replace('_', ' ').title()} increased by {value}!", GREEN)

    elif effect_type == "skill_increase":
        skill = effect.get("skill", "")
        value = effect.get("value", 0)

        if skill and value > 0:
            if "skills" not in user_data:
                user_data["skills"] = {}
            if skill not in user_data["skills"]:
                user_data["skills"][skill] = 0
            user_data["skills"][skill] += value
            print_colored(f"Your {skill.replace('_', ' ').title()} skill increased by {value}!", GREEN)

    elif effect_type == "quest_unlock":
        quest = effect.get("quest", "")

        if quest:
            # Check if this quest is already active or completed
            active_quests = user_data.get("active_quests", [])
            completed_quests = user_data.get("completed_quests", [])

            if quest not in active_quests and quest not in completed_quests:
                # Add quest to active quests
                if "active_quests" not in user_data:
                    user_data["active_quests"] = []
                user_data["active_quests"].append(quest)
                print_colored(f"Unlocked new quest: {quest}!", GREEN)
            else:
                print_colored(f"You've already discovered the quest: {quest}", YELLOW)

    elif effect_type == "area_unlock":
        area = effect.get("area", "")

        if area:
            # Add area to discovered areas if not already there
            if "discovered_areas" not in user_data:
                user_data["discovered_areas"] = []

            if area not in user_data["discovered_areas"]:
                user_data["discovered_areas"].append(area)
                print_colored(f"Discovered new area: {area}!", GREEN)

                # Apply bonus if any
                bonus = effect.get("bonus", "")
                if bonus:
                    print_colored(f"Bonus in this area: {bonus}", CYAN)
            else:
                print_colored(f"You've already discovered the area: {area}", YELLOW)

    elif effect_type == "crafting_unlock":
        recipes = effect.get("recipes", [])

        if recipes:
            if "known_recipes" not in user_data:
                user_data["known_recipes"] = []

            new_recipes = []
            for recipe in recipes:
                if recipe not in user_data["known_recipes"]:
                    user_data["known_recipes"].append(recipe)
                    new_recipes.append(recipe)

            if new_recipes:
                print_colored(f"Learned {len(new_recipes)} new recipes:", GREEN)
                for recipe in new_recipes:
                    print_colored(f"  - {recipe}", CYAN)
            else:
                print_colored("You already know all these recipes.", YELLOW)

    elif effect_type == "one_time_spell":
        # For scrolls that grant a one-time spell
        print_colored("This scroll contains a spell you can use once.", MAGENTA)

        # Add to usable spells
        if "usable_spells" not in user_data:
            user_data["usable_spells"] = []

        spell_data = {
            "name": title,
            "source": item_id,
            "effect": effect
        }
        user_data["usable_spells"].append(spell_data)
        print_colored(f"Added '{title}' to your usable spells.", GREEN)

    elif effect_type == "special_ability":
        ability = effect.get("ability", "")
        description = effect.get("description", "")

        if ability:
            if "abilities" not in user_data:
                user_data["abilities"] = []

            if ability not in user_data["abilities"]:
                user_data["abilities"].append(ability)
                print_colored(f"Gained new ability: {ability}!", GREEN)
                print_colored(f"  {description}", CYAN)
            else:
                print_colored(f"You already have the ability: {ability}", YELLOW)

def check_literature_quest_unlocks(item_id: str) -> None:
    """Check if the given literature item unlocks any quests from the literature quest system"""
    global LITERATURE_QUESTS

    # Check all literature quests
    for quest in LITERATURE_QUESTS:
        # Get literature requirements for this quest
        unlock_requirements = quest.get("unlock_requirements", {})
        required_literature = unlock_requirements.get("literature", [])

        # If this item is required for the quest
        if item_id in required_literature:
            quest_name = quest.get("name", "Unknown Quest")
            quest_id = quest.get("id", "unknown_quest")

            # Check if player meets level requirements
            level_req = quest.get("level_requirement", 1)
            if user_data.get("level", 1) < level_req:
                print_colored(f"You sense there's more to learn about {quest_name}, but it's beyond your current understanding.", YELLOW)
                print_colored(f"(Requires level {level_req})", YELLOW)
                continue

            # Check if quest is already active or completed
            active_quests = user_data.get("active_quests", [])
            completed_quests = user_data.get("completed_quests", [])

            if quest_id in active_quests:
                print_colored(f"You already have the quest: {quest_name}", YELLOW)
            elif quest_id in completed_quests:
                print_colored(f"You've already completed the quest: {quest_name}", YELLOW)
            else:
                # Add quest to active quests
                if "active_quests" not in user_data:
                    user_data["active_quests"] = []
                user_data["active_quests"].append(quest_id)

                print_colored(f"Unlocked new quest: {quest_name}!", GREEN + BOLD)
                print_colored(quest.get("description", ""), CYAN)

                # Add quest details to player's quest log
                if "quest_log" not in user_data:
                    user_data["quest_log"] = {}

                user_data["quest_log"][quest_id] = {
                    "name": quest_name,
                    "description": quest.get("description", ""),
                    "objectives": quest.get("objectives", []),
                    "current_objective": 0,
                    "unlocked_time": user_data.get("current_time", 0),
                    "status": "active"
                }

def view_literature_effects() -> None:
    """View all active effects gained from literature"""
    lit_data = user_data.get("literature", {})
    read = lit_data.get("read", [])

    if not read:
        print_colored("You haven't read any literature yet, so you have no active effects.", YELLOW)
        print_colored("Find books and scrolls to gain knowledge and special abilities!", CYAN)
        wait_for_input()
        return

    print_header("Literature Effects")

    active_effects = []
    for item_id in read:
        try:
            item_type, category, title = item_id.split(":", 2)

            # Get item data
            if item_type == "Books":
                item_data = LITERATURE_DATA["books"][category][title]
            elif item_type == "Scrolls":
                item_data = LITERATURE_DATA["scrolls"][category][title]
            elif item_type == "Notes":
                item_data = LITERATURE_DATA["notes"][category][title]
            else:
                continue

            # Get effect data
            effect = item_data.get("effect", {})
            if effect:
                active_effects.append({
                    "title": item_data.get("title", "Unknown"),
                    "type": item_type[:-1],  # Remove 's' from end (Books -> Book)
                    "effect": effect
                })
        except (ValueError, KeyError):
            continue

    if not active_effects:
        print_colored("None of the literature you've read has granted any special effects.", YELLOW)
        wait_for_input()
        return

    # Group effects by type
    effect_types = {
        "stat_increase": "Stat Increases",
        "skill_increase": "Skill Increases",
        "quest_unlock": "Unlocked Quests",
        "area_unlock": "Discovered Areas",
        "crafting_unlock": "Learned Recipes",
        "one_time_spell": "Usable Spells",
        "special_ability": "Special Abilities"
    }

    for effect_type, type_name in effect_types.items():
        # Filter effects by type
        filtered_effects = [e for e in active_effects if e["effect"].get("type") == effect_type]

        if filtered_effects:
            print_colored(f"{type_name}:", CYAN + BOLD)

            for effect_data in filtered_effects:
                title = effect_data["title"]
                effect = effect_data["effect"]

                if effect_type == "stat_increase":
                    stat = effect.get("stat", "")
                    value = effect.get("value", 0)
                    print_colored(f"  {title}: +{value} {stat.replace('_', ' ').title()}", GREEN)

                elif effect_type == "skill_increase":
                    skill = effect.get("skill", "")
                    value = effect.get("value", 0)
                    print_colored(f"  {title}: +{value} {skill.replace('_', ' ').title()}", GREEN)

                elif effect_type == "quest_unlock":
                    quest = effect.get("quest", "")
                    print_colored(f"  {title}: Unlocked '{quest}'", GREEN)

                elif effect_type == "area_unlock":
                    area = effect.get("area", "")
                    bonus = effect.get("bonus", "")
                    if bonus:
                        print_colored(f"  {title}: Discovered '{area}' (Bonus: {bonus})", GREEN)
                    else:
                        print_colored(f"  {title}: Discovered '{area}'", GREEN)

                elif effect_type == "crafting_unlock":
                    recipes = effect.get("recipes", [])
                    print_colored(f"  {title}: Learned {len(recipes)} recipes", GREEN)

                elif effect_type == "one_time_spell":
                    # Check if spell has been used
                    used = False
                    for spell in user_data.get("usable_spells", []):
                        if spell.get("name") == title:
                            used = False
                            break

                    status = "Available" if not used else "Used"
                    status_color = GREEN if not used else YELLOW
                    print_colored(f"  {title}: One-time spell ({status})", status_color)

                elif effect_type == "special_ability":
                    ability = effect.get("ability", "")
                    print_colored(f"  {title}: Ability '{ability}'", GREEN)

            print()  # Add space between sections

    wait_for_input()

def show_help() -> None:
    help_text = """
LEGACIES OF OUR LEGENDS - COMMANDS

PROGRESS
/start            - Starter guide
/areas             - Area guides
/dungeons          - Dungeon guides
/timetravel        - Time travel guide
/coolness          - Info about coolness
/story             - Show storyline progress
/archaeology       - Discover ancient ruins and artifacts
/library           - Manage your literature collection
/books            - Show your book collection
/read             - Read books from your collection
/search_books     - Search for books in your current location
/gacha            - Character wish system (collect unique characters)
/wish             - Same as /gacha command
/characters       - View your character collection

CRAFTING
/craft             - Recipes calculator
/dismantle         - Dismantling calculator
/invcalc           - Inventory calculator
/drops             - Monster drops
/enchants          - Enchantments info

ITEMS
/equip <item>      - Equip an item from inventory
/inspect <item>    - Inspect an item's special properties
/upgrade           - Upgrade weapons and armor to increase their stats
/enchant           - Apply enchantments to weapons and armor
/chest <tier>      - Open a treasure chest (Common, Uncommon, Rare, Epic, Legendary)
/use <potion>      - Use a potion from your inventory

PETS
/pet               - Pets guide

TRADING
/trading           - Trading guide

PROFESSIONS
/professions       - Professions guide
/prof_system       - Professions system

GUILD
/guild             - Guild guide

EVENTS
/events            - Event guides

MONSTERS
/mobs [area]       - Monsters in [area]
/dailymob          - Today's monster
/fight [monster]   - Fight a monster
/dungeon [name]    - Enter a dungeon
/dungeon_list      - List all dungeons
/bestiary          - List all monsters

GAMBLING
/gambling          - Gambling guide

DIMENSIONS
/dimensions        - Travel between dimensions
/dim               - Shortcut for dimensions travel
/find_key          - Search for dimension keys
/return_home       - Emergency return to Overworld

CAMP
/camp              - Manage your home camp
/camp_build        - Build or upgrade camp structures
/camp_repair       - Repair damaged structures
/camp_use          - Use a camp structure for benefits
/camp_demolish     - Remove existing structures
/camp_info         - View information about structures

WEATHER & SEASONS
/weather           - Show current weather conditions
/season            - Display current season information

MISC
/codes             - Redeemable codes
/duel              - Duel info
/farm              - Farming guide
/tip               - Random tip
/shop              - Visit the shop
/equip [item]      - Equip an item
/stats             - Show your stats
/support           - Support information
/save              - Save game
/load              - Load game
/quests            - View and accept quests
/new               - Create a new character
/inventory         - Show your inventory

SETTINGS
/settings          - Your settings
/setprogress       - Change progress
/prefix            - Show prefix
/exit              - Exit game
/gather            - Gather materials
/materials         - Show materials
/travel            - Travel to area
"""

    for line in help_text.strip().split("\n"):
        stripped = line.strip()
        if stripped.isupper() and len(stripped) > 0:
            print_colored(stripped, MAGENTA)
        elif stripped.startswith("/"):
            print_colored(stripped, CYAN)
        else:
            print(stripped)

# Function to handle commands
def show_location() -> None:
    print_header("Current Location")
    current = user_data["current_area"]
    print_animated(f"You are currently in: {current}")
    if current in LOCATIONS:
        print_animated(f"Description: {LOCATIONS[current]['description']}")

# Function to inspect items (especially legendary items)
def inspect_item(item_name: str) -> None:
    """Inspect an item to see its special properties and effects"""
    print_header("Item Inspection")

    if not item_name:
        print_colored("Please specify an item to inspect.", WARNING)
        return

    # Check if item is in inventory
    if item_name not in user_data["inventory"]:
        print_colored(f"You don't have '{item_name}' in your inventory.", FAIL)
        return

    # Check if item is a legendary item
    if item_name in LEGENDARY_ITEMS:
        item = LEGENDARY_ITEMS[item_name]
        print_colored("✧・゚: *✧・゚:* LEGENDARY ITEM *:・゚✧*:・゚✧", MAGENTA)
        print_colored(f"Name: {item_name}", CYAN)
        print(f"Type: {item['type'].capitalize()}")
        print(f"Effect: +{item['effect']} {item['type']} {'damage' if item['type'] == 'weapon' else 'defense'}")
        print_colored(f"Special Ability: {item['special_ability']}", OKGREEN)
        print(f"Description: {item['description']}")

        # Show special note based on item type
        if item['type'] == 'weapon':
            print_colored("\nThis legendary weapon can be equipped to drastically increase your attack.", YELLOW)
        elif item['type'] == 'armor':
            print_colored("\nThis legendary armor can be equipped to drastically increase your defense.", YELLOW)
        elif item['type'] == 'accessory':
            print_colored("\nThis legendary accessory grants special abilities when carried in your inventory.", YELLOW)

    # Check if item is a weapon
    elif item_name in WEAPONS:
        weapon = WEAPONS[item_name]
        print_colored("WEAPON", CYAN)
        print(f"Name: {item_name}")
        print(f"Damage: {weapon['damage']}")
        print(f"Speed: {weapon['speed']}")
        print(f"Price: {weapon['price']} gold")
        if 'effect' in weapon:
            print_colored(f"Special Effect: {weapon['effect']}", OKGREEN)

    # Otherwise it's a regular item
    else:
        print(f"Item: {item_name}")

        # Check for item types based on name patterns
        if "Potion" in item_name:
            print("Type: Consumable")
            if "Health" in item_name:
                print("Effect: Restores health when used")
            elif "Mana" in item_name:
                print("Effect: Restores mana when used")
        elif any(armor_type in item_name for armor_type in ["Armor", "Shield", "Helmet", "Boots"]):
            print("Type: Armor")
            print("Effect: Increases defense when equipped")
        else:
            print("Type: Miscellaneous item")
            print("This appears to be a regular item with no special properties.")

# Elemental System
ELEMENTS = {
    "Ignis": {
        "name": "Ignis",
        "description": "The element of fire, capable of burning and dealing damage over time.",
        "color": Fore.RED + Style.BRIGHT,  # LIGHTRED
        "weakness": ["Aqua", "Gē"],
        "strength": ["Glacies", "Aer", "Pneuma"],
        "damage_type": "elemental"
    },
    "Aqua": {
        "name": "Aqua",
        "description": "The element of water, versatile and adaptive, weakens fire.",
        "color": Fore.BLUE,  # Blue
        "weakness": ["Fulmen", "Glacies"],
        "strength": ["Ignis", "Venēnum"],
        "damage_type": "elemental"
    },
    "Gē": {
        "name": "Gē",
        "description": "The element of earth, sturdy and grounding, absorbs electricity.",
        "color": Fore.YELLOW,  # Yellow/Brown
        "weakness": ["Aer", "Ferrum"],
        "strength": ["Fulmen", "Ignis"],
        "damage_type": "elemental"
    },
    "Aer": {
        "name": "Aer",
        "description": "The element of air, swift and evasive, disperses poison.",
        "color": Fore.CYAN,  # Cyan
        "weakness": ["Ignis", "Ferrum"],
        "strength": ["Gē", "Venēnum"],
        "damage_type": "elemental"
    },
    "Fulmen": {
        "name": "Fulmen",
        "description": "The element of lightning, delivering swift, powerful strikes.",
        "color": Fore.MAGENTA,  # Magenta
        "weakness": ["Gē", "Ferrum"],
        "strength": ["Aqua", "Aer"],
        "damage_type": "elemental"
    },
    "Glacies": {
        "name": "Glacies",
        "description": "The element of ice, freezing and slowing opponents.",
        "color": Fore.CYAN + Style.BRIGHT,  # Light Cyan
        "weakness": ["Ignis", "Ferrum"],
        "strength": ["Aqua", "Aer"],
        "damage_type": "elemental"
    },
    "Lux": {
        "name": "Lux",
        "description": "The element of light, purifying and revealing the hidden.",
        "color": Fore.WHITE + Style.BRIGHT,  # White
        "weakness": ["Tenebrae"],
        "strength": ["Tenebrae", "Pneuma"],
        "damage_type": "elemental"
    },
    "Tenebrae": {
        "name": "Tenebrae",
        "description": "The element of darkness, corrupting and concealing.",
        "color": Fore.BLACK + Style.DIM,  # Dark Gray
        "weakness": ["Lux"],
        "strength": ["Lux", "Pneuma"],
        "damage_type": "elemental"
    },
    "Venēnum": {
        "name": "Venēnum",
        "description": "The element of poison, inflicting toxins and weakening foes.",
        "color": Fore.GREEN,  # Green
        "weakness": ["Aqua", "Aer"],
        "strength": ["Gē", "Ferrum"],
        "damage_type": "elemental"
    },
    "Ferrum": {
        "name": "Ferrum",
        "description": "The element of metal, resistant and conductive.",
        "color": Fore.WHITE,  # Light Gray
        "weakness": ["Venēnum", "Fulmen"],
        "strength": ["Glacies", "Aer", "Gē"],
        "damage_type": "elemental"
    },
    "Pneuma": {
        "name": "Pneuma",
        "description": "The element of spirit, affecting the soul and mind.",
        "color": Fore.MAGENTA,  # Purple
        "weakness": ["Lux", "Tenebrae"],
        "strength": ["Venēnum", "Glacies"],
        "damage_type": "elemental"
    },
    "Viridia": {
        "name": "Viridia",
        "description": "The element of plants and nature, with restorative and ensnaring abilities.",
        "color": Fore.GREEN + Style.BRIGHT,  # Bright Green
        "weakness": ["Ignis", "Venēnum"],
        "strength": ["Aqua", "Gē", "Aer"],
        "damage_type": "elemental"
    },
    "Nullum": {
        "name": "Nullum",
        "description": "Non-elemental physical damage that ignores elemental resistances.",
        "color": Style.RESET_ALL,  # Default/White
        "weakness": [],
        "strength": [],
        "damage_type": "physical"
    }
}

# Elemental Reactions
ELEMENTAL_REACTIONS = {
    # Original Reactions
    "Ignis+Aqua": {
        "name": "Fumus",
        "description": "Creates a steam cloud that reduces vision and increases evasion.",
        "effect": {"evasion": 15, "vision": -30, "duration": 5},
        "damage_multiplier": 1.2,
        "damage_type": "elemental"
    },
    "Ignis+Fulmen": {
        "name": "Tempestas",
        "description": "Creates a chain explosion with area effect burn and shock damage.",
        "effect": {"area_damage": True, "burn": 3, "shock": 2, "duration": 5},
        "damage_multiplier": 1.8,
        "damage_type": "elemental"
    },
    "Aqua+Glacies": {
        "name": "Congelatio",
        "description": "Freezes the enemy, immobilizing them for a short duration.",
        "effect": {"immobilize": 2, "duration": 5},
        "damage_multiplier": 1.3,
        "damage_type": "elemental"
    },
    "Aqua+Venēnum": {
        "name": "Dilutio",
        "description": "Creates a toxic mist that poisons all enemies in an area.",
        "effect": {"area_damage": True, "poison": 4, "duration": 5},
        "damage_multiplier": 1.5,
        "damage_type": "elemental"
    },
    "Gē+Ferrum": {
        "name": "Arma",
        "description": "Temporarily raises defense or spawns protective armor.",
        "effect": {"defense": 30, "duration": 3},
        "damage_multiplier": 1.0,
        "damage_type": "physical"
    },
    "Aer+Fulmen": {
        "name": "Tonitrus",
        "description": "Creates a thunderstorm that strikes multiple foes.",
        "effect": {"multi_target": True, "shock": 3, "duration": 5},
        "damage_multiplier": 1.6,
        "damage_type": "elemental"
    },
    "Lux+Tenebrae": {
        "name": "Umbra",
        "description": "Creates an eclipse effect causing area blindness or HP drain.",
        "effect": {"area_damage": True, "blind": 2, "drain": 5, "duration": 5},
        "damage_multiplier": 1.7,
        "damage_type": "elemental"
    },
    "Lux+Pneuma": {
        "name": "Divinum",
        "description": "Bestows a holy blessing that heals and cleanses allies.",
        "effect": {"heal": 40, "cleanse": True, "duration": 5},
        "damage_multiplier": 1.0,
        "damage_type": "elemental"
    },
    "Tenebrae+Venēnum": {
        "name": "Maleficium",
        "description": "Inflicts a curse causing damage over time and debuffs.",
        "effect": {"dot": 5, "attack": -15, "defense": -15, "duration": 5},
        "damage_multiplier": 1.4,
        "damage_type": "elemental"
    },
    "Ferrum+Fulmen": {
        "name": "Magnetismus",
        "description": "Creates a magnetic field that pulls enemies together.",
        "effect": {"pull": True, "range": 3, "duration": 5},
        "damage_multiplier": 1.2,
        "damage_type": "elemental"
    },
    "Glacies+Pneuma": {
        "name": "Frigus Animae",
        "description": "Freezes the soul, slowing enemies and lowering spirit regeneration.",
        "effect": {"slow": 30, "mana_regen": -50, "duration": 5},
        "damage_multiplier": 1.3,
        "damage_type": "elemental"
    },
    "Aer+Aqua": {
        "name": "Nebula",
        "description": "Creates a fog that increases dodge rate and conceals allies.",
        "effect": {"dodge": 25, "stealth": True, "duration": 5},
        "damage_multiplier": 1.0,
        "damage_type": "elemental"
    },
    "Gē+Venēnum": {
        "name": "Miasma",
        "description": "Creates a toxic zone on the ground that damages over time.",
        "effect": {"area_damage": True, "poison": 3, "movement": -20, "duration": 5},
        "damage_multiplier": 1.4,
        "damage_type": "elemental"
    },

    # New Reactions with Viridia
    "Viridia+Ignis": {
        "name": "Combustio",
        "description": "Plants burst into flames, creating widespread burning damage.",
        "effect": {"area_damage": True, "burn": 5, "duration": 5},
        "damage_multiplier": 1.5,
        "damage_type": "elemental"
    },
    "Viridia+Aqua": {
        "name": "Virescentia",
        "description": "Plants flourish with water, creating a healing zone and boosting attack.",
        "effect": {"healing_zone": True, "heal": 15, "attack": 15, "duration": 5},
        "damage_multiplier": 1.0,
        "damage_type": "elemental"
    },
    "Viridia+Venēnum": {
        "name": "Toxicum",
        "description": "Creates highly toxic plants that release deadly poison.",
        "effect": {"poison": 7, "area_damage": True, "duration": 5},
        "damage_multiplier": 1.7,
        "damage_type": "elemental"
    },
    "Viridia+Aer": {
        "name": "Pollinis",
        "description": "Spreads pollen that causes confusion and mild healing.",
        "effect": {"confusion": True, "heal": 10, "duration": 5},
        "damage_multiplier": 1.2,
        "damage_type": "elemental"
    },
    "Viridia+Gē": {
        "name": "Arbores",
        "description": "Creates massive roots that entangle foes and boost defense.",
        "effect": {"entangle": True, "defense": 20, "duration": 5},
        "damage_multiplier": 1.3,
        "damage_type": "elemental"
    },
    "Viridia+Lux": {
        "name": "Photosynthesis",
        "description": "Plants absorb light energy for massive healing and energy restoration.",
        "effect": {"heal": 30, "energy": 30, "duration": 5},
        "damage_multiplier": 1.0,
        "damage_type": "elemental"
    },

    # Nullum combinations
    "Nullum+Ignis": {
        "name": "Flamma Pura",
        "description": "Physical strike infused with fire, ignoring elemental resistances.",
        "effect": {"pierce_resistance": True, "burn": 2, "duration": 5},
        "damage_multiplier": 1.6,
        "damage_type": "physical"
    },
    "Nullum+Aqua": {
        "name": "Fluctus",
        "description": "Physical force with water pressure, pushing enemies back.",
        "effect": {"knockback": True, "slow": 15, "duration": 5},
        "damage_multiplier": 1.4,
        "damage_type": "physical"
    },
    "Nullum+Fulmen": {
        "name": "Percussum",
        "description": "Electrified physical strike that stuns enemies.",
        "effect": {"stun": 2, "duration": 5},
        "damage_multiplier": 1.5,
        "damage_type": "physical"
    },
    "Nullum+Ferrum": {
        "name": "Acies",
        "description": "Perfect physical strike that increases critical chance.",
        "effect": {"critical_chance": 20, "duration": 5},
        "damage_multiplier": 1.8,
        "damage_type": "physical"
    }
}

# Legendary items with special effects
# Archaeological artifacts system
ARCHAEOLOGICAL_SITES = {
    "Ancient Temple Ruins": {
        "description": "The crumbling remains of a temple dedicated to forgotten gods.",
        "required_level": 10,
        "location": "Deep Forest",
        "artifacts": ["Ceremonial Dagger", "Priest's Medallion", "Stone Tablet", "Ritual Mask", "Temple Key"],
        "difficulty": "Medium",
        "knowledge_reward": "Temple Civilization"
    },
    "Abandoned Mine": {
        "description": "A vast network of tunnels where ancient miners once extracted precious minerals.",
        "required_level": 15,
        "location": "Mountain Range",
        "artifacts": ["Miner's Pickaxe", "Mineral Specimen", "Ancient Lamp", "Ore Sample", "Mining Helmet"],
        "difficulty": "Hard",
        "knowledge_reward": "Mining Techniques"
    },
    "Sunken Palace": {
        "description": "The remains of an opulent palace, now submerged beneath a lake.",
        "required_level": 20,
        "location": "Great Lake",
        "artifacts": ["Royal Scepter", "Crown Jewel", "Throne Fragment", "Royal Seal", "Court Painting"],
        "difficulty": "Very Hard",
        "knowledge_reward": "Lost Dynasty"
    },
    "Celestial Observatory": {
        "description": "An ancient structure used to study the stars and celestial bodies.",
        "required_level": 25,
        "location": "Mountain Peak",
        "artifacts": ["Star Chart", "Telescope Fragment", "Astronomer's Journal", "Celestial Globe", "Moon Calendar"],
        "difficulty": "Expert",
        "knowledge_reward": "Ancient Astronomy"
    },
    "Battlefield Grave Site": {
        "description": "The site of an epic battle where countless warriors fell.",
        "required_level": 5,
        "location": "Open Plains",
        "artifacts": ["Broken Sword", "Rusted Helmet", "War Banner", "Commander's Insignia", "Battle Map"],
        "difficulty": "Easy",
        "knowledge_reward": "Great War"
    }
}

ARCHAEOLOGICAL_ARTIFACTS = {
    "Ceremonial Dagger": {
        "description": "A ritualistic dagger used in ancient ceremonies.",
        "rarity": "Uncommon",
        "set": "Temple Collection",
        "effect": {"ritual_power": 5},
        "value": 150
    },
    "Priest's Medallion": {
        "description": "A symbol of religious authority worn by high priests.",
        "rarity": "Rare",
        "set": "Temple Collection",
        "effect": {"divine_protection": 10},
        "value": 300
    },
    "Stone Tablet": {
        "description": "Contains writings in a forgotten language.",
        "rarity": "Uncommon",
        "set": "Temple Collection",
        "effect": {"ancient_knowledge": 15},
        "value": 200
    },
    "Ritual Mask": {
        "description": "Worn during sacred ceremonies to embody divine beings.",
        "rarity": "Rare",
        "set": "Temple Collection",
        "effect": {"intimidation": 20},
        "value": 350
    },
    "Temple Key": {
        "description": "Likely used to access restricted areas of the temple.",
        "rarity": "Epic",
        "set": "Temple Collection",
        "effect": {"unlock_chance": 25},
        "value": 500
    },
    "Miner's Pickaxe": {
        "description": "A well-preserved tool used by ancient miners.",
        "rarity": "Common",
        "set": "Mining Collection",
        "effect": {"mining_efficiency": 10},
        "value": 100
    },
    "Mineral Specimen": {
        "description": "A rare mineral not found in modern mines.",
        "rarity": "Uncommon",
        "set": "Mining Collection",
        "effect": {"gem_finding": 15},
        "value": 180
    },
    "Ancient Lamp": {
        "description": "Oil lamp used to illuminate the dark mine tunnels.",
        "rarity": "Common",
        "set": "Mining Collection",
        "effect": {"darkness_vision": 5},
        "value": 80
    },
    "Ore Sample": {
        "description": "Contains traces of a metal unknown to modern metallurgy.",
        "rarity": "Rare",
        "set": "Mining Collection",
        "effect": {"crafting_quality": 10},
        "value": 250
    },
    "Mining Helmet": {
        "description": "Protected miners from falling rocks and debris.",
        "rarity": "Uncommon",
        "set": "Mining Collection",
        "effect": {"head_protection": 15},
        "value": 200
    },
    "Royal Scepter": {
        "description": "Symbol of authority carried by the monarch of a lost kingdom.",
        "rarity": "Legendary",
        "set": "Royal Collection",
        "effect": {"command_power": 25},
        "value": 1000
    },
    "Crown Jewel": {
        "description": "A magnificent gemstone that adorned the royal crown.",
        "rarity": "Epic",
        "set": "Royal Collection",
        "effect": {"charisma": 20},
        "value": 800
    },
    "Throne Fragment": {
        "description": "A piece of the royal throne, ornately carved from rare wood.",
        "rarity": "Rare",
        "set": "Royal Collection",
        "effect": {"nobility_aura": 15},
        "value": 400
    },
    "Royal Seal": {
        "description": "Used to authenticate royal decrees and documents.",
        "rarity": "Epic",
        "set": "Royal Collection",
        "effect": {"negotiation_power": 20},
        "value": 600
    },
    "Court Painting": {
        "description": "Depicts the royal court during its golden age.",
        "rarity": "Rare",
        "set": "Royal Collection",
        "effect": {"historical_insight": 15},
        "value": 350
    }
}

ANCIENT_KNOWLEDGE = {
    "Temple Civilization": {
        "description": "Knowledge about an advanced civilization that built elaborate temples to their gods.",
        "stat_bonus": {"wisdom": 10, "divine_resistance": 15},
        "unlocks": ["Temple Meditation", "Divine Insight"]
    },
    "Mining Techniques": {
        "description": "Ancient methods of extracting and processing valuable minerals.",
        "stat_bonus": {"strength": 5, "material_knowledge": 20},
        "unlocks": ["Efficient Gathering", "Gem Cutting"]
    },
    "Lost Dynasty": {
        "description": "The history of a powerful royal lineage that mysteriously vanished.",
        "stat_bonus": {"charisma": 15, "leadership": 10},
        "unlocks": ["Royal Command", "Noble Presence"]
    },
    "Ancient Astronomy": {
        "description": "Early understanding of celestial bodies and their influence.",
        "stat_bonus": {"intelligence": 15, "cosmic_awareness": 20},
        "unlocks": ["Star Navigation", "Cosmic Prediction"]
    },
    "Great War": {
        "description": "Records of an epic conflict that shaped the ancient world.",
        "stat_bonus": {"combat_strategy": 15, "battlefield_awareness": 10},
        "unlocks": ["Battle Formation", "Strategic Retreat"]
    }
}

ARCHAEOLOGICAL_EXCAVATION_TOOLS = {
    "Basic Trowel": {
        "description": "A simple digging tool for careful excavation.",
        "efficiency": 1.0,
        "preservation_chance": 0.8,
        "value": 50
    },
    "Archaeologist's Brush Set": {
        "description": "Fine brushes for cleaning delicate artifacts.",
        "efficiency": 0.8,
        "preservation_chance": 0.95,
        "value": 120
    },
    "Surveying Equipment": {
        "description": "Tools for mapping archaeological sites.",
        "efficiency": 1.2,
        "preservation_chance": 0.85,
        "value": 200
    },
    "Advanced Detector": {
        "description": "Uses magic to detect buried artifacts.",
        "efficiency": 1.5,
        "preservation_chance": 0.9,
        "value": 350
    },
    "Master Excavation Kit": {
        "description": "A complete set of professional tools for archaeological work.",
        "efficiency": 2.0,
        "preservation_chance": 0.98,
        "value": 800
    }
}

# Set bonuses for collecting complete artifact sets
ARCHAEOLOGICAL_SET_BONUSES = {
    "Temple Collection": {
        "name": "Divine Favor",
        "description": "Gain the blessing of ancient gods, increasing magical power.",
        "bonus": {"magic_power": 25, "divine_protection": 15, "ritual_success_rate": 0.2}
    },
    "Mining Collection": {
        "name": "Master Prospector",
        "description": "Enhanced ability to find valuable minerals and gems.",
        "bonus": {"mining_yield": 30, "rare_mineral_chance": 0.25, "cave_navigation": 20}
    },
    "Royal Collection": {
        "name": "Noble Heritage",
        "description": "Command respect and authority like the rulers of old.",
        "bonus": {"charisma": 25, "negotiation_power": 30, "royal_presence": 20}
    },
    "Celestial Collection": {
        "name": "Cosmic Insight",
        "description": "Gain deeper understanding of the stars and their magic.",
        "bonus": {"cosmic_magic": 30, "star_navigation": 25, "celestial_prediction": 0.2}
    },
    "Warrior Collection": {
        "name": "Battle Wisdom",
        "description": "Ancient combat knowledge enhances your fighting abilities.",
        "bonus": {"attack": 20, "defense": 15, "battlefield_awareness": 25}
    }
}

LEGENDARY_ITEMS = {
    "Crown of New Dawn": {
        "type": "armor",
        "effect": 30,
        "special_ability": "Grants 10% chance to resurrect upon death",
        "description": "A legendary crown forged from otherworldly materials, rumored to be blessed by the gods themselves."
    },
    "Dimensional Compass": {
        "type": "accessory",
        "effect": 0,
        "special_ability": "Allows travel to dimensional rifts",
        "description": "A mysterious compass that points to places between worlds."
    },
    "Godforged Artifact": {
        "type": "weapon",
        "effect": 50,
        "special_ability": "Weapon damage scales with your character level",
        "description": "A weapon of divine origin, growing in power as its wielder does."
    },
    "Celestial Aegis": {
        "type": "armor",
        "effect": 40,
        "special_ability": "Reduces all damage by 20%",
        "description": "A shield forged from the scales of a celestial dragon."
    },
    "Timekeeper's Pendant": {
        "type": "accessory",
        "effect": 0,
        "special_ability": "30% chance to perform a double attack",
        "description": "A pendant containing grains of timesand, allowing its wearer to occasionally bend time."
    },
    "Phoenix Plume": {
        "type": "accessory",
        "effect": 0,
        "special_ability": "Auto-resurrect once per dungeon",
        "description": "A feather from the legendary phoenix, pulsing with the essence of rebirth."
    },
    "Worldbreaker": {
        "type": "weapon",
        "effect": 60,
        "special_ability": "10% chance to instantly defeat non-boss enemies",
        "description": "A massive hammer said to have been used to shape the very mountains."
    },
    "Voidwalker Boots": {
        "type": "armor",
        "effect": 20,
        "special_ability": "50% chance to dodge any attack",
        "description": "Boots that phase in and out of reality, making the wearer difficult to hit."
    }
}

# Post-game activity functions
def dimensional_rifts() -> None:
    """Function to handle dimensional rift exploration"""
    print_header("DIMENSIONAL RIFTS")

    if "Dimensional Compass" not in user_data["inventory"]:
        print_colored("You need the 'Dimensional Compass' to navigate the rifts!", WARNING)
        print_colored("Complete the 'Dimensional Rifts' storyline to obtain it.", YELLOW)
        return

    rifts = [
        "Mirror Dimension", 
        "Time Fracture", 
        "Shadow Realm", 
        "Elemental Plane", 
        "Dream World"
    ]

    print_colored("Available rifts:", CYAN)
    for idx, rift in enumerate(rifts, 1):
        print(f"{idx}. {rift}")

    choice = input("\nSelect a rift to explore (1-5) or 'back' to return: ")

    if choice.lower() == "back":
        return
    elif choice.isdigit() and 1 <= int(choice) <= len(rifts):
        selected_rift = rifts[int(choice)-1]
        print_colored(f"Entering the {selected_rift}...", CYAN)
        print_colored("This feature will be expanded in future updates.", YELLOW)

        # Give player a small reward for trying this feature
        reward_gold = random.randint(100, 500)
        user_data["gold"] += reward_gold
        print_colored(f"You found {reward_gold} gold in the rift!", OKGREEN)
    else:
        print_colored("Invalid choice.", FAIL)

# Function to handle dimensions system
def dimensions_menu() -> None:
    """Function to handle dimension traveling and discovery"""
    print_header("DIMENSIONAL TRAVEL")

    print_colored("Current Dimension: ", CYAN, end="")
    print_colored(user_data["current_dimension"], MAGENTA)
    print()

    print_colored("Discovered Dimensions:", CYAN)
    for dim_name in user_data["dimensions_discovered"]:
        if dim_name == user_data["current_dimension"]:
            print_colored(f"  > {dim_name} (Current)", OKGREEN)
        else:
            print_colored(f"  - {dim_name}", LIGHTGRAY)
    print()

    # Check for portal frame
    has_portal = "Portal Frame" in [s for s in user_data["home_structures"] if user_data["home_structures"].get(s, {}).get("built", False)]

    if not has_portal:
        print_colored("You need to build a Portal Frame in your camp to travel between dimensions.", WARNING)
        print_colored("Use /camp_build to construct a Portal Frame.", LIGHTGRAY)
        return

    # Show available dimensions based on discovered keys and level
    print_colored("Available Dimensions for Travel:", CYAN)
    available_dimensions = []

    for dim_name, dim_info in DIMENSIONS.items():
        if dim_name in user_data["dimensions_discovered"]:
            available_dimensions.append(dim_name)
            print_colored(f"  [{len(available_dimensions)}] {dim_name}", OKGREEN)
        elif "unlock_item" in dim_info and dim_info["unlock_item"] in user_data["dimension_keys"]:
            if user_data["level"] >= dim_info["access_level"]:
                available_dimensions.append(dim_name)
                print_colored(f"  [{len(available_dimensions)}] {dim_name}", YELLOW)
            else:
                print_colored(f"  [?] {dim_name} (Requires Level {dim_info['access_level']})", WARNING)
        elif user_data["level"] >= dim_info["access_level"]:
            print_colored(f"  [?] {dim_name} (Requires {dim_info.get('unlock_item', 'Unknown Key')})", WARNING)

    print_colored("  [0] Cancel", LIGHTGRAY)
    print()

    # Get player choice
    choice = input("Select a dimension to travel to (number): ")

    try:
        choice_idx = int(choice)
        if choice_idx == 0:
            print_colored("Dimensional travel canceled.", LIGHTGRAY)
            return

        if 1 <= choice_idx <= len(available_dimensions):
            selected_dimension = available_dimensions[choice_idx - 1]

            if selected_dimension == user_data["current_dimension"]:
                print_colored("You are already in this dimension.", YELLOW)
                return

            # Travel to the dimension
            user_data["current_dimension"] = selected_dimension

            # Add to discovered if not already there
            if selected_dimension not in user_data["dimensions_discovered"]:
                user_data["dimensions_discovered"].append(selected_dimension)
                print_colored(f"You have discovered the {selected_dimension}!", OKGREEN)

            print_colored(f"Traveling to the {selected_dimension}...", CYAN)
            time.sleep(1)
            print_colored(f"You have arrived in the {selected_dimension}!", OKGREEN)

            # Describe the dimension
            if selected_dimension in DIMENSIONS:
                print_colored(DIMENSIONS[selected_dimension]["description"], LIGHTCYAN)
        else:
            print_colored("Invalid choice.", FAIL)
    except ValueError:
        print_colored("Please enter a valid number.", FAIL)

def find_dimension_key() -> None:
    """Find a key to unlock a new dimension"""
    current_dim = user_data["current_dimension"]
    player_level = user_data["level"]

    # Find potential dimensions that could have keys
    potential_keys = []
    for dim_name, dim_info in DIMENSIONS.items():
        if dim_name not in user_data["dimensions_discovered"] and "unlock_item" in dim_info:
            if dim_info["unlock_item"] not in user_data["dimension_keys"] and player_level >= dim_info["access_level"]:
                potential_keys.append((dim_name, dim_info["unlock_item"]))

    if not potential_keys:
        print_colored("You have found all available dimension keys for your current level.", YELLOW)
        return

    # Random chance to find a key based on current dimension and player level
    find_chance = min(0.05 * player_level, 0.5)  # 5% per level, max 50%

    # Exploring other dimensions increases chance
    if current_dim != "Overworld":
        find_chance += 0.2

    if random.random() < find_chance:
        # Found a key
        dim_name, key_name = random.choice(potential_keys)
        user_data["dimension_keys"].append(key_name)
        print_colored(f"You found the {key_name}!", OKGREEN)
        print_colored(f"This key will allow you to access the {dim_name} dimension.", CYAN)
        print_colored("Use /dimensions to travel to new dimensions.", LIGHTGRAY)
    else:
        print_colored("You search for dimensional anomalies but find nothing of interest.", LIGHTGRAY)

def returnToOverworld() -> None:
    """Emergency function to return to the Overworld dimension if stuck"""
    if user_data["current_dimension"] == "Overworld":
        print_colored("You are already in the Overworld.", YELLOW)
        return

    # Return to Overworld
    prev_dimension = user_data["current_dimension"]
    user_data["current_dimension"] = "Overworld"
    print_colored(f"You've escaped from the {prev_dimension} and returned to the Overworld!", OKGREEN)
    print_colored("You find yourself back in familiar territory.", CYAN)

# Function to handle home/camp system
def camp_menu() -> None:
    """Function to handle camp management"""
    print_header("CAMP MANAGEMENT")

    print_colored(f"Current Location: {user_data['home_location']}", CYAN)

    # Show existing structures
    print_colored("\nCurrent Structures:", CYAN)
    if not any(user_data["home_structures"].get(s, {}).get("built", False) for s in user_data["home_structures"]):
        print_colored("  No structures built yet.", LIGHTGRAY)
    else:
        for struct_name, struct_data in user_data["home_structures"].items():
            if struct_data.get("built", False):
                health_percent = struct_data.get("health", 100)
                health_color = OKGREEN if health_percent > 70 else (YELLOW if health_percent > 30 else FAIL)
                print_colored(f"  - {struct_name} ", LIGHTGRAY, end="")
                print_colored(f"[Health: {health_percent}%]", health_color)

    print_colored("\nOptions:", CYAN)
    print_colored("  [1] Build/Upgrade Structure", LIGHTGRAY)
    print_colored("  [2] Repair Structure", LIGHTGRAY)
    print_colored("  [3] Use Structure", LIGHTGRAY)
    print_colored("  [4] Demolish Structure", LIGHTGRAY)
    print_colored("  [5] View Structure Info", LIGHTGRAY)
    print_colored("  [0] Exit", LIGHTGRAY)

    choice = input("\nSelect an option: ")

    if choice == "1":
        build_structure()
    elif choice == "2":
        repair_structure()
    elif choice == "3":
        use_structure()
    elif choice == "4":
        demolish_structure()
    elif choice == "5":
        view_structure_info()
    elif choice == "0":
        return
    else:
        print_colored("Invalid choice.", FAIL)

def build_structure() -> None:
    """Build or upgrade a camp structure"""
    print_header("BUILD/UPGRADE STRUCTURE")

    # Group structures by category
    structures_by_category = {}
    for struct_name, struct_data in HOME_STRUCTURES.items():
        category = struct_data.get("category", "misc")
        if category not in structures_by_category:
            structures_by_category[category] = []
        structures_by_category[category].append((struct_name, struct_data))

    # Filter available structures based on player level and dependencies
    available_structures = []
    for category, structures in structures_by_category.items():
        print_colored(f"\n{category.capitalize()}:", CYAN)
        for struct_name, struct_data in structures:
            # Check if already built
            already_built = user_data["home_structures"].get(struct_name, {}).get("built", False)

            # Check for upgrades
            upgrade_from = struct_data.get("upgrade_from")
            if upgrade_from and not user_data["home_structures"].get(upgrade_from, {}).get("built", False):
                print_colored(f"  [?] {struct_name} (Requires {upgrade_from})", WARNING)
                continue

            # Check for dependencies
            requires = struct_data.get("requires")
            if requires and not user_data["home_structures"].get(requires, {}).get("built", False):
                print_colored(f"  [?] {struct_name} (Requires {requires})", WARNING)
                continue

            # Check level requirement (implicit in structure level)
            if struct_data.get("level", 1) * 5 > user_data["level"]:
                print_colored(f"  [?] {struct_name} (Requires Level {struct_data.get('level', 1) * 5})", WARNING)
                continue

            if already_built:
                if not upgrade_from:  # Can't upgrade a structure that isn't an upgrade
                    print_colored(f"  [B] {struct_name} (Already Built)", OKGREEN)
                    continue
                else:
                    print_colored(f"  [U] {struct_name} (Upgrade from {upgrade_from})", YELLOW)
            else:
                print_colored(f"  [{len(available_structures) + 1}] {struct_name}", LIGHTGRAY)

            # Show required materials
            for material, amount in struct_data.get("materials", {}).items():
                material_owned = user_data.get("materials", {}).get(material, 0)
                color = OKGREEN if material_owned >= amount else FAIL
                print_colored(f"      {material}: {material_owned}/{amount}", color)

            available_structures.append(struct_name)

    if not available_structures:
        print_colored("\nNo structures available to build at your current level.", WARNING)
        return

    print_colored("\n  [0] Cancel", LIGHTGRAY)

    choice = input("\nSelect a structure to build (number): ")

    try:
        choice_idx = int(choice)
        if choice_idx == 0:
            return

        if 1 <= choice_idx <= len(available_structures):
            selected_structure = available_structures[choice_idx - 1]
            struct_data = HOME_STRUCTURES[selected_structure]

            # Check if we have the materials
            materials = struct_data.get("materials", {})
            can_build = True

            for material, amount in materials.items():
                if user_data.get("materials", {}).get(material, 0) < amount:
                    can_build = False
                    print_colored(f"Not enough {material}. Need {amount}.", FAIL)

            if can_build:
                # Deduct materials
                for material, amount in materials.items():
                    user_data["materials"][material] = user_data["materials"].get(material, 0) - amount

                # Add structure to home
                if selected_structure not in user_data["home_structures"]:
                    user_data["home_structures"][selected_structure] = {}

                user_data["home_structures"][selected_structure]["built"] = True
                user_data["home_structures"][selected_structure]["health"] = 100
                user_data["home_structures"][selected_structure]["position"] = [0, 0]  # Simple position

                print_colored(f"Successfully built {selected_structure}!", OKGREEN)

                # Check if this is an upgrade
                upgrade_from = struct_data.get("upgrade_from")
                if upgrade_from:
                    # Remove the previous structure
                    if upgrade_from in user_data["home_structures"]:
                        user_data["home_structures"][upgrade_from]["built"] = False
                    print_colored(f"Upgraded from {upgrade_from} to {selected_structure}!", OKGREEN)
            else:
                print_colored("You don't have enough resources to build this structure.", FAIL)
        else:
            print_colored("Invalid choice.", FAIL)
    except ValueError:
        print_colored("Please enter a valid number.", FAIL)

def repair_structure() -> None:
    """Repair a damaged camp structure"""
    print_header("REPAIR STRUCTURE")

    # Show existing structures with health
    structures_to_repair = []
    print_colored("Structures that need repair:", CYAN)

    for struct_name, struct_data in user_data["home_structures"].items():
        if struct_data.get("built", False) and struct_data.get("health", 100) < 100:
            structures_to_repair.append(struct_name)
            health = struct_data.get("health", 100)
            health_color = YELLOW if health > 50 else FAIL
            print_colored(f"  [{len(structures_to_repair)}] {struct_name} ", LIGHTGRAY, end="")
            print_colored(f"[Health: {health}%]", health_color)

    if not structures_to_repair:
        print_colored("  No structures need repair.", LIGHTGRAY)
        return

    print_colored("  [0] Cancel", LIGHTGRAY)

    choice = input("\nSelect a structure to repair (number): ")

    try:
        choice_idx = int(choice)
        if choice_idx == 0:
            return

        if 1 <= choice_idx <= len(structures_to_repair):
            selected_structure = structures_to_repair[choice_idx - 1]
            current_health = user_data["home_structures"][selected_structure].get("health", 100)

            # Calculate repair materials (25% of original for a full repair)
            original_materials = HOME_STRUCTURES[selected_structure].get("materials", {})
            repair_materials = {}
            repair_percentage = (100 - current_health) / 100

            for material, amount in original_materials.items():
                repair_amount = math.ceil(amount * 0.25 * repair_percentage)
                repair_materials[material] = repair_amount

            # Show repair cost
            print_colored(f"\nRepairing {selected_structure} will cost:", CYAN)
            can_repair = True

            for material, amount in repair_materials.items():
                if amount > 0:
                    material_owned = user_data.get("materials", {}).get(material, 0)
                    color = OKGREEN if material_owned >= amount else FAIL
                    print_colored(f"  {material}: {material_owned}/{amount}", color)
                    if material_owned < amount:
                        can_repair = False

            if can_repair:
                confirm = input("\nProceed with repair? (y/n): ").lower()
                if confirm == 'y':
                    # Deduct materials
                    for material, amount in repair_materials.items():
                        if amount > 0:
                            user_data["materials"][material] = user_data["materials"].get(material, 0) - amount

                    # Repair structure
                    user_data["home_structures"][selected_structure]["health"] = 100
                    print_colored(f"Successfully repaired {selected_structure}!", OKGREEN)
            else:
                print_colored("You don't have enough resources for the repair.", FAIL)
        else:
            print_colored("Invalid choice.", FAIL)
    except ValueError:
        print_colored("Please enter a valid number.", FAIL)

def use_structure() -> None:
    """Use a camp structure and receive its benefits"""
    print_header("USE STRUCTURE")

    # Show existing usable structures
    usable_structures = []
    print_colored("Usable structures:", CYAN)

    for struct_name, struct_data in user_data["home_structures"].items():
        if struct_data.get("built", False) and struct_data.get("health", 0) > 0:
            # Structure must be built and have health
            struct_info = HOME_STRUCTURES.get(struct_name, {})
            if struct_info.get("effects"):
                usable_structures.append(struct_name)
                print_colored(f"  [{len(usable_structures)}] {struct_name}", LIGHTGRAY)

    if not usable_structures:
        print_colored("  No usable structures available.", LIGHTGRAY)
        return

    print_colored("  [0] Cancel", LIGHTGRAY)

    choice = input("\nSelect a structure to use (number): ")

    try:
        choice_idx = int(choice)
        if choice_idx == 0:
            return

        if 1 <= choice_idx <= len(usable_structures):
            selected_structure = usable_structures[choice_idx - 1]
            struct_info = HOME_STRUCTURES.get(selected_structure, {})
            effects = struct_info.get("effects", {})

            # Apply effects based on structure type
            print_colored(f"Using {selected_structure}...", CYAN)

            # Health regeneration
            if "rest_heal" in effects:
                heal_amount = effects["rest_heal"]
                old_health = user_data["health"]
                user_data["health"] = min(user_data["max_health"], user_data["health"] + heal_amount)
                actual_heal = user_data["health"] - old_health
                print_colored(f"You rest and recover {actual_heal} health points!", OKGREEN)

            # Mana regeneration
            if "mana_regen" in effects:
                if "mana" in user_data and "max_mana" in user_data:
                    mana_regen = effects["mana_regen"]
                    old_mana = user_data["mana"]
                    user_data["mana"] = min(user_data["max_mana"], user_data["mana"] + int(user_data["max_mana"] * mana_regen))
                    actual_regen = user_data["mana"] - old_mana
                    print_colored(f"You meditate and recover {actual_regen} mana points!", OKGREEN)

            # Herb production
            if "herb_production" in effects:
                herb_amount = effects["herb_production"]
                herb_types = ["Red Herb", "Blue Herb", "Green Herb"]

                for _ in range(herb_amount):
                    herb = random.choice(herb_types)
                    user_data["materials"][herb] = user_data["materials"].get(herb, 0) + 1
                    print_colored(f"You harvested 1 {herb}!", OKGREEN)

            # Cooking food
            if "cook_food" in effects:
                if "food_quality" in effects:
                    quality_bonus = effects["food_quality"]
                    print_colored(f"Your food is {int(quality_bonus * 100)}% more effective when cooked here!", OKGREEN)

                # Simplified cooking system
                if "Raw Meat" in user_data.get("materials", {}):
                    meat_amount = min(3, user_data["materials"]["Raw Meat"])
                    if meat_amount > 0:
                        user_data["materials"]["Raw Meat"] -= meat_amount
                        user_data["materials"]["Cooked Meat"] = user_data["materials"].get("Cooked Meat", 0) + meat_amount
                        print_colored(f"You cooked {meat_amount} Raw Meat into Cooked Meat!", OKGREEN)
                else:
                    print_colored("You don't have any Raw Meat to cook.", YELLOW)

            # Combat experience bonus
            if "combat_exp_bonus" in effects:
                print_colored(f"Training here will give you {int(effects['combat_exp_bonus'] * 100)}% more combat experience!", OKGREEN)
                # Award small amount of XP
                exp_gain = int(10 * (1 + effects['combat_exp_bonus']))
                user_data["exp"] += exp_gain
                print_colored(f"You trained and gained {exp_gain} experience!", OKGREEN)
                check_level_up()

            # Crafting bonus
            if "crafting_bonus" in effects or "smithing_bonus" in effects or "alchemy_bonus" in effects:
                bonus_type = "crafting"
                bonus_value = effects.get("crafting_bonus", 0)

                if "smithing_bonus" in effects:
                    bonus_type = "smithing"
                    bonus_value = effects["smithing_bonus"]
                elif "alchemy_bonus" in effects:
                    bonus_type = "alchemy"
                    bonus_value = effects["alchemy_bonus"]

                print_colored(f"Using this {bonus_type} station gives you a {int(bonus_value * 100)}% bonus to {bonus_type}!", OKGREEN)

            # Dimension travel
            if "dimension_travel" in effects:
                print_colored("This portal allows dimensional travel!", CYAN)
                print_colored("Use /dimensions to travel between dimensions.", LIGHTGRAY)

            # Slightly damage structure from use
            current_health = user_data["home_structures"][selected_structure].get("health", 100)
            damage = random.randint(1, 5)  # Random damage between 1-5%
            user_data["home_structures"][selected_structure]["health"] = max(0, current_health - damage)

            if user_data["home_structures"][selected_structure]["health"] < 30:
                print_colored(f"Warning: {selected_structure} is in need of repair!", WARNING)
        else:
            print_colored("Invalid choice.", FAIL)
    except ValueError:
        print_colored("Please enter a valid number.", FAIL)

def demolish_structure() -> None:
    """Demolish a camp structure and recover some materials"""
    print_header("DEMOLISH STRUCTURE")

    # Show existing structures that can be demolished
    demolishable_structures = []
    print_colored("Structures that can be demolished:", CYAN)

    for struct_name, struct_data in user_data["home_structures"].items():
        if struct_data.get("built", False):
            # Check if any other structures depend on this one
            has_dependents = False
            for dep_name, dep_data in HOME_STRUCTURES.items():
                if dep_data.get("requires") == struct_name or dep_data.get("upgrade_from") == struct_name:
                    if dep_name in user_data["home_structures"] and user_data["home_structures"][dep_name].get("built", False):
                        has_dependents = True
                        break

            if has_dependents:
                print_colored(f"  [X] {struct_name} (Required by other structures)", WARNING)
            elif struct_name == "Tent" and len([s for s in user_data["home_structures"] if user_data["home_structures"].get(s, {}).get("built", False)]) == 1:
                print_colored(f"  [X] {struct_name} (Cannot demolish your only shelter)", WARNING)
            else:
                demolishable_structures.append(struct_name)
                print_colored(f"  [{len(demolishable_structures)}] {struct_name}", LIGHTGRAY)

    if not demolishable_structures:
        print_colored("  No structures can be demolished at this time.", LIGHTGRAY)
        return

    print_colored("  [0] Cancel", LIGHTGRAY)

    choice = input("\nSelect a structure to demolish (number): ")

    try:
        choice_idx = int(choice)
        if choice_idx == 0:
            return

        if 1 <= choice_idx <= len(demolishable_structures):
            selected_structure = demolishable_structures[choice_idx - 1]

            # Confirm demolition
            confirm = input(f"Are you sure you want to demolish {selected_structure}? (y/n): ").lower()
            if confirm != 'y':
                print_colored("Demolition canceled.", LIGHTGRAY)
                return

            # Return some materials (50% of original)
            original_materials = HOME_STRUCTURES[selected_structure].get("materials", {})
            print_colored("Recovered materials:", CYAN)

            for material, amount in original_materials.items():
                recovered = math.ceil(amount * 0.5)
                user_data["materials"][material] = user_data["materials"].get(material, 0) + recovered
                print_colored(f"  {material}: +{recovered}", OKGREEN)

            # Remove structure
            user_data["home_structures"][selected_structure]["built"] = False
            print_colored(f"Successfully demolished {selected_structure}!", OKGREEN)
        else:
            print_colored("Invalid choice.", FAIL)
    except ValueError:
        print_colored("Please enter a valid number.", FAIL)

def view_structure_info() -> None:
    """View detailed information about camp structures"""
    print_header("STRUCTURE INFORMATION")

    # Group structures by category
    structures_by_category = {}
    for struct_name, struct_data in HOME_STRUCTURES.items():
        category = struct_data.get("category", "misc")
        if category not in structures_by_category:
            structures_by_category[category] = []
        structures_by_category[category].append((struct_name, struct_data))

    # Display categories
    categories = list(structures_by_category.keys())
    print_colored("Structure Categories:", CYAN)

    for idx, category in enumerate(categories, 1):
        print_colored(f"  [{idx}] {category.capitalize()}", LIGHTGRAY)

    print_colored("  [0] Cancel", LIGHTGRAY)

    cat_choice = input("\nSelect a category (number): ")

    try:
        cat_idx = int(cat_choice)
        if cat_idx == 0:
            return

        if 1 <= cat_idx <= len(categories):
            selected_category = categories[cat_idx - 1]
            structures = structures_by_category[selected_category]

            print_colored(f"\n{selected_category.capitalize()} Structures:", CYAN)

            for idx, (struct_name, struct_data) in enumerate(structures, 1):
                print_colored(f"  [{idx}] {struct_name}", LIGHTGRAY)

            print_colored("  [0] Back", LIGHTGRAY)

            struct_choice = input("\nSelect a structure (number): ")

            try:
                struct_idx = int(struct_choice)
                if struct_idx == 0:
                    view_structure_info()  # Go back to category selection
                    return

                if 1 <= struct_idx <= len(structures):
                    selected_structure, struct_data = structures[struct_idx - 1]

                    # Display detailed information
                    print_header(selected_structure)
                    print_colored(f"Description: {struct_data.get('description', 'No description available.')}", LIGHTCYAN)
                    print_colored(f"Level: {struct_data.get('level', 1)}", LIGHTGRAY)

                    if "upgrade_from" in struct_data:
                        print_colored(f"Upgrade from: {struct_data['upgrade_from']}", YELLOW)

                    if "requires" in struct_data:
                        print_colored(f"Requires: {struct_data['requires']}", YELLOW)

                    print_colored("\nMaterials:", CYAN)
                    for material, amount in struct_data.get("materials", {}).items():
                        print_colored(f"  {material}: {amount}", LIGHTGRAY)

                    print_colored("\nEffects:", CYAN)
                    for effect, value in struct_data.get("effects", {}).items():
                        effect_name = effect.replace("_", " ").capitalize()
                        if isinstance(value, bool):
                            print_colored(f"  {effect_name}: {'Yes' if value else 'No'}", OKGREEN if value else FAIL)
                        elif isinstance(value, (int, float)):
                            if effect == "rest_heal":
                                print_colored(f"  {effect_name}: +{value} HP", OKGREEN)
                            elif effect == "storage":
                                print_colored(f"  {effect_name}: +{value} slots", OKGREEN)
                            elif effect in ("crafting_bonus", "smithing_bonus", "alchemy_bonus", "combat_exp_bonus", "mana_regen"):
                                print_colored(f"  {effect_name}: +{int(value * 100)}%", OKGREEN)
                            else:
                                print_colored(f"  {effect_name}: {value}", OKGREEN)

                    # Check if player has this structure
                    built = selected_structure in user_data["home_structures"] and user_data["home_structures"][selected_structure].get("built", False)

                    if built:
                        health = user_data["home_structures"][selected_structure].get("health", 100)
                        health_color = OKGREEN if health > 70 else (YELLOW if health > 30 else FAIL)
                        print_colored("\nStatus: Built", OKGREEN)
                        print_colored(f"Health: {health}%", health_color)
                    else:
                        print_colored("\nStatus: Not Built", LIGHTGRAY)

                    input("\nPress Enter to return to categories...")
                    view_structure_info()  # Return to category selection
                else:
                    print_colored("Invalid choice.", FAIL)
                    time.sleep(1)
                    view_structure_info()  # Try again
            except ValueError:
                print_colored("Please enter a valid number.", FAIL)
                time.sleep(1)
                view_structure_info()  # Try again
        else:
            print_colored("Invalid choice.", FAIL)
    except ValueError:
        print_colored("Please enter a valid number.", FAIL)

def divine_trials() -> None:
    """Function to handle divine trials"""
    print_header("DIVINE TRIALS")

    trials = [
        "Trial of Strength", 
        "Trial of Wisdom", 
        "Trial of Courage", 
        "Trial of Endurance", 
        "Trial of Balance"
    ]

    print_colored("The gods have set forth these trials:", CYAN)
    for idx, trial in enumerate(trials, 1):
        completed = f"{OKGREEN}✓{ENDC}" if f"{trial}" in user_data.get("completed_trials", []) else f"{YELLOW}◯{ENDC}"
        print(f"{idx}. {completed} {trial}")

    choice = input("\nSelect a trial to attempt (1-5) or 'back' to return: ")

    if choice.lower() == "back":
        return
    elif choice.isdigit() and 1 <= int(choice) <= len(trials):
        selected_trial = trials[int(choice)-1]
        print_colored(f"Preparing for the {selected_trial}...", CYAN)
        print_colored("This feature will be expanded in future updates.", YELLOW)

        # Mark trial as completed for testing purposes
        user_data.setdefault("completed_trials", []).append(selected_trial)

        # Give player a small reward
        if len(user_data.get("completed_trials", [])) >= 5:
            if "Godforged Artifact" not in user_data["inventory"]:
                user_data["inventory"].append("Godforged Artifact")
                print_colored("You have completed all divine trials!", OKGREEN)
                print_colored("The gods bestow upon you the GODFORGED ARTIFACT!", MAGENTA)
    else:
        print_colored("Invalid choice.", FAIL)

def legendary_hunts() -> None:
    """Function to handle legendary monster hunts"""
    print_header("LEGENDARY HUNTS")

    legendary_monsters = [
        {"name": "Ancient Dragon", "level": 35, "health": 500, "attack": 50, "drops": ["Dragon's Heart", "Dragon Scale"]},
        {"name": "Behemoth", "level": 40, "health": 700, "attack": 60, "drops": ["Behemoth Horn", "Massive Hide"]},
        {"name": "Kraken", "level": 45, "health": 800, "attack": 70, "drops": ["Kraken Ink", "Giant Tentacle"]},
        {"name": "Phoenix", "level": 50, "health": 600, "attack": 80, "drops": ["Phoenix Plume", "Eternal Flame"]},
        {"name": "World Serpent", "level": 55, "health": 1000, "attack": 90, "drops": ["Serpent Fang", "World Scale"]}
    ]

    print_colored("These legendary beasts await worthy challengers:", CYAN)
    for idx, monster in enumerate(legendary_monsters, 1):
        hunted = f"{OKGREEN}✓{ENDC}" if monster["name"] in user_data.get("legendary_hunts_completed", []) else f"{YELLOW}◯{ENDC}"
        print(f"{idx}. {hunted} {monster['name']} (Level {monster['level']})")

    choice = input("\nSelect a monster to hunt (1-5) or 'back' to return: ")

    if choice.lower() == "back":
        return
    elif choice.isdigit() and 1 <= int(choice) <= len(legendary_monsters):
        selected_monster = legendary_monsters[int(choice)-1]

        if user_data["level"] < selected_monster["level"]:
            print_colored("You are not strong enough to face this monster yet!", WARNING)
            print_colored(f"Required level: {selected_monster['level']}", YELLOW)
            return

        print_colored(f"Hunting the {selected_monster['name']}...", CYAN)

        # Simulate fight with the monster
        fight(selected_monster)

        # If player survived and monster was defeated
        if user_data["health"] > 0:
            user_data.setdefault("legendary_hunts_completed", []).append(selected_monster["name"])
    else:
        print_colored("Invalid choice.", FAIL)

def time_trials() -> None:
    """Function to handle dungeon time trials"""
    print_header("TIME TRIALS")

    # Get completed dungeons
    completed_dungeons = user_data.get("dungeons_completed", [])
    if len(completed_dungeons) < 3:
        print_colored("You need to complete at least 3 dungeons to access Time Trials!", WARNING)
        return

    print_colored("Select a dungeon to challenge in Time Trial mode:", CYAN)
    for idx, dungeon_name in enumerate(completed_dungeons, 1):
        trial_record = user_data.get("time_trial_records", {}).get(dungeon_name, "No record")
        print(f"{idx}. {dungeon_name} - Best time: {trial_record}")

    choice = input("\nSelect a dungeon (1-{}) or 'back' to return: ".format(len(completed_dungeons)))

    if choice.lower() == "back":
        return
    elif choice.isdigit() and 1 <= int(choice) <= len(completed_dungeons):
        selected_dungeon = completed_dungeons[int(choice)-1]
        print_colored(f"Preparing Time Trial for {selected_dungeon}...", CYAN)
        print_colored("This feature will be expanded in future updates.", YELLOW)

        # Simulate a trial record
        completion_time = random.randint(60, 300)  # Random time between 1-5 minutes
        minutes = completion_time // 60
        seconds = completion_time % 60
        time_str = f"{minutes}m {seconds}s"

        user_data.setdefault("time_trial_records", {})[selected_dungeon] = time_str
        print_colored(f"Trial completed in {time_str}!", OKGREEN)

        if "Timekeeper's Pendant" not in user_data["inventory"] and len(user_data.get("time_trial_records", {})) >= 5:
            user_data["inventory"].append("Timekeeper's Pendant")
            print_colored("You've mastered the flow of time!", OKGREEN)
            print_colored("You've earned the TIMEKEEPER'S PENDANT!", MAGENTA)
    else:
        print_colored("Invalid choice.", FAIL)

def new_game_plus() -> None:
    """Function to handle New Game+ mode"""
    print_header("NEW GAME+")

    if user_data["level"] < 50:
        print_colored("You need to reach level 50 to start New Game+!", WARNING)
        return

    print_colored("WARNING: Starting New Game+ will reset your story progress", FAIL)
    print_colored("but you'll keep your level, skills, and equipment.", YELLOW)

    confirm = input("\nAre you sure you want to start New Game+? (yes/no): ")

    if confirm.lower() == "yes":
        # Reset story progress but keep character stats
        user_data["active_quests"] = []
        user_data["completed_quests"] = []
        user_data["current_area"] = "Greenwood Village"
        user_data["dungeons_completed"] = []

        # Add bonus
        user_data["health"] += 50
        user_data["max_health"] += 50
        user_data["attack"] += 10
        user_data["defense"] += 10

        print_colored("You have started New Game+!", OKGREEN)
        print_colored("The world has reset, but you retain your power!", CYAN)
        print_colored("You've gained permanent stat bonuses!", MAGENTA)
    else:
        print_colored("New Game+ cancelled.", YELLOW)

def endless_tower() -> None:
    """Function to handle the Endless Tower challenge"""
    print_header("ENDLESS TOWER")

    current_floor = user_data.get("endless_tower_floor", 0)
    print_colored(f"Current highest floor: {current_floor}", CYAN)

    print_colored("The Endless Tower challenges await...", YELLOW)
    print_colored("Each floor contains stronger enemies than the last.", YELLOW)
    print_colored("How high can you climb?", CYAN)

    options = ["Climb higher", "Claim rewards", "Exit"]
    for idx, option in enumerate(options, 1):
        print(f"{idx}. {option}")

    choice = input("\nSelect an option: ")

    if choice == "1":
        # Climb to next floor
        next_floor = current_floor + 1
        print_colored(f"Climbing to floor {next_floor}...", CYAN)

        # Generate a monster based on floor number
        monster = {
            "name": f"Tower Guardian {next_floor}",
            "level": 30 + next_floor,
            "health": 100 + (next_floor * 20),
            "attack": 20 + (next_floor * 3),
            "drops": ["Tower Fragment", "Ancient Coin", "Magic Dust"]
        }

        print_colored(f"You encounter {monster['name']}!", YELLOW)

        # Simulate fight
        fight(monster)

        # If player won, advance to next floor
        if user_data["health"] > 0:
            user_data["endless_tower_floor"] = next_floor
            print_colored(f"You've reached floor {next_floor}!", OKGREEN)

            # Special rewards for milestone floors
            if next_floor == 10:
                user_data["inventory"].append("Tower Champion's Badge")
                print_colored("You've earned the Tower Champion's Badge!", MAGENTA)
            elif next_floor == 25:
                user_data["inventory"].append("Celestial Aegis")
                print_colored("You've earned the CELESTIAL AEGIS!", MAGENTA)
            elif next_floor == 50:
                user_data["inventory"].append("Tower Master's Crown")
                print_colored("You've earned the Tower Master's Crown!", MAGENTA)
        else:
            print_colored("You were defeated! The tower has repelled you.", FAIL)
    elif choice == "2":
        # Calculate rewards based on highest floor
        if current_floor == 0:
            print_colored("You haven't climbed any floors yet!", WARNING)
            return

        gold_reward = current_floor * 100
        exp_reward = current_floor * 50

        user_data["gold"] += gold_reward
        user_data["exp"] += exp_reward

        print_colored(f"You received {gold_reward} gold and {exp_reward} experience!", OKGREEN)
    elif choice == "3":
        return
    else:
        print_colored("Invalid choice.", FAIL)

# Developer settings and commands
DEV_COMMANDS = {
    "/dev_complete": "Complete a dungeon, story, or quest",
    "/dev_give": "Give items, gold, exp, or levels", 
    "/dev_set": "Set health, location, or other stats",
    "/dev_unlock": "Unlock areas, skills, or features",
    "/dev_mode": "Toggle god mode, debug mode, etc"
}

def dev_command_handler(cmd: str) -> None:
    global user_data
    parts = cmd.split()
    base_cmd = parts[0].lower()

    if not parts:
        print("Invalid command format")
        return

    try:
        if base_cmd == "/dev_complete":
            if len(parts) < 3:
                print("Usage: /dev_complete [dungeon/story/quest] [name]")
                return

            complete_type = parts[1]
            name = " ".join(parts[2:])

            if complete_type == "dungeon":
                if name not in user_data["dungeons_completed"]:
                    user_data["dungeons_completed"].append(name)
                    print(f"Completed dungeon: {name}")
            elif complete_type == "quest":
                quest = next((q for q in QUESTS if q["name"].lower() == name.lower()), None)
                if quest:
                    user_data["completed_quests"].append(quest["id"])
                    print(f"Completed quest: {name}")

        elif base_cmd == "/dev_give":
            if len(parts) < 3:
                print("Usage: /dev_give [item/gold/exp/level] [amount/name]")
                return

            give_type = parts[1]
            value = " ".join(parts[2:])

            if give_type == "item":
                user_data["inventory"].append(value)
                print(f"Added {value} to inventory")
            elif give_type in ["gold", "exp", "level"]:
                amount = int(value)
                if give_type == "gold":
                    user_data["gold"] += amount
                elif give_type == "exp":
                    user_data["exp"] += amount
                elif give_type == "level":
                    user_data["level"] += amount
                print(f"Added {amount} {give_type}")

        elif base_cmd == "/dev_set":
            if len(parts) < 3:
                print("Usage: /dev_set [health/location/class] [value]")
                return

            set_type = parts[1]
            value = " ".join(parts[2:])

            if set_type == "health":
                hp = int(value)
                user_data["health"] = hp
                user_data["max_health"] = hp
                print(f"Set health to {hp}")
            elif set_type == "location":
                if value in LOCATIONS:
                    user_data["current_area"] = value
                    print(f"Moved to {value}")
            elif set_type == "class":
                if value in CHARACTER_CLASSES:
                    user_data["class"] = value
                    print(f"Changed class to {value}")

        elif base_cmd == "/dev_unlock":
            if len(parts) < 2:
                print("Usage: /dev_unlock [all/areas/skills]")
                return

            unlock_type = parts[1]

            if unlock_type == "all":
                for location in LOCATIONS:
                    user_data.setdefault("unlocked_areas", []).append(location)
                print("Unlocked everything")
            elif unlock_type == "areas":
                for location in LOCATIONS:
                    user_data.setdefault("unlocked_areas", []).append(location)
                print("Unlocked all areas")
            elif unlock_type == "skills":
                if user_data["class"]:
                    user_data["skills"] = SKILLS[user_data["class"]]
                    print("Unlocked all class skills")

        elif base_cmd == "/dev_mode":
            if len(parts) < 2:
                print("Usage: /dev_mode [god/debug]")
                return

            mode_type = parts[1]

            if mode_type == "god":
                user_data["god_mode"] = not user_data.get("god_mode", False)
                print(f"God mode: {'enabled' if user_data['god_mode'] else 'disabled'}")
            elif mode_type == "debug":
                user_data["debug_mode"] = not user_data.get("debug_mode", False)
                print(f"Debug mode: {'enabled' if user_data['debug_mode'] else 'disabled'}")

    except Exception as e:
        print(f"Error in dev command: {e}")
        print("Use /help_dev to see command usage")

# Weather and Seasons System
def update_weather() -> None:
    """Function to update the weather based on current game time"""
    current_day = game_state["current_day"]

    # Check if it's time to change the weather
    if current_day - game_state["last_weather_change"] >= game_state["weather_duration"]:
        dimension = user_data.get("current_dimension", "Overworld")

        # Different weather system for different dimensions
        if dimension != "Overworld" and dimension in DIMENSION_WEATHERS:
            # Special dimension-specific weather
            special_weather = random.choice(DIMENSION_WEATHERS[dimension])
            game_state["current_weather"] = special_weather["name"]
            game_state["current_weather_description"] = special_weather["description"]
            game_state["current_weather_color"] = special_weather["color"]
            game_state["current_weather_crop_modifier"] = special_weather["crop_growth_modifier"]
        else:
            # Regular weather
            weathers = []
            weights = []

            for weather_id, weather_data in WEATHERS.items():
                weathers.append(weather_id)
                weights.append(weather_data["rarity"])

            new_weather = random.choices(weathers, weights=weights, k=1)[0]
            game_state["current_weather"] = new_weather
            game_state["current_weather_description"] = WEATHERS[new_weather]["description"]
            game_state["current_weather_color"] = WEATHERS[new_weather]["color"]
            game_state["current_weather_crop_modifier"] = WEATHERS[new_weather]["crop_growth_modifier"]

        # Update weather duration (3-7 days)
        game_state["weather_duration"] = random.randint(3, 7)
        game_state["last_weather_change"] = current_day

        # Notify player
        print_colored(f"The weather has changed to: {get_weather_name()}", game_state["current_weather_color"])
        print_colored(f"{get_weather_description()}", LIGHTGRAY)

def update_season() -> None:
    """Function to update the season based on current game time"""
    current_day = game_state["current_day"]
    days_per_season = game_state["days_per_season"]

    # Calculate which season it should be
    season_index = (current_day // days_per_season) % len(SEASONS)
    new_season = SEASONS[season_index]

    # Check if season changed
    if new_season != game_state["current_season"]:
        game_state["current_season"] = new_season
        game_state["season_day"] = 1

        # Notify player
        print_colored(f"The season has changed to {new_season}!", YELLOW)

        # Different message for each season
        if new_season == "Spring":
            print_colored("The world blooms with new life and the air is filled with fresh scents.", GREEN)
        elif new_season == "Summer":
            print_colored("The days grow longer and warmer. A perfect time for certain crops.", OKGREEN)
        elif new_season == "Fall":
            print_colored("Leaves change color and the air becomes crisp. Harvest season begins.", YELLOW)
        elif new_season == "Winter":
            print_colored("A chill settles over the land. Few crops will grow in this cold.", CYAN)
    else:
        game_state["season_day"] += 1

def get_weather_name() -> str:
    """Get the current weather name with proper formatting"""
    dimension = user_data.get("current_dimension", "Overworld")

    if dimension != "Overworld" and dimension in DIMENSION_WEATHERS:
        # Special dimension-specific weather may already be stored as a name
        return game_state["current_weather"]
    else:
        # Regular weather is stored as an ID, get the name
        return WEATHERS[game_state["current_weather"]]["name"]

def get_weather_description() -> str:
    """Get the current weather description"""
    dimension = user_data.get("current_dimension", "Overworld")

    if dimension != "Overworld" and dimension in DIMENSION_WEATHERS:
        # Special dimension-specific weather description
        return game_state["current_weather_description"]
    else:
        # Regular weather description
        return WEATHERS[game_state["current_weather"]]["description"]

def show_weather() -> None:
    """Function to display current weather information"""
    print_header("Current Weather")

    weather_name = get_weather_name()
    weather_desc = get_weather_description()
    weather_color = game_state["current_weather_color"]

    print_colored(f"Current Weather: {weather_name}", weather_color)
    print_colored(f"Description: {weather_desc}", LIGHTGRAY)
    print_colored("Effect on Crops: ", CYAN, end="")

    modifier = game_state["current_weather_crop_modifier"]
    if modifier > 1.0:
        print_colored(f"+{int((modifier-1.0)*100)}% growth rate", OKGREEN)
    elif modifier < 1.0:
        print_colored(f"-{int((1.0-modifier)*100)}% growth rate", FAIL)
    else:
        print_colored("No effect", LIGHTGRAY)

    print()
    print_colored("Weather affects how quickly your crops grow and can influence", YELLOW)
    print_colored("certain activities. Each crop has optimal and unfavorable weather.", YELLOW)

def show_season() -> None:
    """Function to display current season information"""
    print_header("Current Season")

    season = game_state["current_season"]
    day = game_state["season_day"]
    days_total = game_state["days_per_season"]

    season_colors = {
        "Spring": GREEN,
        "Summer": YELLOW,
        "Fall": RED,
        "Winter": CYAN
    }

    print_colored(f"Current Season: {season}", season_colors.get(season, LIGHTGRAY))
    print_colored(f"Day: {day}/{days_total}", LIGHTGRAY)

    # Season-specific messages
    if season == "Spring":
        print_colored("Best crops: Most common vegetables, berries", OKGREEN)
        print_colored("Spring rains help crops grow quickly.", LIGHTCYAN)
    elif season == "Summer":
        print_colored("Best crops: Heat-loving fruits, peppers, grains", OKGREEN)
        print_colored("The warm weather is perfect for sun-loving plants.", LIGHTYELLOW)
    elif season == "Fall":
        print_colored("Best crops: Root vegetables, gourds, nuts", OKGREEN)
        print_colored("Harvest season brings abundance before winter.", LIGHTRED)
    elif season == "Winter":
        print_colored("Best crops: Frost berries, crystal blooms", OKGREEN)
        print_colored("Few crops grow in winter - a time for planning.", BLUE)

    print()
    print_colored("Some crops will only grow during certain seasons.", YELLOW)
    print_colored("Check the crop information before planting!", YELLOW)

def handle_command(cmd: str) -> None:
    allowed_commands_without_character = {"/new", "/load", "/help", "/exit", "/prefix", "/save"}

    # Add new commands for our enhanced features
    allowed_commands_without_character.add("/about")

    parts = cmd.lower().split()
    base_cmd = parts[0] if parts else ""

    # Initialize new systems when user first loads game
    if "user_data" in globals() and not user_data.get("new_systems_initialized", False):
        # Initialize new systems here if needed
        user_data["new_systems_initialized"] = True

    # Special handling for /dev command
    if base_cmd == "/dev":
        if len(parts) > 1 and " ".join(parts[1:]) == "activatedevmode":
            user_data["dev_mode"] = True
            print("Developer mode activated! Use /help_dev to see available commands.")
            return
        else:
            print("Incorrect developer command. Use '/dev ACTIVATEDEVMODE' to enable developer mode.")
            return
    elif cmd.lower() == "/help_dev" and user_data.get("dev_mode", False):
        print_header("Developer Commands")
        for command, desc in DEV_COMMANDS.items():
            print(f"{command}: {desc}")
        return

    # Handle developer commands if dev mode is active
    if cmd.split()[0].lower() in DEV_COMMANDS and user_data.get("dev_mode", False):
        dev_command_handler(cmd)
        return
    elif cmd.split()[0].lower() in DEV_COMMANDS and not user_data.get("dev_mode", False):
        print("Developer mode not activated! Use /dev with correct password.")
        return

    # Increment ticks based on command if it's not a no-tick command
    base_command = cmd.split()[0].lower()
    if base_command not in NO_TICK_COMMANDS:
        if base_command in TICK_COMMANDS:
            ticks = random.randint(*TICK_COMMANDS[base_command])
            game_state["current_tick"] += ticks
            game_state["current_day"] = game_state["current_tick"] // TICKS_PER_DAY

            # Update plant growth based on elapsed ticks, weather, and season
            if "farming" in user_data:
                # Update weather and season based on current game time
                update_weather()
                update_season()

                current_weather = game_state["current_weather"]
                current_season = game_state["current_season"]
                weather_modifier = game_state.get("current_weather_crop_modifier", 1.0)

                for plot in user_data["farming"]["growth"]:
                    crop_name = user_data["farming"]["plots"].get(plot)
                    if not crop_name:
                        continue

                    # Base growth ticks
                    growth_ticks = ticks
                    crop_data = CROPS.get(crop_name, {})

                    # Season modifier - check if current season is optimal for this crop
                    season_modifier = 1.0
                    crop_seasons = crop_data.get("seasons", [])

                    # All-season crops (mainly dimension-specific)
                    if "All" in crop_seasons:
                        season_modifier = 1.2  # Bonus for all-season crops
                    elif current_season in crop_seasons:
                        season_modifier = 1.2  # Good season for this crop
                    else:
                        season_modifier = 0.5  # Bad season - grows slower

                    # Weather modifier - check if current weather is optimal/weak for this crop
                    crop_optimal_weather = crop_data.get("optimal_weather", [])
                    crop_weak_weather = crop_data.get("weak_weather", [])

                    additional_weather_modifier = 1.0
                    if current_weather in crop_optimal_weather:
                        additional_weather_modifier = 1.3  # This weather is perfect for the crop
                    elif current_weather in crop_weak_weather:
                        additional_weather_modifier = 0.7  # This weather harms the crop

                    # Apply all modifiers
                    total_modifier = weather_modifier * season_modifier * additional_weather_modifier

                    # Apply modified growth ticks (convert to integer)
                    modified_ticks = int(growth_ticks * total_modifier)
                    if modified_ticks < 1:
                        modified_ticks = 1  # Ensure at least some growth

                    user_data["farming"]["growth"][plot] += modified_ticks

    elif cmd.startswith("/talk"):
        try:
            parts = cmd.split(" ", 1)
            npc_name = parts[1] if len(parts) > 1 else None
            talk_to_npc(npc_name)
        except Exception as e:
            print(f"{FAIL}Error talking to NPC: {e}{ENDC}")
    elif cmd == "/npcs":
        list_npcs()
    elif cmd == "/story":
        show_storyline()

    if user_data["class"] is None and cmd not in allowed_commands_without_character:
        print_animated("You need to create a character first! Use /new to start your adventure.")
        return

    commands = {
        "/sell": lambda: sell_item(cmd.split(" ", 1)[1] if len(cmd.split(" ", 1)) > 1 else ""),
        "/start": start_guide,
        "/help": show_help,
        "/h": show_help,
        "/pet": show_pets,
        "/archaeology": archaeology,
        "/arch": archaeology,
        "/artifacts": analyze_artifacts,
        "/excavate": excavate_site,
        "/dig": excavate_site,
        "/relics": view_archaeological_sites,
        "/ancient_knowledge": view_ancient_knowledge,
        "/museum": view_museum,
        "/library": literature_system,
        "/books": literature_system,
        "/read": read_literature,
        "/collection": view_literature_collection,
        "/search_books": search_literature,
        "/gacha": gacha_system,
        "/wish": gacha_system,
        "/characters": view_character_collection,
        "/search": search_resources,
        "/location": show_location,
        "/location_check": check_location,
        "/professions": show_professions,
        "/prof_system": professions_system,
        "/cook": cook_food,
        "/stats": show_stats,
        "/s_t": show_stats,
        "/shop": visit_shop,
        "/inventory": show_inventory,
        "/i": show_inventory,
        "/quests": show_quests,
        "/gather": lambda: gather_materials(user_data["current_area"]),
        "/craft": craft_item,
        "/materials": print_materials,
        "/travel": travel_to_area,
        "/new": create_character,
        "/save": lambda: save_prompt(),
        "/load": lambda: load_prompt(),
        "/saves": show_save_slots,
        "/delete_save": lambda: delete_save_prompt(),
        "/exit": exit_game,
        "/guild": guild_guide,
        "/guild_join": guild_join,
        "/guild_leave": guild_leave,
        "/guild_list": guild_list,
        # New item enhancement commands
        "/upgrade": upgrade_item,
        "/enchant": enchant_item,
        "/use": lambda: use_potion(cmd.split(" ", 1)[1] if len(cmd.split(" ", 1)) > 1 else ""),
        "/chest": lambda: open_chest(cmd.split(" ", 1)[1] if len(cmd.split(" ", 1)) > 1 else "Common"),
        "/areas": area_guides,
        "/dungeons": dungeon_guides,
        "/timetravel": time_travel_guide,
        "/coolness": coolness_info,
        "/dismantle": dismantle_items,
        "/invcalc": inventory_calculator,
        "/drops": show_drops,
        "/enchants": show_enchants,
        "/trading": trading_system,
        "/gambling": gambling_guide,
        "/codes": redeem_codes,
        "/duel": duel_info,
        "/farm": farming_guide,
        "/tip": random_tip,
        "/support": show_support,
        "/dungeon_list": list_dungeons,
        "/bestiary": show_bestiary,
        # New Systems
        "/skills": lambda: process_skills_command(cmd.split()),
        "/ability": lambda: process_ability_command(cmd.split()),
        "/knowledge": lambda: show_knowledge(),
        "/buffs": lambda: show_active_buffs(),
        "/resistance": lambda: show_elemental_resistance(),
        "/spells": lambda: show_one_time_spells(),
        # Mechanical constructs system
        "/constructs": display_constructs,
        "/blueprints": display_blueprints,
        "/craft_construct": lambda: handle_construct_command(cmd.split()),
        "/dailymob": daily_monster,
        "/weapon_info": lambda: show_weapon_info(),
        "/settings": user_settings,
        "/prefix": command_prefix,
        "/pet_adopt": adopt_pet,
        "/pet_train": train_pet,
        "/pet_list": show_pets,
        "/pet_evolve": evolve_pet,
        "/evolve_pet": evolve_pet,
        "/achievement_list": show_achievements,
        "/inventory_sort": sort_inventory,
        "/inventory_filter": filter_inventory,
        "/quest_complete": complete_quest,
        "/quest_list": list_active_quests,
        "/q": list_active_quests,
        "/l": load_prompt,
        "/x": exit_game,
        # Dimensions system commands
        "/dimensions": dimensions_menu,
        "/dim": dimensions_menu,
        "/find_key": find_dimension_key,
        "/return_home": returnToOverworld,
        # Home/camp system commands
        "/camp": camp_menu,
        "/camp_build": build_structure,
        "/camp_repair": repair_structure,
        "/camp_use": use_structure,
        "/camp_demolish": demolish_structure,
        "/camp_info": view_structure_info,

        # Weather and season commands
        "/weather": show_weather,
        "/season": show_season,
        "/c": create_character,
        "/g": guild_guide,
        "/d": dungeon_guides,
        "/f": fight_monster,
        "/t": travel_to_area,
        "/a": show_achievements,
        "/m": print_materials,
        "/r": redeem_codes,
        "/u": user_settings,
        "/z": show_save_slots
    }

    # Handle commands with arguments
    if cmd.startswith("/fight "):
        fight_monster(cmd.split(" ", 1)[1])
    elif cmd.startswith("/equip "):
        equip_item(cmd.split(" ", 1)[1])
    elif cmd.startswith("/dungeon "):
        enter_dungeon(cmd.split(" ", 1)[1])
    elif cmd.startswith("/guild_join "):
        guild_join(cmd.split(" ", 1)[1])
    elif cmd.startswith("/guild_leave"):
        guild_leave()
    elif cmd.startswith("/pet_adopt "):
        adopt_pet(cmd.split(" ", 1)[1])
    elif cmd.startswith("/pet_train "):
        train_pet(cmd.split(" ", 1)[1])
    elif cmd.startswith("/pet_evolve ") or cmd.startswith("/evolve_pet "):
        # Extract pet name from either command format
        pet_name = cmd.split(" ", 1)[1]
        evolve_pet(pet_name)
    elif cmd.startswith("/quest_complete "):
        complete_quest(cmd.split(" ", 1)[1])
    # Post-game commands
    elif cmd == "/postgame":
        show_postgame_content()
    elif cmd == "/rifts":
        dimensional_rifts()
    elif cmd == "/trials":
        divine_trials()
    elif cmd == "/legendary_hunts":
        legendary_hunts()
    elif cmd == "/time_trials":
        time_trials()
    elif cmd == "/newgame+":
        new_game_plus()
    elif cmd == "/tower":
        endless_tower()
    elif cmd.startswith("/inspect "):
        inspect_item(cmd.split(" ", 1)[1])
    elif cmd in commands:
        commands[cmd]()
    else:
        print_animated("Unknown command. Type '/help' for a list of commands.")

# Define functions
def start_guide() -> None:
    print_header("Starter Guide")
    print("Welcome to TextRP CLI! Type /help for help!")

def area_guides() -> None:
    print_header("Area Guides")
    print("Areas: Forest, Cave, Desert, Snowy Peaks...")

def dungeon_guides() -> None:
    print_header("Dungeon Guides")
    print("Dungeons are challenging! Bring a team and gear up.")

def coolness_info() -> None:
    print_header("Coolness")
    print("Coolness is a rare stat that boosts drop rates and XP gain.")

def random_tip() -> None:
    tips = [
        "Always carry health potions!",
        "Upgrade your gear before dungeons.",
    ]
    print_header("Random Tip")
    print(random.choice(tips))

def guild_guide() -> None:
    print_header("Adventurer's Guild")

    # Initialize adventurer data if it doesn't exist
    if "adventurer" not in user_data:
        user_data["adventurer"] = {
            "rank": "Novice",
            "exp": 0,
            "level": 1,
            "total_quests": 0,
            "bosses_defeated": 0,
            "reputation": 0
        }

    adv = user_data["adventurer"]
    exp_required = adv["level"] * 100

    print(f"{CYAN}Adventurer Rank:{ENDC} {adv['rank']}")
    print(f"{CYAN}Adventurer Level:{ENDC} {adv['level']}")
    print(f"{CYAN}Experience:{ENDC} {adv['exp']}/{exp_required}")
    print(f"{CYAN}Quests Completed:{ENDC} {adv['total_quests']}")
    print(f"{CYAN}Bosses Defeated:{ENDC} {adv['bosses_defeated']}")
    print(f"{CYAN}Guild Reputation:{ENDC} {adv['reputation']}")

    # Create progress bar for experience
    exp_percentage = min(100, (adv['exp'] / exp_required) * 100)
    progress_bar = create_progress_bar(exp_percentage)
    print(f"\n{CYAN}Progress:{ENDC} [{progress_bar}] {int(exp_percentage)}%")

    # Show available rank advancements
    next_rank = get_next_rank(adv["rank"])
    if next_rank:
        print(f"\n{YELLOW}Next Rank:{ENDC} {next_rank['name']}")
        print(f"{YELLOW}Requirements:{ENDC} Level {next_rank['level_req']}, {next_rank['quest_req']} Quests, {next_rank['boss_req']} Bosses")

    # Show rewards for current level
    print(f"\n{GREEN}Active Benefits:{ENDC}")
    for level in range(1, adv["level"] + 1):
        rewards = get_adventurer_level_rewards(level)
        if rewards:
            print(f"- Level {level}: {rewards['description']}")

    # Show guild facilities
    print(f"\n{PURPLE}Adventurer's Guild Facilities:{ENDC}")
    print(f"- {LIGHTBLUE}Quest Board{ENDC}: Special quests for adventurers")
    print(f"- {LIGHTBLUE}Trading Post{ENDC}: Exchange rare items with other adventurers")
    print(f"- {LIGHTBLUE}Training Ground{ENDC}: Practice combat techniques")
    print(f"- {LIGHTBLUE}Research Library{ENDC}: Learn about monsters and dungeons")
    print(f"- {LIGHTBLUE}Trophy Hall{ENDC}: Display your greatest achievements")

def user_settings() -> None:
    print_header("User Settings")
    print(f"Level: {user_data['level']}")
    print(f"Gold: {user_data['gold']}")
    print(f"Coolness: {user_data['coolness']}")
    print(f"Guild: {user_data['guild']}")
    print(f"Pets: {', '.join(user_data['pets']) if user_data['pets'] else 'No pets'}")
    print(f"Health: {user_data['health']}/{user_data['max_health']}")
    print(f"Experience: {user_data['exp']}")
    print(f"Current Area: {user_data['current_area']}")
    print_materials()

def command_prefix() -> None:
    print_header("Command Prefix")
    print("Prefix for commands is '/'. Use '/help' for all available commands.")

def exit_game() -> None:
    print_animated("Exiting game...", BLUE, 0.01)
    print_animated("Goodbye!", BLUE, 0.01)
    sys.exit()

def show_villages() -> None:
    print_header("Villages")
    for village in villages:
        print(f"Name: {village['name']}, Population: {village['population']}, Special Items: {', '.join(village['special_items'])}")

def show_biomes() -> None:
    print_header("Biomes")
    for biome in biomes:
        print(f"Name: {biome['name']}, Description: {biome['description']}")

def join_guild(guild_name: str) -> None:
    user_data["guild"] = guild_name
    print_header("Join Guild")
    print(f"Successfully joined the {guild_name} guild!")

def adopt_pet(pet_name: str) -> None:
    if pet_name in PETS:
        if pet_name in user_data["pets"]:
            print(f"You already have a pet named {pet_name}.")
        else:
            user_data["pets"].append(pet_name)
            print(f"You have adopted a pet: {pet_name}.")
    else:
        print(f"No pet named {pet_name} found.")
    print_header("Adopt Pet")
    print(f"Adopted a new pet named {pet_name}!")

def show_mobs(area: Optional[str] = None) -> None:
    print_header("Monsters")
    target_area = area if area else user_data.get("current_area", "")

    if target_area not in LOCATIONS:
        print(f"Invalid area: {target_area}")
        return

    area_monster_names = LOCATIONS[target_area].get("monsters", [])
    area_monsters = [m for m in monsters if m["name"] in area_monster_names]

    if area_monsters:
        print(f"Monsters in {target_area}:")
        for monster in area_monsters:
            print(f"- {monster['name']} (Level {monster['level']})")
            print(f"  Health: {monster['health']}, Attack: {monster['attack']}")
            if monster.get("boss", False):
                print(f"  {RED}⚠ BOSS MONSTER ⚠{ENDC}")
    else:
        print(f"No monsters found in {target_area}")

# Function to handle a fight with a monster (used in dungeons)
def fight(monster: Dict) -> None:
    """
    Enhanced combat system with combo mechanics, status effects, and visual feedback
    Includes pet integration with abilities and elemental interactions
    """
    if not user_data["class"]:
        print(f"{FAIL}You need to create a character first! Use /new{ENDC}")
        return

    if user_data["health"] <= 0:
        print(f"{FAIL}You can't fight while defeated! Use a healing potion or rest.{ENDC}")
        return

    # Initialize combat state variables
    combo_counter = 0
    max_combo = 3  # Can build up to 3-hit combos
    stunned = False
    monster_stunned = False
    combat_log = []  # Track recent actions for combo detection
    player_status_effects = []  # Track temporary buffs/debuffs
    monster_status_effects = []

    # Pet combat variables
    active_pet = get_active_pet()
    pet_shield_active = False
    pet_shield_duration = 0
    pet_dodge_bonus = 0
    # Track turns for pet ability cooldowns in future implementation

    # Extract monster data with defaults
    monster_health = monster["health"]
    monster_name = monster["name"]
    monster_level = monster["level"]
    monster_element = monster.get("element", "Normal")

    # Get player element
    player_element = user_data.get("element", "Normal")

    # Battle intro with fancy visuals
    print_header(f"⚔️ COMBAT: {monster_name} ⚔️")
    print_animated(f"{BG_RED}{WHITE} BATTLE START! {ENDC}", delay=0.05)
    print_animated(f"You encountered a {LIGHTRED}{monster_name}{ENDC} (Level {YELLOW}{monster_level}{ENDC})!", delay=0.03)

    if monster.get("boss", False):
        print_animated(f"{BG_MAGENTA}{WHITE}❗ BOSS BATTLE ❗{ENDC}", delay=0.05)
        print_animated(f"{monster.get('description', 'A powerful foe stands before you!')}", LIGHTMAGENTA, delay=0.03)

    # Display monster's element if available
    if monster_element != "Normal":
        print_animated(f"Element: {get_element_color(monster_element)}{monster_element}{ENDC}", delay=0.02)

    # Main combat loop
    turn_counter = 0
    while user_data["health"] > 0 and monster_health > 0:
        turn_counter += 1
        try:
            # Display health bars with visual representation
            player_health_percent = user_data["health"] / user_data["max_health"]
            monster_health_percent = monster_health / monster["health"]

            # Create health bars
            player_health_bar = create_health_bar(player_health_percent, 20)
            monster_health_bar = create_health_bar(monster_health_percent, 20)

            print(f"\n{BOLD}Turn {turn_counter}{ENDC}")
            print(f"\n{CYAN}Your Health: {user_data['health']}/{user_data['max_health']} {player_health_bar}{ENDC}")
            print(f"{LIGHTRED}Enemy Health: {monster_health}/{monster['health']} {monster_health_bar}{ENDC}")

            # Display active status effects
            if player_status_effects:
                effects_str = ", ".join([f"{e['name']} ({e['duration']})" for e in player_status_effects])
                print(f"{LIGHTYELLOW}Your Status: {effects_str}{ENDC}")
            if monster_status_effects:
                effects_str = ", ".join([f"{e['name']} ({e['duration']})" for e in monster_status_effects])
                print(f"{LIGHTYELLOW}Enemy Status: {effects_str}{ENDC}")

            # Display combo counter if active
            if combo_counter > 0:
                print(f"{LIGHTMAGENTA}Combo: x{combo_counter}{ENDC}")

            # Display active pet information if any
            if active_pet:
                pet_name = active_pet["name"]
                pet_level = active_pet.get("level", 1)
                pet_element = active_pet.get("element", "Nullum")
                pet_element_display = f" | {get_element_color(pet_element)}{pet_element}{ENDC}" if pet_element != "Nullum" else ""

                # Display pet status
                print(f"\n{CYAN}Active Pet: {pet_name} (Lvl {pet_level}){pet_element_display}{ENDC}")

                # Show active abilities if any
                pet_abilities = active_pet.get("abilities", [])
                if pet_abilities and pet_shield_active:
                    print(f"{YELLOW}Pet Shield: Active ({pet_shield_duration} turns){ENDC}")

            # Check if player is stunned
            if stunned:
                print(f"{YELLOW}You are stunned and cannot act this turn!{ENDC}")
                stunned = False  # Stun lasts one turn
            else:
                # Actions menu
                print("\n⚔️ Actions:")
                print(f"{LIGHTCYAN}1. Attack{ENDC}")
                print(f"{LIGHTGREEN}2. Use Skill{ENDC}")
                print(f"{LIGHTBLUE}3. Use Item{ENDC}")
                # Show pet command option if a pet is active
                if active_pet and active_pet.get("abilities", []):
                    print(f"{MAGENTA}4. Pet Command{ENDC}")
                    print(f"{YELLOW}5. Defend{ENDC}")
                    print(f"{LIGHTRED}6. Flee{ENDC}")
                else:
                    print(f"{YELLOW}4. Defend{ENDC}")
                    print(f"{LIGHTRED}5. Flee{ENDC}")

                max_choice = "6" if active_pet and active_pet.get("abilities", []) else "5"
                choice = input(f"{YELLOW}Choose action (1-{max_choice}): {ENDC}").strip()

                if choice == "1":  # Basic Attack
                    # Calculate damage with equipped weapon and combo bonus
                    base_damage = user_data.get("attack", 10)
                    weapon_bonus = user_data.get("equipped", {}).get("weapon", {}).get("effect", 0)
                    combo_bonus = int(combo_counter * base_damage * 0.2)  # 20% bonus damage per combo point

                    # Calculate critical hit
                    is_critical = random.random() < (CRITICAL_CHANCE + combo_counter * 0.05)  # Combo increases crit chance

                    # Calculate total damage
                    damage = base_damage + weapon_bonus + combo_bonus

                    if is_critical:
                        crit_multiplier = 2.0
                        # Apply class-specific crit bonuses
                        if user_data["class"] == "Rogue":
                            crit_multiplier = 2.5
                        elif user_data["class"] == "Archer":
                            crit_multiplier = 2.2

                        damage = int(damage * crit_multiplier)
                        print_animated(f"{BG_YELLOW}{BLACK} CRITICAL HIT! {ENDC}", delay=0.02)

                    # Apply elemental damage modifiers
                    elemental_result = calculate_elemental_damage(player_element, monster_element, damage)
                    damage = elemental_result[0]
                    effect_message = elemental_result[1]
                    elemental_effects = elemental_result[2]

                    # Apply damage
                    monster_health -= damage

                    # Apply any elemental effects to monster
                    if elemental_effects:
                        for effect_name, effect_data in elemental_effects.items():
                            monster_status_effects.append({
                                "name": effect_name,
                                "duration": effect_data.get("duration", 2),
                                "effect": effect_data
                            })

                    # Display attack results
                    print_animated(f"You {get_attack_verb(combo_counter)} the {monster_name} for {LIGHTGREEN}{damage}{ENDC} damage!", delay=0.02)
                    if effect_message:
                        print_animated(f"{LIGHTCYAN}{effect_message}{ENDC}", delay=0.02)

                    # Update combo counter
                    combat_log.append("attack")
                    if len(combat_log) >= 3 and combat_log[-3:] == ["attack", "attack", "attack"]:
                        # Reset combo after 3 consecutive attacks
                        print_animated(f"{BG_MAGENTA}{WHITE} COMBO FINISHER! {ENDC}", delay=0.02)
                        combo_counter = 0
                        combat_log = []
                        # Apply stun effect on combo finisher
                        monster_stunned = True
                        print_animated(f"The {monster_name} is stunned!", LIGHTYELLOW, delay=0.02)
                    else:
                        combo_counter = min(combo_counter + 1, max_combo)

                elif choice == "2":  # Use Skill
                    if user_data["skills"]:
                        print("\nAvailable skills:")
                        for i, skill in enumerate(user_data["skills"], 1):
                            # Get skill details if available
                            skill_name = skill if isinstance(skill, str) else skill.get("name", "Unknown Skill")
                            skill_desc = skill.get("description", "No description") if isinstance(skill, dict) else ""
                            skill_element = skill.get("element", player_element) if isinstance(skill, dict) else player_element

                            # Display with element color
                            print(f"[{i}] {get_element_color(skill_element)}{skill_name}{ENDC} - {skill_desc}")

                        try:
                            skill_choice = int(input("Choose skill (0 to cancel): "))
                            if skill_choice == 0:
                                continue

                            if 1 <= skill_choice <= len(user_data["skills"]):
                                skill = user_data["skills"][skill_choice - 1]
                                skill_name = skill if isinstance(skill, str) else skill.get("name", "Unknown Skill")
                                skill_element = skill.get("element", player_element) if isinstance(skill, dict) else player_element

                                # Base skill damage calculation
                                intellect_bonus = user_data.get("intellect", 0) * 0.5
                                base_skill_damage = random.randint(15, 25) + int(intellect_bonus)

                                # Calculate skill-specific damage
                                if isinstance(skill, dict) and "damage_multiplier" in skill:
                                    skill_multiplier = skill.get("damage_multiplier", 1.0)
                                    damage = int(base_skill_damage * skill_multiplier)
                                else:
                                    damage = base_skill_damage

                                # Apply elemental damage modifiers
                                elemental_result = calculate_elemental_damage(skill_element, monster_element, damage)
                                damage = elemental_result[0]
                                effect_message = elemental_result[1]
                                elemental_effects = elemental_result[2]

                                # Apply damage
                                monster_health -= damage

                                # Apply any elemental effects
                                if elemental_effects:
                                    for effect_name, effect_data in elemental_effects.items():
                                        monster_status_effects.append({
                                            "name": effect_name,
                                            "duration": effect_data.get("duration", 2),
                                            "effect": effect_data
                                        })

                                # Display skill results with visual effects
                                print_animated(f"{BG_CYAN}{WHITE} SKILL ACTIVATED! {ENDC}", delay=0.02)
                                print_animated(f"You cast {get_element_color(skill_element)}{skill_name}{ENDC} and deal {LIGHTGREEN}{damage}{ENDC} damage!", delay=0.02)
                                if effect_message:
                                    print_animated(f"{LIGHTCYAN}{effect_message}{ENDC}", delay=0.02)

                                # Special skill effects
                                if isinstance(skill, dict) and "effects" in skill:
                                    for effect, value in skill["effects"].items():
                                        if effect == "heal":
                                            heal_amount = int(value)
                                            user_data["health"] = min(user_data["health"] + heal_amount, user_data["max_health"])
                                            print_animated(f"You recover {LIGHTGREEN}{heal_amount}{ENDC} health!", delay=0.02)
                                        elif effect == "stun":
                                            if random.random() < value:
                                                monster_stunned = True
                                                print_animated(f"The {monster_name} is stunned!", LIGHTYELLOW, delay=0.02)
                                        elif effect == "combo":
                                            combo_counter = min(combo_counter + value, max_combo)
                                            print_animated(f"Combo increased to {LIGHTMAGENTA}x{combo_counter}{ENDC}!", delay=0.02)

                                # Reset combo counter after using a skill
                                combat_log = []
                            else:
                                print("Invalid skill choice.")

                        except ValueError:
                            print("Invalid input.")
                    else:
                        print(f"{YELLOW}You have no skills available!{ENDC}")
                        continue

                elif choice == "3":  # Use Item
                    # Get a list of usable combat items
                    combat_items = [item for item in user_data["inventory"] 
                                  if item in ["Healing Potion", "Mana Potion", "Strength Potion", 
                                             "Defense Potion", "Speed Potion", "Bomb"]]

                    if combat_items:
                        print("\nUsable items:")
                        for i, item in enumerate(combat_items, 1):
                            print(f"[{i}] {item}")

                        try:
                            item_choice = int(input("Choose item (0 to cancel): "))
                            if item_choice == 0:
                                continue

                            if 1 <= item_choice <= len(combat_items):
                                item_name = combat_items[item_choice - 1]

                                # Apply item effects
                                if item_name == "Healing Potion":
                                    heal_amount = int(user_data["max_health"] * 0.3)  # 30% of max health
                                    user_data["health"] = min(user_data["health"] + heal_amount, user_data["max_health"])
                                    print_animated(f"{BG_GREEN}{BLACK} ITEM USED! {ENDC}", delay=0.02)
                                    print_animated(f"You used a Healing Potion and recovered {LIGHTGREEN}{heal_amount}{ENDC} health!", delay=0.02)

                                elif item_name == "Strength Potion":
                                    # Add temporary strength buff
                                    player_status_effects.append({
                                        "name": "Strength Up",
                                        "duration": 3,
                                        "effect": {"attack": 10}
                                    })
                                    print_animated(f"{BG_GREEN}{BLACK} ITEM USED! {ENDC}", delay=0.02)
                                    print_animated("You used a Strength Potion! Attack increased for 3 turns.", delay=0.02)

                                elif item_name == "Defense Potion":
                                    # Add temporary defense buff
                                    player_status_effects.append({
                                        "name": "Defense Up",
                                        "duration": 3,
                                        "effect": {"defense": 10}
                                    })
                                    print_animated(f"{BG_GREEN}{BLACK} ITEM USED! {ENDC}", delay=0.02)
                                    print_animated("You used a Defense Potion! Defense increased for 3 turns.", delay=0.02)

                                elif item_name == "Speed Potion":
                                    # Add temporary speed buff
                                    player_status_effects.append({
                                        "name": "Speed Up",
                                        "duration": 3,
                                        "effect": {"speed": 5}
                                    })
                                    print_animated(f"{BG_GREEN}{BLACK} ITEM USED! {ENDC}", delay=0.02)
                                    print_animated("You used a Speed Potion! Speed increased for 3 turns.", delay=0.02)

                                elif item_name == "Bomb":
                                    # Deal direct damage to monster
                                    bomb_damage = 50  # Fixed damage
                                    monster_health -= bomb_damage
                                    print_animated(f"{BG_GREEN}{BLACK} ITEM USED! {ENDC}", delay=0.02)
                                    print_animated(f"You threw a Bomb! The {monster_name} takes {LIGHTRED}{bomb_damage}{ENDC} damage!", delay=0.02)

                                # Remove the item after use
                                user_data["inventory"].remove(item_name)

                            else:
                                print("Invalid item choice.")

                        except ValueError:
                            print("Invalid input.")
                    else:
                        print(f"{YELLOW}You have no usable combat items!{ENDC}")
                        continue

                elif choice == "4" and active_pet and active_pet.get("abilities", []):  # Pet Command
                    # Get active pet abilities
                    pet_abilities = []
                    pet_stats = user_data["pet_stats"].get(active_pet["name"], {}).get("level", 1)
                    pet_loyalty = user_data["pet_stats"].get(active_pet["name"], {}).get("loyalty", 50)

                    # Get abilities available at current pet level
                    for level_req, ability_name in active_pet.get("abilities", {}).items():
                        if int(level_req) <= pet_stats:
                            pet_abilities.append(ability_name)

                    if not pet_abilities:
                        print_animated(f"{YELLOW}{active_pet['name']} doesn't know any abilities yet. Train your pet more!{ENDC}", delay=0.02)
                        continue

                    # Display pet abilities
                    print(f"\n{CYAN}{active_pet['name']}'s Abilities:{ENDC}")
                    for i, ability in enumerate(pet_abilities, 1):
                        ability_desc = ABILITY_DESCRIPTIONS.get(ability, "No description available")
                        print(f"{i}. {MAGENTA}{ability}{ENDC} - {ability_desc}")

                    print(f"0. {YELLOW}Back{ENDC}")

                    try:
                        ability_choice = int(input("Choose ability (0 to cancel): "))
                        if ability_choice == 0:
                            continue

                        if 1 <= ability_choice <= len(pet_abilities):
                            selected_ability = pet_abilities[ability_choice-1]

                            # Check loyalty for ability success
                            loyalty_check_passed = True
                            if pet_loyalty < 30 and random.random() < 0.3:  # 30% chance to fail at low loyalty
                                print_animated(f"{RED}{active_pet['name']} ignores your command!{ENDC}", delay=0.02)
                                loyalty_check_passed = False

                            if loyalty_check_passed:
                                # Process pet ability
                                if selected_ability == "Quick Attack":
                                    # Pet deals small damage
                                    pet_damage = int(user_data.get("attack", 10) * 0.1)  # 10% of player attack
                                    monster_health -= pet_damage
                                    print_animated(f"{CYAN}{active_pet['name']} dashes forward with a quick attack, dealing {LIGHTRED}{pet_damage}{ENDC} damage!", delay=0.02)

                                elif selected_ability == "Protective Stance":
                                    # Pet provides damage reduction
                                    pet_shield_active = True
                                    pet_shield_duration = 3
                                    print_animated(f"{CYAN}{active_pet['name']} takes a protective stance, ready to block incoming attacks!{ENDC}", delay=0.02)

                                elif selected_ability == "Flame Burst":
                                    # Pet deals fire elemental damage
                                    pet_damage = int(user_data.get("attack", 10) * 0.15)  # 15% of player attack
                                    # Apply elemental damage calculation
                                    final_damage, reaction_name, reaction_effect = calculate_elemental_damage("Fire", monster_element, pet_damage)
                                    monster_health -= final_damage

                                    print_animated(f"{CYAN}{active_pet['name']} unleashes a burst of {RED}flames{ENDC}, dealing {LIGHTRED}{final_damage}{ENDC} damage!", delay=0.02)

                                    if reaction_name:
                                        print_animated(f"{YELLOW}Elemental Reaction: {reaction_name}!{ENDC}", delay=0.02)
                                        apply_elemental_effects(monster, reaction_effect, is_player=False)

                                elif selected_ability == "Healing Mist":
                                    # Pet heals player
                                    heal_amount = int(user_data.get("max_health", 100) * 0.1)  # 10% of max health
                                    user_data["health"] = min(user_data["health"] + heal_amount, user_data["max_health"])
                                    print_animated(f"{CYAN}{active_pet['name']} creates a healing mist, restoring {GREEN}{heal_amount}{ENDC} health!", delay=0.02)

                                elif selected_ability == "Stone Shield":
                                    # Pet creates a stronger shield
                                    pet_shield_active = True
                                    pet_shield_duration = 3
                                    player_status_effects.append({
                                        "name": "Stone Shield",
                                        "duration": 3,
                                        "effect": {"defense": int(user_data.get("defense", 5) * 0.15)}  # 15% defense boost
                                    })
                                    print_animated(f"{CYAN}{active_pet['name']} creates a shield of stone around you!{ENDC}", delay=0.02)

                                elif selected_ability == "Swift Movement":
                                    # Pet increases dodge chance
                                    pet_dodge_bonus = 0.1  # +10% dodge chance
                                    player_status_effects.append({
                                        "name": "Swift Movement",
                                        "duration": 3,
                                        "effect": {"speed": int(user_data.get("speed", 5) * 0.2)}  # 20% speed boost
                                    })
                                    print_animated(f"{CYAN}{active_pet['name']} enhances your agility, making you more difficult to hit!{ENDC}", delay=0.02)

                                elif selected_ability == "Shock Strike":
                                    # Pet deals lightning damage with stun chance
                                    pet_damage = int(user_data.get("attack", 10) * 0.15)  # 15% of player attack
                                    # Apply elemental damage calculation
                                    final_damage, reaction_name, reaction_effect = calculate_elemental_damage("Lightning", monster_element, pet_damage)
                                    monster_health -= final_damage

                                    print_animated(f"{CYAN}{active_pet['name']} strikes with {YELLOW}lightning{ENDC}, dealing {LIGHTRED}{final_damage}{ENDC} damage!", delay=0.02)

                                    # Chance to stun
                                    if random.random() < 0.15:  # 15% stun chance
                                        monster_stunned = True
                                        print_animated(f"{YELLOW}The {monster_name} is stunned!{ENDC}", delay=0.02)

                                    if reaction_name:
                                        print_animated(f"{YELLOW}Elemental Reaction: {reaction_name}!{ENDC}", delay=0.02)
                                        apply_elemental_effects(monster, reaction_effect, is_player=False)

                                elif selected_ability == "Energy Pulse":
                                    # Pet deals neutral damage
                                    pet_damage = int(user_data.get("attack", 10) * 0.12)  # 12% of player attack
                                    monster_health -= pet_damage
                                    print_animated(f"{CYAN}{active_pet['name']} releases a pulse of neutral energy, dealing {LIGHTRED}{pet_damage}{ENDC} damage!", delay=0.02)

                                elif selected_ability == "Find Treasure":
                                    # No direct combat effect, will be checked during loot
                                    print_animated(f"{CYAN}{active_pet['name']} is keeping an eye out for extra treasures!{ENDC}", delay=0.02)
                                    # Just to not waste a turn
                                    pet_damage = int(user_data.get("attack", 10) * 0.05)  # 5% of player attack
                                    monster_health -= pet_damage
                                    print_animated(f"{CYAN}While searching, {active_pet['name']} deals {LIGHTRED}{pet_damage}{ENDC} damage!", delay=0.02)

                                elif selected_ability == "Intimidate":
                                    # Chance for weaker enemies to flee
                                    if monster_level < user_data.get("level", 1) and random.random() < 0.3:  # 30% chance if monster is lower level
                                        monster_health = 0  # Force end combat
                                        print_animated(f"{CYAN}{active_pet['name']} lets out a terrifying sound! The {monster_name} flees in fear!{ENDC}", delay=0.02)
                                    else:
                                        # If intimidate fails, still deal some damage and reduce enemy attack
                                        pet_damage = int(user_data.get("attack", 10) * 0.08)  # 8% of player attack
                                        monster_health -= pet_damage
                                        monster_status_effects.append({
                                            "name": "Intimidated",
                                            "duration": 2,
                                            "effect": {"attack": -int(monster["attack"] * 0.15)}  # Reduce enemy attack by 15%
                                        })
                                        print_animated(f"{CYAN}{active_pet['name']} intimidates the {monster_name}, lowering its attack power!{ENDC}", delay=0.02)

                                elif selected_ability == "Fierce Loyalty":
                                    # Only activates when player health is low, gives damage boost
                                    if user_data["health"] < user_data["max_health"] * 0.2:  # Below 20% health
                                        pet_damage = int(user_data.get("attack", 10) * 0.25)  # 25% of player attack
                                        monster_health -= pet_damage
                                        print_animated(f"{CYAN}Seeing you in danger, {active_pet['name']} attacks fiercely for {LIGHTRED}{pet_damage}{ENDC} damage!{ENDC}", delay=0.02)
                                    else:
                                        # Regular attack if health isn't low
                                        pet_damage = int(user_data.get("attack", 10) * 0.1)  # 10% of player attack
                                        monster_health -= pet_damage
                                        print_animated(f"{CYAN}{active_pet['name']} loyally attacks for {LIGHTRED}{pet_damage}{ENDC} damage!{ENDC}", delay=0.02)

                                # Pet gains experience from battle
                                if "pet_stats" not in user_data:
                                    user_data["pet_stats"] = {}

                                if active_pet["name"] not in user_data["pet_stats"]:
                                    user_data["pet_stats"][active_pet["name"]] = {
                                        "level": 1,
                                        "exp": 0,
                                        "exp_next": 100,
                                        "loyalty": 50,
                                        "abilities": [],
                                        "element": active_pet.get("element", "Nullum")
                                    }

                                # Add some exp for using ability in battle
                                user_data["pet_stats"][active_pet["name"]]["exp"] += 3

                        else:
                            print("Invalid ability selection.")
                            continue
                    except ValueError:
                        print("Please enter a valid number.")
                        continue

                elif choice == "5" and active_pet and active_pet.get("abilities", []) or choice == "4":  # Defend
                    # Reduce incoming damage and gain a small health recovery
                    defense_buff = int(user_data.get("defense", 5) * 0.5)
                    player_status_effects.append({
                        "name": "Defending",
                        "duration": 1,
                        "effect": {"defense": defense_buff}
                    })

                    # Heal a small amount
                    heal_amount = int(user_data["max_health"] * 0.05)  # 5% of max health
                    user_data["health"] = min(user_data["health"] + heal_amount, user_data["max_health"])

                    # Gain a combo point
                    combo_counter = min(combo_counter + 1, max_combo)

                    print_animated(f"{BG_BLUE}{WHITE} DEFENDING! {ENDC}", delay=0.02)
                    print_animated(f"You take a defensive stance! Reduced damage for 1 turn and recovered {LIGHTGREEN}{heal_amount}{ENDC} health.", delay=0.02)
                    print_animated(f"Combo increased to {LIGHTMAGENTA}x{combo_counter}{ENDC}!", delay=0.02)

                    # Update combat log
                    combat_log.append("defend")

                elif choice == "6" and active_pet and active_pet.get("abilities", []) or choice == "5" and not (active_pet and active_pet.get("abilities", [])):  # Flee
                    # Calculate flee chance based on speed and status
                    player_speed = user_data.get("speed", 5)
                    monster_speed = monster.get("speed", 5)

                    # Apply speed buffs from status effects
                    for effect in player_status_effects:
                        if "speed" in effect["effect"]:
                            player_speed += effect["effect"]["speed"]

                    base_chance = 0.4  # Base flee chance
                    speed_diff = player_speed - monster_speed
                    flee_chance = base_chance + (speed_diff * 0.05)

                    # Boss battles are harder to flee from
                    if monster.get("boss", False):
                        flee_chance *= 0.5

                    # Clamp between 10% and 90%
                    flee_chance = max(0.1, min(flee_chance, 0.9))

                    # Roll for success
                    if random.random() < flee_chance:
                        print_animated(f"{BG_GREEN}{BLACK} ESCAPED! {ENDC}", delay=0.02)
                        print_animated("You successfully fled from battle!", delay=0.02)
                        return
                    else:
                        print_animated(f"{BG_RED}{WHITE} FAILED TO ESCAPE! {ENDC}", delay=0.02)
                        print_animated("You couldn't escape!", delay=0.02)
                        # Reset combo after failed flee
                        combo_counter = 0
                        combat_log = []

                else:
                    print(f"{YELLOW}Invalid choice!{ENDC}")
                    continue

            # Update status effects
            player_status_effects = [effect for effect in player_status_effects if effect["duration"] > 0]
            for effect in player_status_effects:
                effect["duration"] -= 1

            monster_status_effects = [effect for effect in monster_status_effects if effect["duration"] > 0]
            for effect in monster_status_effects:
                effect["duration"] -= 1

            # Monster's turn if it's still alive and not stunned
            if monster_health > 0:
                if monster_stunned:
                    print_animated(f"The {monster_name} is stunned and cannot attack!", LIGHTYELLOW, delay=0.02)
                    monster_stunned = False  # Reset stun for next turn
                else:
                    print_animated(f"\n{LIGHTRED}Enemy's turn!{ENDC}", delay=0.02)

                    # Calculate base monster damage
                    monster_attack = monster["attack"]

                    # Calculate player defense with equipment and status effects
                    defense_bonus = user_data.get("equipped", {}).get("armor", {}).get("effect", 0)
                    for effect in player_status_effects:
                        if "defense" in effect["effect"]:
                            defense_bonus += effect["effect"]["defense"]

                    # Calculate final damage
                    damage_taken = max(1, monster_attack - defense_bonus)

                    # Check for pet shield effect
                    if pet_shield_active and pet_shield_duration > 0 and active_pet:
                        # Check for Protective Stance ability
                        if "Protective Stance" in active_pet.get("abilities", {}).values():
                            # 20% chance to block damage
                            if random.random() < 0.2:
                                blocked_damage = int(damage_taken * 0.3)  # Block 30% of damage
                                damage_taken -= blocked_damage
                                print_animated(f"{CYAN}{active_pet['name']} blocks {blocked_damage} damage!{ENDC}", delay=0.02)

                        # Decrement pet shield duration
                        pet_shield_duration -= 1
                        if pet_shield_duration <= 0:
                            pet_shield_active = False
                            print_animated(f"{YELLOW}{active_pet['name']}'s protective stance ends.{ENDC}", delay=0.02)

                    # Check for dodge
                    player_speed = user_data.get("speed", 5)
                    for effect in player_status_effects:
                        if "speed" in effect["effect"]:
                            player_speed += effect["effect"]["speed"]

                    dodge_chance = DODGE_CHANCE + (player_speed * 0.01)  # Speed increases dodge chance

                    # Add pet dodge bonus if active
                    if pet_dodge_bonus > 0:
                        dodge_chance += pet_dodge_bonus

                    dodge_chance = min(dodge_chance, 0.5)  # Cap at 50%

                    if random.random() < dodge_chance:
                        print_animated(f"{BG_CYAN}{BLACK} DODGE! {ENDC}", delay=0.02)
                        print_animated("You dodged the attack!", delay=0.02)
                    else:
                        # Apply damage to player
                        user_data["health"] -= damage_taken

                        # Check for critical hit from monster
                        if random.random() < 0.1:  # 10% monster crit chance
                            damage_taken = int(damage_taken * 1.5)
                            print_animated(f"{BG_RED}{WHITE} CRITICAL HIT! {ENDC}", delay=0.02)

                        print_animated(f"The {monster_name} attacks and deals {LIGHTRED}{damage_taken}{ENDC} damage!", delay=0.02)

                        # Apply monster attack effects
                        if "effects" in monster:
                            for effect_name, chance in monster["effects"].items():
                                if random.random() < chance:
                                    if effect_name == "poison":
                                        player_status_effects.append({
                                            "name": "Poisoned",
                                            "duration": 3,
                                            "effect": {"poison_damage": int(user_data["max_health"] * 0.05)}
                                        })
                                        print_animated(f"{LIGHTGREEN}You have been poisoned!{ENDC}", delay=0.02)
                                    elif effect_name == "stun":
                                        stunned = True
                                        print_animated(f"{LIGHTYELLOW}You have been stunned!{ENDC}", delay=0.02)
                                    elif effect_name == "burn":
                                        player_status_effects.append({
                                            "name": "Burning",
                                            "duration": 2,
                                            "effect": {"burn_damage": int(user_data["max_health"] * 0.07)}
                                        })
                                        print_animated(f"{LIGHTRED}You are burning!{ENDC}", delay=0.02)

                    # Apply damage over time effects
                    for effect in player_status_effects:
                        if "poison_damage" in effect["effect"]:
                            poison_damage = effect["effect"]["poison_damage"]
                            user_data["health"] -= poison_damage
                            print_animated(f"{LIGHTGREEN}Poison deals {poison_damage} damage!{ENDC}", delay=0.02)
                        elif "burn_damage" in effect["effect"]:
                            burn_damage = effect["effect"]["burn_damage"]
                            user_data["health"] -= burn_damage
                            print_animated(f"{LIGHTRED}Burning deals {burn_damage} damage!{ENDC}", delay=0.02)

        except Exception as e:
            print(f"{FAIL}Error during combat: {e}{ENDC}")
            continue

    # Combat conclusion
    print_animated(f"\n{BG_CYAN}{WHITE} BATTLE COMPLETED! {ENDC}", delay=0.05)

    if monster_health <= 0:
        print_animated(f"\n{BG_GREEN}{BLACK} VICTORY! {ENDC}", delay=0.05)
        print_animated(f"You defeated the {monster_name}!", LIGHTGREEN, delay=0.03)

        # Calculate experience and rewards
        exp_gain = monster["level"] * 20

        # Bonus exp for higher level monsters
        if monster["level"] > user_data["level"]:
            level_diff = monster["level"] - user_data["level"]
            exp_bonus = int(exp_gain * (level_diff * 0.2))  # 20% more exp per level difference
            exp_gain += exp_bonus
            print_animated(f"Bonus EXP for defeating a stronger enemy: +{exp_bonus}!", LIGHTCYAN, delay=0.02)

        user_data["exp"] += exp_gain
        print_animated(f"Gained {LIGHTCYAN}{exp_gain}{ENDC} experience!", delay=0.02)

        # Increment monsters killed count
        user_data["monsters_killed"] += 1

        # Increment specific monster type counter
        monster_type = monster.get("type", "unknown")
        if "monster_types_killed" not in user_data:
            user_data["monster_types_killed"] = {}
        user_data["monster_types_killed"][monster_type] = user_data["monster_types_killed"].get(monster_type, 0) + 1

        # Check for achievements
        check_achievements()

        # Check if monster is a boss
        if monster.get("boss", False):
            print_animated(f"{BG_MAGENTA}{WHITE} BOSS DEFEATED! {ENDC}", delay=0.05)
            print_animated(f"Congratulations! You defeated the boss {monster_name}!", LIGHTMAGENTA, delay=0.03)

            # Award special boss rewards
            bonus_gold = monster["level"] * 50
            user_data["gold"] += bonus_gold
            print_animated(f"Bonus reward: {LIGHTYELLOW}{bonus_gold} gold{ENDC}!", delay=0.02)

            # Initialize adventurer data if it doesn't exist
            if "adventurer" not in user_data:
                user_data["adventurer"] = {
                    "rank": "Novice",
                    "exp": 0,
                    "level": 1,
                    "total_quests": 0,
                    "bosses_defeated": 0,
                    "reputation": 0
                }

            # Increment boss counter
            user_data["adventurer"]["bosses_defeated"] += 1

            # Award adventurer experience (boss level * 20)
            boss_level = monster.get("level", 1)
            adv_exp = boss_level * 20
            add_adventurer_exp(adv_exp)

            # Display adventurer rewards
            print_animated(f"\n{CYAN}Adventurer's Guild:{ENDC} Boss defeated!", delay=0.02)
            print_animated(f"{CYAN}+{adv_exp} Adventurer EXP{ENDC}", delay=0.02)
            print_animated(f"{CYAN}Bosses Defeated:{ENDC} {user_data['adventurer']['bosses_defeated']}", delay=0.02)

            # Check if rank advancement is available
            check_rank_advancement()

            # Check for level up
            check_level_up()
        else:
            # Regular monsters also give some adventurer exp
            if "adventurer" in user_data:
                # Award small amount of adventurer experience (monster level * 2)
                monster_level = monster.get("level", 1)
                adv_exp = max(5, monster_level * 2)  # Minimum 5 exp
                add_adventurer_exp(adv_exp)

                # Only show message if it's at least 10 exp
                if adv_exp >= 10:
                    print_animated(f"{CYAN}+{adv_exp} Adventurer EXP{ENDC}", delay=0.02)

            # Check for level up
            check_level_up()

        # Handle loot
        loot(monster)
    else:
        print_animated(f"\n{BG_RED}{WHITE} DEFEAT! {ENDC}", delay=0.05)
        print_animated("You were defeated!", LIGHTRED, delay=0.03)
        user_data["health"] = 1  # Prevent death, set to 1 HP

        # Lose some gold on defeat
        if user_data["gold"] > 0:
            gold_loss = max(1, int(user_data["gold"] * 0.1))  # Lose 10% of gold
            user_data["gold"] -= gold_loss
            print_animated(f"You lost {LIGHTYELLOW}{gold_loss} gold{ENDC}!", delay=0.02)

        print_animated("Rest at an inn or use a healing potion to recover.", LIGHTCYAN, delay=0.02)

# Utility functions for the enhanced combat system
def create_health_bar(percent: float, length: int = 20) -> str:
    """Creates a visual health bar based on percentage"""
    filled_length = int(length * percent)
    empty_length = length - filled_length

    if percent > 0.7:
        bar_color = LIGHTGREEN
    elif percent > 0.3:
        bar_color = LIGHTYELLOW
    else:
        bar_color = LIGHTRED

    bar = f"{bar_color}{'█' * filled_length}{GREY}{'▒' * empty_length}{ENDC}"
    return bar

def get_attack_verb(combo: int) -> str:
    """Returns a different attack verb based on combo counter for variety"""
    if combo == 0:
        return random.choice(["strike", "hit", "attack"])
    elif combo == 1:
        return random.choice(["slash", "smash", "strike"])
    elif combo == 2:
        return random.choice(["thrash", "pummel", "devastate"])
    else:
        return random.choice(["obliterate", "annihilate", "demolish"])

def get_element_color(element: str) -> str:
    """Returns the appropriate color code for an element"""
    element_colors = {
        "Fire": LIGHTRED,
        "Water": LIGHTBLUE,
        "Earth": LIGHTGREEN,
        "Air": LIGHTCYAN,
        "Lightning": LIGHTYELLOW,
        "Ice": CYAN,
        "Light": WHITE,
        "Dark": GREY,
        "Poison": GREEN,
        "Normal": WHITE
    }
    return element_colors.get(element, WHITE)

def get_save_slots() -> List[str]:
    saves = [f for f in os.listdir() if f.startswith("save_") and f.endswith(".json")]
    return sorted(saves)

def get_save_directory() -> str:
    save_dir = os.path.join(os.getcwd(), "saves")
    os.makedirs(save_dir, exist_ok=True)
    return save_dir

def save_game(slot: int = 1, auto: bool = False) -> None:
    try:
        # Convert any set objects to lists for JSON serialization
        prepared_user_data = prepare_user_data_for_save(user_data)

        # Capture comprehensive game state
        save_data = {
            # Core user data with all progression
            "user_data": prepared_user_data,
            
            # Game metadata and versioning
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "version": "2.0_ultimate",
            "gacha_version": "2.0",
            "save_format_version": "2.0",
            
            # Character progression and statistics
            "character_stats": {
                "level": user_data.get("level", 1),
                "experience": user_data.get("experience", 0),
                "skill_points": user_data.get("skill_points", 0),
                "total_playtime": user_data.get("total_playtime", 0),
                "creation_date": user_data.get("creation_date", datetime.now().isoformat()),
                "last_login": user_data.get("last_login", datetime.now().isoformat()),
                "login_streak": user_data.get("login_streak", 0),
                "total_sessions": user_data.get("total_sessions", 0)
            },
            
            # Story and quest progression
            "story_progress": {
                "current_chapter": user_data.get("current_chapter", 1),
                "completed_quests": user_data.get("completed_quests", []),
                "active_quests": user_data.get("active_quests", []),
                "story_flags": user_data.get("story_flags", {}),
                "dialogue_history": user_data.get("dialogue_history", []),
                "choices_made": user_data.get("choices_made", {}),
                "unlocked_content": user_data.get("unlocked_content", []),
                "discovered_lore": user_data.get("discovered_lore", [])
            },
            
            # Inventory and equipment comprehensive data
            "inventory_data": {
                "items": user_data.get("inventory", {}),
                "equipment": user_data.get("equipment", {}),
                "consumables": user_data.get("consumables", {}),
                "materials": user_data.get("materials", {}),
                "currency": user_data.get("currency", 0),
                "bank_storage": user_data.get("bank_storage", {}),
                "item_history": user_data.get("item_acquisition_history", []),
                "crafting_recipes": user_data.get("known_recipes", []),
                "upgrade_materials": user_data.get("upgrade_materials", {})
            },
            
            # Gacha and collection system
            "gacha_data": {
                "pulls_total": user_data.get("gacha_pulls_total", 0),
                "pulls_history": user_data.get("gacha_history", []),
                "pity_counter": user_data.get("pity_counter", 0),
                "guaranteed_counter": user_data.get("guaranteed_counter", 0),
                "collection_book": user_data.get("collection_book", {}),
                "rare_items_obtained": user_data.get("rare_collection", []),
                "gacha_currency": user_data.get("gacha_currency", 0),
                "banners_pulled": user_data.get("banners_history", {}),
                "luck_statistics": user_data.get("gacha_luck_stats", {})
            },
            
            # Achievement and milestone tracking
            "achievements": {
                "unlocked_achievements": user_data.get("achievements", []),
                "achievement_progress": user_data.get("achievement_progress", {}),
                "milestones_reached": user_data.get("milestones", []),
                "records_set": user_data.get("personal_records", {}),
                "badges_earned": user_data.get("badges", []),
                "titles_unlocked": user_data.get("titles", []),
                "active_title": user_data.get("active_title", None)
            },
            
            # Settings and preferences
            "user_settings": {
                "game_preferences": user_data.get("settings", {}),
                "display_options": user_data.get("display_settings", {}),
                "audio_settings": user_data.get("audio_settings", {}),
                "control_mappings": user_data.get("controls", {}),
                "notification_preferences": user_data.get("notifications", {}),
                "accessibility_options": user_data.get("accessibility", {}),
                "language_preference": user_data.get("language", "en")
            },
            
            # Social and multiplayer data
            "social_data": {
                "friends_list": user_data.get("friends", []),
                "guild_membership": user_data.get("guild", {}),
                "trading_history": user_data.get("trades", []),
                "reputation": user_data.get("reputation", 0),
                "social_interactions": user_data.get("social_log", []),
                "blocked_players": user_data.get("blocked", []),
                "favorite_players": user_data.get("favorites", [])
            },
            
            # Game world state and exploration
            "world_state": {
                "visited_locations": user_data.get("visited_locations", []),
                "unlocked_areas": user_data.get("unlocked_areas", []),
                "discovered_secrets": user_data.get("secrets_found", []),
                "world_events_witnessed": user_data.get("world_events", []),
                "exploration_percentage": user_data.get("exploration_progress", 0),
                "map_revelations": user_data.get("map_data", {}),
                "environmental_interactions": user_data.get("environment_log", [])
            },
            
            # Combat and battle statistics
            "combat_data": {
                "battles_fought": user_data.get("battles_total", 0),
                "battles_won": user_data.get("battles_won", 0),
                "battles_lost": user_data.get("battles_lost", 0),
                "perfect_victories": user_data.get("perfect_wins", 0),
                "damage_dealt": user_data.get("total_damage_dealt", 0),
                "damage_taken": user_data.get("total_damage_taken", 0),
                "abilities_used": user_data.get("ability_usage_stats", {}),
                "strategies_employed": user_data.get("battle_strategies", {}),
                "boss_defeats": user_data.get("bosses_defeated", [])
            },
            
            # Seasonal and event data
            "event_data": {
                "seasonal_progress": user_data.get("seasonal_data", {}),
                "event_participation": user_data.get("event_history", []),
                "seasonal_rewards": user_data.get("seasonal_rewards", []),
                "limited_content_accessed": user_data.get("limited_content", []),
                "holiday_celebrations": user_data.get("holiday_data", {}),
                "special_achievements": user_data.get("special_achievements", [])
            },
            
            # Performance and analytics
            "analytics": {
                "session_durations": user_data.get("session_times", []),
                "feature_usage": user_data.get("feature_stats", {}),
                "error_encounters": user_data.get("error_log", []),
                "performance_metrics": user_data.get("performance_data", {}),
                "user_feedback": user_data.get("feedback_history", []),
                "beta_participation": user_data.get("beta_features", [])
            }
        }

        save_dir = get_save_directory()
        filename = os.path.join(save_dir, f"save_{slot}.json")

        # Create backup of existing save
        if os.path.exists(filename):
            backup_file = f"{filename}.backup"
            os.replace(filename, backup_file)

        with open(filename, "w") as f:
            json.dump(save_data, f, indent=2)
        if not auto:
            print(f"Game saved successfully in slot {slot}!")
    except Exception as e:
        print(f"Error saving game: {e}")


def prepare_user_data_for_save(data: Dict) -> Dict:
    """
    Prepare user data for saving by converting sets to lists
    and handling any other special data types.
    """
    prepared_data = {}

    # Handle nested dictionaries through recursion
    for key, value in data.items():
        if isinstance(value, set):
            # Convert sets to lists
            prepared_data[key] = list(value)
        elif isinstance(value, dict):
            # Recursively handle nested dictionaries
            prepared_data[key] = prepare_user_data_for_save(value)
        elif isinstance(value, list):
            # Handle lists of dictionaries or sets
            prepared_list = []
            for item in value:
                if isinstance(item, dict):
                    prepared_list.append(prepare_user_data_for_save(item))
                elif isinstance(item, set):
                    prepared_list.append(list(item))
                else:
                    prepared_list.append(item)
            prepared_data[key] = prepared_list
        else:
            # No conversion needed
            prepared_data[key] = value

    return prepared_data

def load_game(slot: int = 1) -> bool:
    save_dir = get_save_directory()
    filename = os.path.join(save_dir, f"save_{slot}.json")

    try:
        if not os.path.exists(filename):
            print(f"No saved game found in slot {slot}.")
            return False

        with open(filename, "r", encoding='utf-8') as f:
            save_data = json.load(f)
            saved_version = save_data.get("version", "1.0")

            # Handle version differences
            if saved_version != "1.1":
                print("Notice: Converting save file to latest version...")

            global user_data
            user_data = save_data["user_data"]

            # Convert any lists back to sets where needed
            user_data = restore_sets_from_lists(user_data)

            # Ensure all required keys exist
            ensure_user_data_keys(user_data)

            # Apply any necessary version-specific migrations
            if "gacha_version" not in save_data or save_data["gacha_version"] != "1.0":
                print("Migrating gacha system data...")
                migrate_gacha_data(user_data)

            # Ensure all gacha system components are fully initialized
            ensure_gacha_system_initialized(user_data)

            # Ensure all archaeology system components are fully initialized
            ensure_archaeology_system_initialized(user_data)

            # Update archaeology and gacha systems interaction
            if "archaeology" in user_data and "gacha" in user_data:
                calculate_archaeology_gacha_bonuses(user_data)

            # Create deep connections between all game systems
            integrate_all_systems()

            print(f"Game loaded successfully from slot {slot}!")
            print(f"Save timestamp: {save_data['timestamp']}")

            # Update daily login reward if player logs in on a new day
            check_daily_login_reward()

            return True
    except Exception as e:
        print(f"Error loading game: {e}")
        # Try to load backup if it exists
        backup_file = f"{filename}.backup"
        if os.path.exists(backup_file):
            print("Attempting to load backup...")
            try:
                with open(backup_file, "r", encoding='utf-8') as f:
                    save_data = json.load(f)
                    user_data = save_data["user_data"]
                    user_data = restore_sets_from_lists(user_data)
                    ensure_user_data_keys(user_data)
                    ensure_gacha_system_initialized(user_data)
                    ensure_archaeology_system_initialized(user_data)
                    calculate_archaeology_gacha_bonuses(user_data)
                    print("Backup loaded successfully!")
                    return True
            except Exception as be:
                print(f"Backup load failed: {be}")
        return False


def restore_sets_from_lists(data: Dict[str, Any]) -> None:
    """
    Restores sets from lists in the loaded data.
    Used for achievement sets and other set data structures that were converted to lists for saving.
    """
    if not isinstance(data, dict):
        return data

    result = {}
    for key, value in data.items():
        if isinstance(value, dict):
            # Recursively process nested dictionaries
            result[key] = restore_sets_from_lists(value)
        elif isinstance(value, list):
            # Special case for achievements.completed and achievements.stats.areas_visited which should be sets
            if key == "completed" and "achievements" in result:
                result[key] = set(value)
            elif key == "areas_visited" and "stats" in result and "achievements" in data:
                result[key] = set(value)
            else:
                # Process list items
                processed_list = []
                for item in value:
                    if isinstance(item, dict):
                        processed_list.append(restore_sets_from_lists(item))
                    else:
                        processed_list.append(item)
                result[key] = processed_list
        else:
            result[key] = value

    # Special case for achievement data
    if "achievements" in data and isinstance(data["achievements"], dict):
        if "completed" in data["achievements"] and isinstance(data["achievements"]["completed"], list):
            result.setdefault("achievements", {})["completed"] = set(data["achievements"]["completed"])

        if "stats" in data["achievements"] and isinstance(data["achievements"]["stats"], dict):
            if "areas_visited" in data["achievements"]["stats"] and isinstance(data["achievements"]["stats"]["areas_visited"], list):
                result.setdefault("achievements", {}).setdefault("stats", {})["areas_visited"] = set(data["achievements"]["stats"]["areas_visited"])

    return result


def integrate_all_systems() -> None:
    """
    Creates deep connections between archaeology, literature, and gacha systems.
    This function implements synergies that allow each system to enhance the others.

    Important: This is called after loading a game and at key points during gameplay
    to ensure all systems properly interact and provide benefits to each other.

    Returns:
        bool: True if integration was successful with multiple systems interacting
    """
    global user_data

    # Track progress in each system to determine integration possibilities
    systems_progress = 0

    # Check progress in archaeology system
    if "archaeology" in user_data:
        arch_data = user_data["archaeology"]
        if arch_data.get("excavated_artifacts", []):
            systems_progress += 1

        # Apply archaeology bonuses to character gacha system
        if "gacha" in user_data and arch_data.get("knowledge", []):
            # Archaeological knowledge can increase pull rates
            knowledge_count = len(arch_data.get("knowledge", []))
            if knowledge_count > 0:
                # Increase 5-star character/weapon rate based on knowledge
                bonus_rate = min(0.02, knowledge_count * 0.005)  # Max 2% bonus
                if "pull_rates" not in user_data["gacha"]:
                    user_data["gacha"]["pull_rates"] = {}
                user_data["gacha"]["pull_rates"]["archaeology_bonus"] = bonus_rate

            # Complete artifact sets provide character bonuses
            if "completed_sets" in arch_data and arch_data["completed_sets"]:
                for char_id, char_data in user_data["gacha"].get("characters", {}).items():
                    # Apply bonuses to matching characters based on artifact themes
                    for set_name in arch_data["completed_sets"]:
                        # Temple collection benefits magical characters
                        if set_name == "Temple Collection" and char_data.get("element") in ["Fire", "Water", "Light"]:
                            char_data["bonus_stats"] = char_data.get("bonus_stats", {})
                            char_data["bonus_stats"]["magic_power"] = char_data["bonus_stats"].get("magic_power", 0) + 15

                        # Mining collection benefits earth characters
                        elif set_name == "Mining Collection" and char_data.get("element") == "Earth":
                            char_data["bonus_stats"] = char_data.get("bonus_stats", {})
                            char_data["bonus_stats"]["defense"] = char_data["bonus_stats"].get("defense", 0) + 20

                        # Royal collection benefits all characters
                        elif set_name == "Royal Collection":
                            char_data["bonus_stats"] = char_data.get("bonus_stats", {})
                            char_data["bonus_stats"]["leadership"] = char_data["bonus_stats"].get("leadership", 0) + 10

    # Check progress in literature system
    if "literature" in user_data:
        lit_data = user_data["literature"]
        read_books = [book for book_id, book in lit_data.get("books", {}).items() if book.get("read", False)]
        if read_books:
            systems_progress += 1

        # Apply literature bonuses to characters
        if "gacha" in user_data and read_books:
            # Reading books provides character bonuses
            for char_id, char_data in user_data["gacha"].get("characters", {}).items():
                # Initialize bonus stats if needed
                if "bonus_stats" not in char_data:
                    char_data["bonus_stats"] = {}

                # Each read book gives a small bonus based on book type and character class
                read_count = len(read_books)
                char_class = char_data.get("class", "")

                if char_class == "Scholar":
                    char_data["bonus_stats"]["intelligence"] = char_data["bonus_stats"].get("intelligence", 0) + (read_count * 3)
                elif char_class == "Warrior":
                    char_data["bonus_stats"]["strength"] = char_data["bonus_stats"].get("strength", 0) + (read_count)
                elif char_class == "Mage":
                    char_data["bonus_stats"]["magic_power"] = char_data["bonus_stats"].get("magic_power", 0) + (read_count * 2)
                else:
                    # Default bonus for all other classes
                    char_data["bonus_stats"]["knowledge"] = char_data["bonus_stats"].get("knowledge", 0) + (read_count)

    # Check progress in gacha system
    if "gacha" in user_data:
        # Check if player has characters
        if user_data["gacha"].get("characters", {}):
            systems_progress += 1

        # Characters can provide archaeology bonuses
        if "archaeology" in user_data:
            # Calculate archaeology bonuses from characters
            skill_bonuses = {"excavation": 0, "analysis": 0}
            rare_find_chance = 0
            artifacts_expertise = []

            # Apply character bonuses to archaeology
            for char_id, char_info in user_data["gacha"].get("characters", {}).items():
                if not char_info.get("active", False):
                    continue  # Only apply bonuses from active characters

                char_class = char_info.get("class", "")
                char_element = char_info.get("element", "")

                # Different classes help with different archaeology skills
                if char_class == "Warrior":
                    skill_bonuses["excavation"] += 2  # Warriors help with digging
                elif char_class == "Mage":
                    skill_bonuses["analysis"] += 2  # Mages help with analysis
                elif char_class == "Scholar":
                    skill_bonuses["analysis"] += 3  # Scholars are best at analysis
                elif char_class == "Explorer":
                    skill_bonuses["excavation"] += 3  # Explorers are best at excavation

                # Elements can provide special archaeology benefits
                if char_element == "Earth":
                    skill_bonuses["excavation"] += 2  # Earth characters have affinity for digging
                    rare_find_chance += 0.05  # 5% better chance for rare finds
                elif char_element == "Water":
                    skill_bonuses["analysis"] += 1  # Water helps clean artifacts
                elif char_element == "Fire":
                    rare_find_chance += 0.03  # Fire illuminates hidden treasures

                # Add character expertise to archaeology system
                char_expertise = char_info.get("archaeology_expertise", [])
                if char_expertise:
                    artifacts_expertise.extend(char_expertise)

            # Apply the bonuses to archaeology system
            if skill_bonuses["excavation"] > 0:
                user_data["archaeology"]["excavation_skill"] = user_data["archaeology"].get("excavation_skill", 1) + skill_bonuses["excavation"]
            if skill_bonuses["analysis"] > 0:
                user_data["archaeology"]["analysis_skill"] = user_data["archaeology"].get("analysis_skill", 1) + skill_bonuses["analysis"]
            if rare_find_chance > 0:
                user_data["archaeology"]["rare_find_bonus"] = user_data["archaeology"].get("rare_find_bonus", 0) + rare_find_chance

    # Check if all systems have synergy effects to apply
    if systems_progress >= 2:
        # Create synergy effects when multiple systems have progress

        # 1. Archaeological discoveries can unlock special character abilities
        if "archaeology" in user_data and "gacha" in user_data:
            arch_data = user_data["archaeology"]
            knowledge_list = arch_data.get("knowledge", [])

            # Each type of knowledge can unlock special abilities for matching characters
            for knowledge_name in knowledge_list:
                if knowledge_name == "Temple Civilization":
                    # Improves magical characters
                    for char_id, char_data in user_data["gacha"].get("characters", {}).items():
                        if char_data.get("element") in ["Fire", "Water", "Light"]:
                            if "special_abilities" not in char_data:
                                char_data["special_abilities"] = []
                            if "Divine Ritual" not in char_data["special_abilities"]:
                                char_data["special_abilities"].append("Divine Ritual")

                elif knowledge_name == "Mining Technologies":
                    # Improves earth and physical characters
                    for char_id, char_data in user_data["gacha"].get("characters", {}).items():
                        if char_data.get("element") == "Earth" or char_data.get("class") == "Warrior":
                            if "special_abilities" not in char_data:
                                char_data["special_abilities"] = []
                            if "Treasure Hunter" not in char_data["special_abilities"]:
                                char_data["special_abilities"].append("Treasure Hunter")

                elif knowledge_name == "Ancient Astronomy":
                    # Improves all characters with cosmic awareness
                    for char_id, char_data in user_data["gacha"].get("characters", {}).items():
                        if "special_abilities" not in char_data:
                            char_data["special_abilities"] = []
                        if "Celestial Navigation" not in char_data["special_abilities"]:
                            char_data["special_abilities"].append("Celestial Navigation")

        # 2. Literature knowledge and character combination can yield unique research insights
        if "literature" in user_data and "gacha" in user_data:
            lit_data = user_data["literature"]
            read_books = [book for book_id, book in lit_data.get("books", {}).items() if book.get("read", False)]

            if read_books and len(read_books) >= 3 and "archaeology" in user_data:
                # Reading multiple books improves archaeological research
                research_bonus = min(50, len(read_books) * 5)  # Up to 50% research bonus
                user_data["archaeology"]["research_bonus"] = user_data["archaeology"].get("research_bonus", 0) + research_bonus

        # 3. Complete archaeological sets can yield special character-specific weapons
        if "archaeology" in user_data and "gacha" in user_data:
            arch_data = user_data["archaeology"]
            completed_sets = arch_data.get("completed_sets", [])

            if completed_sets:
                # Each completed set can unlock a special weapon for appropriate characters
                for char_id, char_data in user_data["gacha"].get("characters", {}).items():
                    if "Royal Collection" in completed_sets and char_data.get("rarity", "") == "5-Star":
                        # Add royal weapon for 5-star characters
                        if "special_weapons" not in char_data:
                            char_data["special_weapons"] = []
                        if "Royal Armament" not in char_data["special_weapons"]:
                            char_data["special_weapons"].append("Royal Armament")

    # Return True if integration had effects to apply
    return systems_progress >= 2

def ensure_archaeology_system_initialized(data: Dict[str, Any]) -> None:
    """
    Ensures all archaeology system components are properly initialized.
    Handles specific archaeology system structures not covered by the general ensure_user_data_keys.
    """
    if "archaeology" not in data:
        data["archaeology"] = {
            "discovered_sites": [],
            "excavated_artifacts": [],
            "knowledge": [],
            "tools": ["Basic Trowel"],
            "museum_exhibits": [],
            "excavation_skill": 1,
            "analysis_skill": 1,
            "artifact_collections": {},
            "site_levels": {},
            "current_site": None,
            "rare_discoveries": [],
            "excavation_dates": {},
            "last_excavation": None
        }

    arch = data["archaeology"]

    # Ensure all archaeology keys exist
    if "artifact_collections" not in arch:
        arch["artifact_collections"] = {}

        # Initialize collections based on existing artifacts
        if "excavated_artifacts" in arch and arch["excavated_artifacts"]:
            for artifact in arch["excavated_artifacts"]:
                if artifact in ARCHAEOLOGICAL_ARTIFACTS:
                    collection = ARCHAEOLOGICAL_ARTIFACTS[artifact].get("set", "Miscellaneous")
                    if collection not in arch["artifact_collections"]:
                        arch["artifact_collections"][collection] = []
                    if artifact not in arch["artifact_collections"][collection]:
                        arch["artifact_collections"][collection].append(artifact)

    # Ensure site levels are tracked
    if "site_levels" not in arch:
        arch["site_levels"] = {}
        for site in arch.get("discovered_sites", []):
            arch["site_levels"][site] = 1

    # Track last excavation for daily limits
    if "last_excavation" not in arch:
        arch["last_excavation"] = None

    # Track excavation dates for statistics
    if "excavation_dates" not in arch:
        arch["excavation_dates"] = {}

    # Special discoveries list
    if "rare_discoveries" not in arch:
        arch["rare_discoveries"] = []

    # Link archaeology to gacha through ancient knowledge
    if "gacha_bonuses" not in arch:
        arch["gacha_bonuses"] = {
            "pull_rate_bonus": 0.0,  # Bonus percentage to pull rates
            "character_exp_bonus": 0.0,  # Bonus percentage to character exp gains
            "material_drop_bonus": 0.0,  # Bonus percentage to material drop rates
            "special_wish_artifacts": []  # Special artifacts that provide wish bonuses
        }

    # Process known archaeology knowledge for bonuses
    if "knowledge" in arch and arch["knowledge"]:
        calculate_archaeology_gacha_bonuses(data)


def calculate_archaeology_gacha_bonuses(data: Dict[str, Any]) -> Dict[str, float]:
    """
    Calculate gacha bonuses based on archaeological knowledge and artifacts.
    This creates synergy between the archaeology and gacha systems.
    """
    if "archaeology" not in data or "gacha" not in data:
        return

    arch = data["archaeology"]

    # Reset bonuses before recalculating
    arch["gacha_bonuses"] = {
        "pull_rate_bonus": 0.0,
        "character_exp_bonus": 0.0,
        "material_drop_bonus": 0.0,
        "special_wish_artifacts": [],
        "character_stat_bonuses": {},
        "combat_bonuses": {
            "attack": 0.0,
            "defense": 0.0,
            "health": 0.0,
            "speed": 0.0,
            "critical_rate": 0.0,
            "elemental_mastery": 0.0
        },
        "special_abilities": []
    }

    # Apply bonuses from ancient knowledge
    for knowledge_name in arch.get("knowledge", []):
        if knowledge_name in ANCIENT_KNOWLEDGE:

            # Apply specific bonuses based on knowledge type
            if knowledge_name == "Temple Civilization":
                arch["gacha_bonuses"]["pull_rate_bonus"] += 0.5  # 0.5% increased pull rates
                arch["gacha_bonuses"]["combat_bonuses"]["elemental_mastery"] += 10.0  # +10 elemental mastery
                # Character-specific bonuses
                arch["gacha_bonuses"]["character_stat_bonuses"]["Solara"] = {
                    "attack": 5,
                    "elemental_mastery": 15
                }
                arch["gacha_bonuses"]["special_abilities"].append({
                    "name": "Temple Ritual",
                    "description": "Characters gain 10% increased elemental damage due to ancient temple knowledge",
                    "effect": {"elemental_damage_bonus": 0.1}
                })

            elif knowledge_name == "Mining Techniques":
                arch["gacha_bonuses"]["material_drop_bonus"] += 5.0  # 5% increased material drops
                arch["gacha_bonuses"]["combat_bonuses"]["defense"] += 5.0  # +5% defense
                # Character-specific bonuses
                arch["gacha_bonuses"]["character_stat_bonuses"]["Adira"] = {
                    "defense": 10,
                    "health": 50
                }
                arch["gacha_bonuses"]["special_abilities"].append({
                    "name": "Ancient Mining",
                    "description": "Characters can extract extra resources from mineral-rich enemies",
                    "effect": {"bonus_materials": 0.15}
                })

            elif knowledge_name == "Ancient Warfare":
                arch["gacha_bonuses"]["character_exp_bonus"] += 3.0  # 3% increased character exp
                arch["gacha_bonuses"]["combat_bonuses"]["attack"] += 5.0  # +5% attack
                # Character-specific bonuses
                arch["gacha_bonuses"]["character_stat_bonuses"]["Kato"] = {
                    "attack": 15,
                    "critical_rate": 3.0
                }
                arch["gacha_bonuses"]["special_abilities"].append({
                    "name": "War Tactics",
                    "description": "Characters have a 5% chance to perform a coordinated strike in battle",
                    "effect": {"coordinated_strike_chance": 0.05}
                })

            elif knowledge_name == "Ancient Astronomy":
                # Astronomy gives a chance for special pulls
                arch["gacha_bonuses"]["pull_rate_bonus"] += 1.0  # 1% increased pull rates
                arch["gacha_bonuses"]["combat_bonuses"]["critical_rate"] += 3.0  # +3% critical rate
                # Character-specific bonuses
                arch["gacha_bonuses"]["character_stat_bonuses"]["Luna"] = {
                    "speed": 5,
                    "elemental_mastery": 10
                }
                arch["gacha_bonuses"]["special_abilities"].append({
                    "name": "Stellar Guidance",
                    "description": "Characters gain increased accuracy and positioning in night battles",
                    "effect": {"night_accuracy_bonus": 0.15}
                })

            elif knowledge_name == "Royal Lineage":
                # Royal knowledge improves character progression
                arch["gacha_bonuses"]["character_exp_bonus"] += 5.0  # 5% increased character exp
                arch["gacha_bonuses"]["combat_bonuses"]["health"] += 5.0  # +5% health
                # Character-specific bonuses
                arch["gacha_bonuses"]["character_stat_bonuses"]["Eldrin"] = {
                    "attack": 8,
                    "defense": 8,
                    "health": 100
                }
                arch["gacha_bonuses"]["special_abilities"].append({
                    "name": "Royal Authority",
                    "description": "Characters with royal lineage gain a command aura, providing small bonuses to all party members",
                    "effect": {"team_stat_bonus": 0.03}
                })

            elif knowledge_name == "Great War":
                # War knowledge increases weapon effectiveness
                arch["gacha_bonuses"]["material_drop_bonus"] += 3.0  # 3% increased material drops
                arch["gacha_bonuses"]["combat_bonuses"]["attack"] += 3.0  # +3% attack
                # Character-specific bonuses
                arch["gacha_bonuses"]["character_stat_bonuses"]["Vayne"] = {
                    "attack": 10,
                    "speed": 7
                }
                arch["gacha_bonuses"]["special_abilities"].append({
                    "name": "Battle Hardened",
                    "description": "Characters gain increased resistance to physical damage",
                    "effect": {"physical_resistance": 0.08}
                })

    # Apply bonuses from complete artifact collections
    for collection, artifacts in arch.get("artifact_collections", {}).items():
        # Check if collection is complete
        if collection in ["Temple Collection", "Mining Collection", "Astronomy Collection", "Royal Collection", "War Collection"]:
            collection_completed = True
            expected_artifacts = []

            # Get all artifacts that should be in this collection
            for artifact, data in ARCHAEOLOGICAL_ARTIFACTS.items():
                if data.get("set") == collection:
                    expected_artifacts.append(artifact)

            # Check if all expected artifacts are in the collection
            for expected in expected_artifacts:
                if expected not in artifacts:
                    collection_completed = False
                    break

            # Apply bonus for complete collection
            if collection_completed:
                if collection == "Temple Collection":
                    arch["gacha_bonuses"]["pull_rate_bonus"] += 1.0  # 1% increased pull rates
                    arch["gacha_bonuses"]["special_wish_artifacts"].append("Ritual Mask")
                    # Increased elemental damage for all characters
                    arch["gacha_bonuses"]["combat_bonuses"]["elemental_mastery"] += 15.0
                    # Unlock special temple-themed cosmetics for characters
                    if "collection_cosmetics" not in arch["gacha_bonuses"]:
                        arch["gacha_bonuses"]["collection_cosmetics"] = {}
                    arch["gacha_bonuses"]["collection_cosmetics"]["Temple"] = [
                        "High Priest's Robes", "Sacred Headdress", "Temple Guardian Armor"
                    ]
                    # Unlock special temple battle arena
                    if "special_arenas" not in arch["gacha_bonuses"]:
                        arch["gacha_bonuses"]["special_arenas"] = []
                    arch["gacha_bonuses"]["special_arenas"].append("Ancient Temple Arena")

                elif collection == "Mining Collection":
                    arch["gacha_bonuses"]["material_drop_bonus"] += 10.0  # 10% increased material drops
                    arch["gacha_bonuses"]["special_wish_artifacts"].append("Mineral Specimen")
                    # Better mining resource drops
                    arch["gacha_bonuses"]["mining_efficiency"] = 1.25  # 25% better mining yields
                    # Unlock mining cosmetics
                    if "collection_cosmetics" not in arch["gacha_bonuses"]:
                        arch["gacha_bonuses"]["collection_cosmetics"] = {}
                    arch["gacha_bonuses"]["collection_cosmetics"]["Mining"] = [
                        "Miner's Outfit", "Crystal Crown", "Gem-studded Armor"
                    ]
                    # Special ability to find rare minerals during excavations
                    arch["gacha_bonuses"]["special_abilities"].append({
                        "name": "Mineral Sense",
                        "description": "Characters can detect rare minerals and gems during excavations",
                        "effect": {"rare_mineral_chance": 0.15}
                    })

                elif collection == "Astronomy Collection":
                    arch["gacha_bonuses"]["pull_rate_bonus"] += 2.0  # 2% increased pull rates
                    arch["gacha_bonuses"]["special_wish_artifacts"].append("Celestial Globe")
                    # Stars and cosmos themed abilities
                    arch["gacha_bonuses"]["combat_bonuses"]["critical_rate"] += 5.0
                    # Special star-themed cosmetics
                    if "collection_cosmetics" not in arch["gacha_bonuses"]:
                        arch["gacha_bonuses"]["collection_cosmetics"] = {}
                    arch["gacha_bonuses"]["collection_cosmetics"]["Astronomy"] = [
                        "Star Mage Robes", "Constellation Crown", "Celestial Armor"
                    ]
                    # Integration with literature system - unlock cosmic literature
                    if "unlocked_literature" not in arch["gacha_bonuses"]:
                        arch["gacha_bonuses"]["unlocked_literature"] = []
                    arch["gacha_bonuses"]["unlocked_literature"].extend([
                        "Cosmic Secrets", "Star Charts of the Ancients", "Celestial Navigation"
                    ])

                elif collection == "Royal Collection":
                    arch["gacha_bonuses"]["character_exp_bonus"] += 10.0  # 10% increased character exp
                    arch["gacha_bonuses"]["special_wish_artifacts"].append("Royal Scepter")
                    # Royal abilities and bonuses
                    arch["gacha_bonuses"]["combat_bonuses"]["health"] += 10.0
                    arch["gacha_bonuses"]["combat_bonuses"]["defense"] += 5.0
                    # Royal themed cosmetics
                    if "collection_cosmetics" not in arch["gacha_bonuses"]:
                        arch["gacha_bonuses"]["collection_cosmetics"] = {}
                    arch["gacha_bonuses"]["collection_cosmetics"]["Royal"] = [
                        "Royal Crown", "Royal Robes", "Royal Guard Armor"
                    ]
                    # Enhanced diplomacy with NPCs
                    arch["gacha_bonuses"]["special_abilities"].append({
                        "name": "Royal Authority",
                        "description": "Characters have enhanced dialogue options with NPCs and better prices with merchants",
                        "effect": {"merchant_discount": 0.10, "npc_relationship_bonus": 15}
                    })

                elif collection == "War Collection":
                    arch["gacha_bonuses"]["material_drop_bonus"] += 5.0  # 5% increased material drops
                    arch["gacha_bonuses"]["character_exp_bonus"] += 5.0  # 5% increased character exp
                    arch["gacha_bonuses"]["special_wish_artifacts"].append("Commander's Insignia")
                    # Combat bonuses
                    arch["gacha_bonuses"]["combat_bonuses"]["attack"] += 10.0
                    arch["gacha_bonuses"]["combat_bonuses"]["speed"] += 5.0
                    # War-themed cosmetics
                    if "collection_cosmetics" not in arch["gacha_bonuses"]:
                        arch["gacha_bonuses"]["collection_cosmetics"] = {}
                    arch["gacha_bonuses"]["collection_cosmetics"]["War"] = [
                        "Commander's Armor", "Battle Helm", "War Banner Cape"
                    ]
                    # Strategic battle abilities
                    arch["gacha_bonuses"]["special_abilities"].append({
                        "name": "Battle Tactics",
                        "description": "Characters gain enhanced positioning in battle and can use special formation abilities",
                        "effect": {"formation_bonus": 0.15, "strategic_retreat_chance": 0.20}
                    })


def ensure_gacha_system_initialized(data: Dict[str, Any]) -> None:
    """
    Ensures all gacha system components are properly initialized.
    This is more comprehensive than ensure_user_data_keys and focuses specifically on the gacha system.
    """
    if "gacha" not in data:
        data["gacha"] = {}

    gacha = data["gacha"]

    # Character system
    if "characters" not in gacha:
        gacha["characters"] = []

    if "memory_shards" not in gacha:
        gacha["memory_shards"] = {}

    if "character_pity_5star" not in gacha:
        gacha["character_pity_5star"] = 0

    if "character_pity_4star" not in gacha:
        gacha["character_pity_4star"] = 0

    if "last_5star_was_featured" not in gacha:
        gacha["last_5star_was_featured"] = False

    # Weapon system
    if "weapons" not in gacha:
        gacha["weapons"] = []

    if "weapon_pity_5star" not in gacha:
        gacha["weapon_pity_5star"] = 0

    if "weapon_pity_4star" not in gacha:
        gacha["weapon_pity_4star"] = 0

    # Party system
    if "active_party" not in gacha:
        gacha["active_party"] = []

    if "equipped_weapons" not in gacha:
        gacha["equipped_weapons"] = {}

    # Currencies
    if "primogems" not in gacha:
        gacha["primogems"] = 1600

    if "fates" not in gacha:
        gacha["fates"] = 0

    if "memory_dust" not in gacha:
        gacha["memory_dust"] = 0

    # Daily login system
    if "daily_login" not in gacha:
        gacha["daily_login"] = {
            "last_login": None,
            "login_streak": 0,
            "claimed_milestones": []
        }

    # Character and weapon progression
    if "character_levels" not in gacha:
        gacha["character_levels"] = {}

    if "weapon_levels" not in gacha:
        gacha["weapon_levels"] = {}

    if "weapon_refinements" not in gacha:
        gacha["weapon_refinements"] = {}

    if "farmed_materials" not in gacha:
        gacha["farmed_materials"] = {}

    # Banner rotation
    if "banner_rotation" not in data:
        current_featured_character = next(iter(GACHA_CHARACTERS.keys())) if GACHA_CHARACTERS else "Unknown Character"
        data["banner_rotation"] = {
            "current_featured_character": current_featured_character,
            "featured_weapons": [],
            "last_rotation": datetime.now().strftime("%Y-%m-%d")
        }

    # Achievement stats related to gacha
    if "achievements" in data and "stats" in data["achievements"]:
        stats = data["achievements"]["stats"]
        if "characters_collected" not in stats:
            stats["characters_collected"] = len(gacha.get("characters", []))
        if "weapons_collected" not in stats:
            stats["weapons_collected"] = len(gacha.get("weapons", []))
        if "gacha_pulls" not in stats:
            stats["gacha_pulls"] = 0


def migrate_gacha_data(data: Dict[str, Any]) -> None:
    """
    Apply migrations for gacha system data.
    This handles specific conversions needed when loading older save files.
    """
    if "gacha" not in data:
        return

    gacha = data["gacha"]

    # Migration for constellation_levels to memory_shards
    if "constellation_levels" in gacha and "memory_shards" not in gacha:
        gacha["memory_shards"] = gacha["constellation_levels"]

    # Initialize character levels for existing characters
    if "characters" in gacha and "character_levels" not in gacha:
        gacha["character_levels"] = {}
        for char_name in gacha["characters"]:
            if char_name in GACHA_CHARACTERS:
                char_data = GACHA_CHARACTERS[char_name]
                rarity = char_data.get("rarity", "Common")
                # Default level based on rarity
                max_level = {
                    "Common": 40,
                    "Uncommon": 50,
                    "Rare": 60,
                    "Epic": 80,
                    "Legendary": 90
                }.get(rarity, 40)
                gacha["character_levels"][char_name] = max_level


def check_daily_login_reward() -> None:
    """
    Check and update daily login rewards when loading a save file.
    Gives rewards if the player logs in on a new day.
    """
    if "gacha" not in user_data or "daily_login" not in user_data["gacha"]:
        return

    daily_login = user_data["gacha"]["daily_login"]

    # Get the current date
    today = datetime.now().strftime("%Y-%m-%d")

    # If this is the first login, set initial values
    if daily_login["last_login"] is None:
        daily_login["last_login"] = today
        daily_login["login_streak"] = 1
        give_daily_login_reward(1, True)
        return

    # Check if this is a new day compared to the last login
    if today != daily_login["last_login"]:
        # Check if the login streak should continue or reset
        last_login_date = datetime.strptime(daily_login["last_login"], "%Y-%m-%d")
        today_date = datetime.strptime(today, "%Y-%m-%d")
        days_difference = (today_date - last_login_date).days

        if days_difference == 1:
            # Consecutive login
            daily_login["login_streak"] += 1
        elif days_difference > 1:
            # Login streak broken, reset to 1
            daily_login["login_streak"] = 1

        # Update the last login date
        daily_login["last_login"] = today

        # Give rewards based on the streak
        give_daily_login_reward(daily_login["login_streak"])


def give_daily_login_reward(streak: int, silent: bool = False) -> None:
    """
    Give daily login rewards based on the login streak.

    Args:
        streak: The current login streak
        silent: If True, don't print messages (for first-time initialization)
    """
    # Base rewards
    primogems = 20 + (streak * 5)  # Increases with streak
    gold = 100 + (streak * 20)     # Increases with streak

    # Give rewards
    user_data["gacha"]["primogems"] += primogems
    user_data["gold"] += gold

    if not silent:
        print_colored(f"Daily Login Reward (Day {streak}):", MAGENTA)
        print_colored(f"• {primogems} Primogems", CYAN)
        print_colored(f"• {gold} Gold", YELLOW)

    # Special milestone rewards
    milestones = {
        7: {"reward": "fate", "amount": 1, "description": "Intertwined Fate"},
        14: {"reward": "materials", "amount": 5, "description": "Rare Materials"},
        30: {"reward": "fate", "amount": 5, "description": "Intertwined Fates"},
        60: {"reward": "character", "description": "Random Epic Character"},
        90: {"reward": "weapon", "description": "Random Legendary Weapon"},
        180: {"reward": "select_character", "description": "Character Selection"}
    }

    # Check if milestone reached and not already claimed
    if streak in milestones and streak not in user_data["gacha"]["daily_login"].get("claimed_milestones", []):
        milestone = milestones[streak]

        if not silent:
            print_colored(f"\nMilestone Reward (Day {streak}):", MAGENTA + BOLD)
            print_colored(f"• {milestone['description']}", CYAN)

        # Give milestone reward
        if milestone["reward"] == "fate":
            user_data["gacha"]["fates"] += milestone["amount"]

        elif milestone["reward"] == "materials":
            # Add random rare materials
            material_types = ["Character Ascension", "Weapon Refinement", "Talent Enhancement"]
            for _ in range(milestone["amount"]):
                material_type = random.choice(material_types)
                if material_type not in user_data["gacha"]["farmed_materials"]:
                    user_data["gacha"]["farmed_materials"][material_type] = 0
                user_data["gacha"]["farmed_materials"][material_type] += 1

        elif milestone["reward"] == "character":
            # Give random Epic character
            epic_chars = [c for c, data in GACHA_CHARACTERS.items() 
                          if data.get("rarity") == "Epic" and c not in user_data["gacha"]["characters"]]

            if epic_chars:
                random_char = random.choice(epic_chars)
                if random_char not in user_data["gacha"]["characters"]:
                    user_data["gacha"]["characters"].append(random_char)
                    user_data["gacha"]["memory_shards"][random_char] = 0
                    user_data["gacha"]["character_levels"][random_char] = 1

        elif milestone["reward"] == "weapon":
            # Give random Legendary weapon
            legendary_weapons = [w for w, data in CHARACTER_WEAPONS.items() 
                               if data.get("rarity") == "Legendary" and w not in user_data["gacha"]["weapons"]]

            if legendary_weapons:
                random_weapon = random.choice(legendary_weapons)
                if random_weapon not in user_data["gacha"]["weapons"]:
                    user_data["gacha"]["weapons"].append(random_weapon)
                    user_data["gacha"]["weapon_levels"][random_weapon] = 1
                    user_data["gacha"]["weapon_refinements"][random_weapon] = 1

        # Mark milestone as claimed
        user_data["gacha"]["daily_login"].setdefault("claimed_milestones", []).append(streak)

def auto_save() -> None:
    save_game(slot=0, auto=True)

def show_save_slots() -> None:
    print_header("Save Slots")
    save_dir = get_save_directory()
    saves = [f for f in os.listdir(save_dir) if f.startswith("save_") and f.endswith(".json")]
    saves = sorted(saves)
    if not saves:
        print("No saved games found.")
        return

    for save in saves:
        try:
            save_path = os.path.join(save_dir, save)
            with open(save_path, "r") as f:
                data = json.load(f)
                slot = save.split("_")[1].split(".")[0]
                name = data['user_data'].get('name', 'Unknown')
                print(f"\nSlot {slot}:")
                print(f"Character: {name}, Level {data['user_data']['level']} {data['user_data']['class']}")
                print(f"Location: {data['user_data']['current_area']}")
                print(f"Saved: {data['timestamp']}")
        except Exception:
            continue

def delete_save(slot: int) -> None:
    filename = f"save_{slot}.json"
    try:
        os.remove(filename)
        print(f"Save in slot {slot} deleted.")
    except FileNotFoundError:
        print(f"No save found in slot {slot}.")

def _display_and_select_quests(quest_entries: List[Dict[str, Any]], has_hylit: bool) -> Optional[str]:
    """Helper function to display and select from a list of quest entries.

    Args:
        quest_entries: List of quest entries with availability info
        has_hylit: Boolean indicating if player has Hylit companion

    Returns:
        Selected quest entry or None if no selection made
    """
    if not quest_entries:
        print("No quests available.")
        return None

    available_quests = []
    unavailable_quests = []

    # Separate available and unavailable quests
    for entry in quest_entries:
        if entry["prerequisite_met"] and entry["level_met"] and entry["location_available"]:
            available_quests.append(entry)
        else:
            unavailable_quests.append(entry)

    # Display available quests first
    if available_quests:
        print(f"\n{GREEN}Available Quests:{ENDC}")
        for i, entry in enumerate(available_quests, 1):
            quest = entry["quest"]

            # Enhanced display based on quest type
            if quest.get("story", False):
                if "story_arc" in quest:
                    print(f"\n{i}. {CYAN}{quest['name']}{ENDC} [{quest['story_arc']}]")
                else:
                    print(f"\n{i}. {YELLOW}{quest['name']}{ENDC} [Chapter {quest.get('chapter', '?')}]")
            else:
                print(f"\n{i}. {quest['name']}")

            # Hylit narration for immersion
            if has_hylit:
                print_animated(f"Hylit whispers: '{quest['description']}'", CYAN)
            else:
                print(f"   {quest['description']}")

            # Quest objective
            target_type, target_count = next(iter(quest["target"].items()))
            print(f"   Objective: {target_type.capitalize()} x {target_count}")

            # Rewards with color coding
            print(f"   Rewards: {YELLOW}{quest['reward']['gold']}{ENDC} gold, {GREEN}{quest['reward']['exp']}{ENDC} exp")
            if "item" in quest["reward"]:
                print(f"           + {MAGENTA}{quest['reward']['item']}{ENDC}")

            # Special requirements
            if "requirements" in quest:
                req = quest["requirements"]
                if "season" in req:
                    season_match = req["season"] == user_data.get("current_season", "")
                    status = f"{GREEN}✓{ENDC}" if season_match else f"{RED}✗{ENDC}"
                    print(f"   Required Season: {req['season']} {status}")
                if "weather" in req:
                    weather_match = req["weather"] == user_data.get("current_weather", "")
                    status = f"{GREEN}✓{ENDC}" if weather_match else f"{RED}✗{ENDC}"
                    print(f"   Required Weather: {req['weather']} {status}")
                if "profession" in req:
                    prof_match = req["profession"] == user_data.get("profession", "")
                    status = f"{GREEN}✓{ENDC}" if prof_match else f"{RED}✗{ENDC}"
                    print(f"   Required Profession: {req['profession']} {status}")

    # Display unavailable quests with reason
    if unavailable_quests:
        print(f"\n{YELLOW}Unavailable Quests:{ENDC}")
        for i, entry in enumerate(unavailable_quests, len(available_quests) + 1):
            quest = entry["quest"]
            reasons = []

            if not entry["prerequisite_met"]:
                reasons.append(f"{RED}Prerequisite not met{ENDC}")
            if not entry["level_met"]:
                reasons.append(f"{RED}Requires level {quest.get('level_required', '?')}{ENDC}")
            if not entry["location_available"]:
                reasons.append(f"{YELLOW}Must travel to: {', '.join(quest.get('travel_locations', []))}{ENDC}")

            print(f"\n{i}. {LIGHTGRAY}{quest['name']}{ENDC} ({', '.join(reasons)})")
            print(f"   {LIGHTGRAY}{quest['description']}{ENDC}")

    # Prompt for quest selection if any available
    if available_quests:
        choice = input("\nSelect a quest to accept (or 0 to go back): ").strip()
        try:
            choice_index = int(choice)
            if choice_index == 0:
                return None

            if 1 <= choice_index <= len(available_quests):
                return available_quests[choice_index - 1]
            else:
                print("Invalid choice.")
                return None
        except ValueError:
            print("Invalid input. Please enter a number.")
            return None
    else:
        input("\nPress Enter to continue...")
        return None

def show_quests() -> None:
    print_header("Quest Journal")

    # Check if player has Hylit companion for narration
    has_hylit = "Hylit" in user_data["pets"]

    # Initialize quest categories
    quest_categories = {
        "main_story": [],      # Main storyline quests
        "story_arcs": {},      # Secondary story arcs (Weather Mysteries, Void Walker, etc.)
        "location": [],        # Location-specific quests
        "profession": [],      # Profession-specific quests
        "seasonal": [],        # Season-specific quests
        "weather": [],         # Weather-specific quests
        "daily": [],           # Daily quests that reset
        "general": []          # General side quests
    }

    # Categorize available quests
    for quest in QUESTS:
        # Skip completed quests
        if quest["id"] in user_data["completed_quests"]:
            continue

        # Skip active quests for available quest display
        if quest in user_data["active_quests"]:
            continue

        # Check if quest is available based on prerequisites
        prerequisite_met = True
        if "prerequisite" in quest and quest["prerequisite"] not in user_data["completed_quests"]:
            prerequisite_met = False

        # Check level requirements
        level_met = True
        if "level_required" in quest and user_data["level"] < quest["level_required"]:
            level_met = False

        # Create a quest entry with availability info
        quest_entry = {
            "quest": quest,
            "prerequisite_met": prerequisite_met,
            "level_met": level_met,
            "location_available": "travel_locations" not in quest or user_data["location"] in quest["travel_locations"]
        }

        # Categorize based on quest attributes
        if quest.get("story", False) and not quest.get("story_arc", None):
            quest_categories["main_story"].append(quest_entry)
        elif "story_arc" in quest:
            arc_name = quest["story_arc"]
            if arc_name not in quest_categories["story_arcs"]:
                quest_categories["story_arcs"][arc_name] = []
            quest_categories["story_arcs"][arc_name].append(quest_entry)
        elif "requirements" in quest:
            if "profession" in quest["requirements"]:
                quest_categories["profession"].append(quest_entry)
            elif "season" in quest["requirements"]:
                quest_categories["seasonal"].append(quest_entry)
            elif "weather" in quest["requirements"]:
                quest_categories["weather"].append(quest_entry)
            elif "daily" in quest["requirements"] and quest["requirements"]["daily"]:
                quest_categories["daily"].append(quest_entry)
            else:
                quest_categories["general"].append(quest_entry)
        elif "travel_locations" in quest:
            quest_categories["location"].append(quest_entry)
        else:
            quest_categories["general"].append(quest_entry)

    # Define quest menu options
    quest_menu_options = {
        "1": "View Main Story Quests",
        "2": "View Story Arc Quests",
        "3": "View Available Side Quests",
        "4": "View Active Quests",
        "5": "View Completed Quests",
        "0": "Back"
    }

    while True:
        print("\nQuest Menu:")
        for key, option in quest_menu_options.items():
            print(f"{key}. {option}")

        choice = input("\nSelect an option: ").strip()

        if choice == "0":
            return

        elif choice == "1":  # Main story quests
            print_header("Main Story Quests")

            if not quest_categories["main_story"]:
                print("No main story quests available at this time.")
                input("\nPress Enter to continue...")
                continue

            # Sort main story quests by chapter
            quest_categories["main_story"].sort(key=lambda x: x["quest"].get("chapter", 0))

            # Display main story quests
            quest_selected = _display_and_select_quests(quest_categories["main_story"], has_hylit)
            if quest_selected:
                # Accept the quest
                user_data["active_quests"].append(quest_selected["quest"])
                print(f"\n{GREEN}Quest '{quest_selected['quest']['name']}' added to your journal!{ENDC}")

                # Special handling for storyline quests - show immersive message
                chapter = quest_selected["quest"].get("chapter", 0)
                print_animated(f"\nChapter {chapter} begins...", CYAN)
                if has_hylit:
                    print_animated("Hylit: 'This is a pivotal moment in your journey. The path ahead may be challenging, but I believe in you!'", CYAN)

                input("\nPress Enter to continue...")

        elif choice == "2":  # Story arc quests
            if not quest_categories["story_arcs"]:
                print("No story arc quests available at this time.")
                input("\nPress Enter to continue...")
                continue

            # Create story arc menu
            print_header("Story Arcs")
            story_arcs = list(quest_categories["story_arcs"].keys())

            for i, arc in enumerate(story_arcs, 1):
                available_quests = sum(1 for q in quest_categories["story_arcs"][arc] 
                                     if q["prerequisite_met"] and q["level_met"] and q["location_available"])
                total_quests = len(quest_categories["story_arcs"][arc])
                print(f"{i}. {arc} ({available_quests}/{total_quests} available)")

            arc_choice = input("\nSelect a story arc (or 0 to go back): ").strip()

            try:
                arc_index = int(arc_choice)
                if arc_index == 0:
                    continue

                if 1 <= arc_index <= len(story_arcs):
                    selected_arc = story_arcs[arc_index-1]
                    print_header(f"{selected_arc} Quests")

                    # Sort by quest sequence (prerequisite chain)
                    arc_quests = quest_categories["story_arcs"][selected_arc]
                    quest_selected = _display_and_select_quests(arc_quests, has_hylit)

                    if quest_selected:
                        # Accept the quest
                        user_data["active_quests"].append(quest_selected["quest"])
                        print(f"\n{GREEN}Quest '{quest_selected['quest']['name']}' added to your journal!{ENDC}")

                        # Special immersive message for story arcs
                        if has_hylit:
                            if selected_arc == "Weather Mysteries":
                                print_animated("Hylit: 'The weather holds many secrets. This quest may reveal forgotten knowledge about the elements themselves.'", CYAN)
                            elif selected_arc == "Void Walker":
                                print_animated("Hylit: 'These dimensional disturbances are concerning. Be cautious as you investigate further.'", CYAN)

                        input("\nPress Enter to continue...")
            except ValueError:
                print("Invalid choice. Please enter a number.")

        elif choice == "3":  # Side quests
            print_header("Available Side Quests")

            # Combine all side quest categories
            all_side_quests = (
                quest_categories["location"] + 
                quest_categories["profession"] + 
                quest_categories["seasonal"] + 
                quest_categories["weather"] + 
                quest_categories["daily"] + 
                quest_categories["general"]
            )

            if not all_side_quests:
                print("No side quests available at this time.")
                input("\nPress Enter to continue...")
                continue

            # Filter options for side quests
            filter_options = {
                "1": "All Side Quests",
                "2": "Location Quests",
                "3": "Profession Quests",
                "4": "Seasonal Quests",
                "5": "Weather Quests",
                "6": "Daily Quests",
                "0": "Back"
            }

            print("\nFilter Options:")
            for key, option in filter_options.items():
                print(f"{key}. {option}")

            filter_choice = input("\nSelect a filter: ").strip()

            if filter_choice == "0":
                continue

            filtered_quests = []
            if filter_choice == "1":
                filtered_quests = all_side_quests
            elif filter_choice == "2":
                filtered_quests = quest_categories["location"]
            elif filter_choice == "3":
                filtered_quests = quest_categories["profession"]
            elif filter_choice == "4":
                filtered_quests = quest_categories["seasonal"]
            elif filter_choice == "5":
                filtered_quests = quest_categories["weather"]
            elif filter_choice == "6":
                filtered_quests = quest_categories["daily"]
            else:
                print("Invalid choice.")
                continue

            if not filtered_quests:
                print("No quests found with this filter.")
                input("\nPress Enter to continue...")
                continue

            # Sort side quests by level required
            filtered_quests.sort(key=lambda x: x["quest"].get("level_required", 0))

            quest_selected = _display_and_select_quests(filtered_quests, has_hylit)
            if quest_selected:
                # Accept the quest
                user_data["active_quests"].append(quest_selected["quest"])
                print(f"\n{GREEN}Quest '{quest_selected['quest']['name']}' added to your journal!{ENDC}")
                input("\nPress Enter to continue...")

        elif choice == "4":  # Active quests
            print_header("Active Quests")

            if not user_data["active_quests"]:
                print("You have no active quests.")
                input("\nPress Enter to continue...")
                continue

            # Display active quests with detailed progress
            active_quests = user_data["active_quests"]
            for i, quest in enumerate(active_quests, 1):
                # Determine quest type/category for display
                quest_type = "Side Quest"
                if quest.get("story", False):
                    if "story_arc" in quest:
                        quest_type = f"{quest['story_arc']} Quest"
                    else:
                        quest_type = f"Chapter {quest.get('chapter', '?')} Main Quest"

                # Format quest header with color based on type
                if "Chapter" in quest_type:
                    print(f"\n{i}. {YELLOW}{quest['name']}{ENDC} ({quest_type})")
                elif "Arc" in quest_type:
                    print(f"\n{i}. {CYAN}{quest['name']}{ENDC} ({quest_type})")
                else:
                    print(f"\n{i}. {GREEN}{quest['name']}{ENDC} ({quest_type})")

                print(f"   Description: {quest['description']}")

                # Show quest objective with progress bar
                target = next(iter(quest["target"].items()))
                target_type, target_count = target
                target_progress = user_data.get("quest_progress", {}).get(quest["name"], {}).get(target_type, 0)

                # Calculate progress percentage and create visual progress bar
                progress_percent = min(100, int((target_progress / target_count) * 100))
                progress_bar = create_progress_bar(progress_percent/100)

                print(f"   Objective: {target_type.capitalize()} x {target_count}")
                print(f"   Progress: {progress_bar} {target_progress}/{target_count} ({progress_percent}%)")

                # Show rewards
                print("   Rewards:")
                print(f"     - {quest['reward']['gold']} gold")
                print(f"     - {quest['reward']['exp']} experience")
                if "item" in quest["reward"]:
                    print(f"     - Item: {quest['reward']['item']}")

                # Location requirement, if any
                if "travel_locations" in quest:
                    if user_data["location"] in quest["travel_locations"]:
                        print(f"   {GREEN}You are in the right location to progress this quest.{ENDC}")
                    else:
                        print(f"   {YELLOW}Travel to: {', '.join(quest['travel_locations'])}{ENDC}")

            # Option to abandon a quest
            print("\nOptions:")
            print("1. Return to quest menu")
            print("2. Abandon a quest")

            active_choice = input("\nSelect an option: ").strip()

            if active_choice == "2":
                abandon_index = input("Enter the number of the quest to abandon (or 0 to cancel): ").strip()
                try:
                    abandon_index = int(abandon_index)
                    if abandon_index == 0:
                        continue

                    if 1 <= abandon_index <= len(active_quests):
                        quest_to_abandon = active_quests[abandon_index-1]

                        # Check if it's a main story quest
                        if quest_to_abandon.get("story", False) and not quest_to_abandon.get("story_arc", None):
                            confirm = input(f"{RED}Warning: This is a main story quest. Are you sure you want to abandon it? (y/n): {ENDC}").strip().lower()
                            if confirm != 'y':
                                continue

                        # Abandon the quest
                        user_data["active_quests"].remove(quest_to_abandon)
                        print(f"{YELLOW}Quest '{quest_to_abandon['name']}' abandoned.{ENDC}")
                except ValueError:
                    print("Invalid choice. Please enter a number.")

        elif choice == "5":  # Completed quests
            print_header("Completed Quests")

            # Get all completed quests
            completed_quest_ids = user_data["completed_quests"]
            if not completed_quest_ids:
                print("You haven't completed any quests yet.")
                input("\nPress Enter to continue...")
                continue

            # Find quest details for each completed ID
            completed_quests = []
            for quest in QUESTS:
                if quest["id"] in completed_quest_ids:
                    completed_quests.append(quest)

            # Group by chapter and story arc
            completed_by_chapter = {}
            completed_by_arc = {}
            completed_side = []

            for quest in completed_quests:
                if quest.get("story", False):
                    if "story_arc" in quest:
                        arc = quest["story_arc"]
                        if arc not in completed_by_arc:
                            completed_by_arc[arc] = []
                        completed_by_arc[arc].append(quest)
                    else:
                        chapter = quest.get("chapter", 0)
                        if chapter not in completed_by_chapter:
                            completed_by_chapter[chapter] = []
                        completed_by_chapter[chapter].append(quest)
                else:
                    completed_side.append(quest)

            # Display completed main story quests by chapter
            if completed_by_chapter:
                print("\nCompleted Main Story Quests:")
                for chapter in sorted(completed_by_chapter.keys()):
                    print(f"\nChapter {chapter}:")
                    for quest in completed_by_chapter[chapter]:
                        print(f"  - {YELLOW}{quest['name']}{ENDC}")

            # Display completed story arc quests
            if completed_by_arc:
                print("\nCompleted Story Arc Quests:")
                for arc in sorted(completed_by_arc.keys()):
                    print(f"\n{arc}:")
                    for quest in completed_by_arc[arc]:
                        print(f"  - {CYAN}{quest['name']}{ENDC}")

            # Display completed side quests
            if completed_side:
                print("\nCompleted Side Quests:")
                for quest in completed_side:
                    print(f"  - {GREEN}{quest['name']}{ENDC}")

            # Show completion statistics
            total_completed = len(completed_quest_ids)
            total_available = len(QUESTS)
            completion_percent = int((total_completed / total_available) * 100)

            print("\nQuest Completion Stats:")
            print(f"Total Quests Completed: {total_completed}/{total_available} ({completion_percent}%)")

            # Show milestones and achievements based on completion
            if completion_percent >= 10:
                print(f"{GREEN}Achievement: Quest Beginner{ENDC}")
            if completion_percent >= 25:
                print(f"{GREEN}Achievement: Quest Enthusiast{ENDC}")
            if completion_percent >= 50:
                print(f"{GREEN}Achievement: Quest Master{ENDC}")
            if completion_percent >= 75:
                print(f"{GREEN}Achievement: Quest Legend{ENDC}")
            if completion_percent == 100:
                print(f"{CYAN}Achievement: Completionist{ENDC}")

            input("\nPress Enter to continue...")

        else:
            print("Invalid choice. Please try again.")


# Ability descriptions for pets
ABILITY_DESCRIPTIONS = {
    # General abilities
    "Quick Attack": "Pet attacks first in combat, dealing small damage (10% of your attack)",
    "Protective Stance": "Pet has a 20% chance to block incoming attacks, reducing damage by 30%",
    "Find Treasure": "Pet has a 15% chance to find extra loot after battles",
    "Scouting": "Pet helps you find materials more efficiently (+10% gathering yield)",

    # Elemental abilities
    "Flame Burst": "Pet deals Fire elemental damage to enemies (15% of your attack)",
    "Healing Mist": "Pet has a 20% chance to heal you for 10% of your max health each turn",
    "Stone Shield": "Pet creates a shield that reduces damage by 15% for 3 turns",
    "Swift Movement": "Pet increases your dodge chance by 10% during combat",
    "Shock Strike": "Pet deals Lightning damage with a 15% chance to stun the enemy for 1 turn",
    "Energy Pulse": "Pet releases a burst of energy dealing 12% of your attack as neutral damage",

    # Special abilities
    "Scavenge": "Pet may find bonus materials when exploring",
    "Weather Sense": "Pet predicts weather changes, giving warning before severe weather",
    "Fierce Loyalty": "When your health drops below 20%, pet deals 50% more damage",
    "Intimidate": "Pet has a 10% chance to frighten weaker enemies, making them flee"
}

# Function to handle loot drops
def loot(monster: Dict) -> None:
    """
    Enhanced loot system with rarity levels, random drops, and treasure chests
    Includes pet integration for bonus loot
    """
    global user_data

    print_animated(f"\n{BG_YELLOW}{BLACK} LOOT DISCOVERED! {ENDC}", delay=0.05)

    # Award Stellarstones for defeating the monster if gacha system is active
    if "gacha" in user_data:
        monster_level = monster.get("level", 1)
        hook_battle_reward(monster_level)

    # Basic monster drops
    base_drops = monster.get("drops", [])

    # Calculate additional random drops based on monster level
    monster_level = monster.get("level", 1)
    is_boss = monster.get("boss", False)

    # Check for active pet with Find Treasure ability
    active_pet = get_active_pet()
    has_treasure_finder = False
    pet_treasure_bonus = 0

    if active_pet:
        pet_name = active_pet["name"]
        pet_abilities = []

        # Get the pet's abilities
        if "pet_stats" in user_data and pet_name in user_data["pet_stats"]:
            pet_abilities = user_data["pet_stats"][pet_name].get("abilities", [])

            # Check if pet has Find Treasure ability
            if "Find Treasure" in pet_abilities:
                has_treasure_finder = True
                pet_level = user_data["pet_stats"][pet_name].get("level", 1)
                pet_loyalty = user_data["pet_stats"][pet_name].get("loyalty", 50)

                # Higher level and loyalty increase bonus chance
                pet_treasure_bonus = 0.15  # Base 15% chance
                pet_treasure_bonus += min(0.05, pet_level * 0.01)  # +1% per level up to 5%

                if pet_loyalty >= 70:
                    pet_treasure_bonus += 0.05  # +5% for high loyalty

    # Determine drop quantities and chances
    drop_count = random.randint(1, 3)  # Base drop count

    # Bosses give more loot
    if is_boss:
        drop_count += random.randint(2, 4)

    # Chance to find a chest
    chest_chance = 0.1 + (monster_level * 0.01)  # 10% base + 1% per monster level
    if is_boss:
        chest_chance += 0.3  # Bosses have higher chest chance

    # Apply pet bonuses if available
    if has_treasure_finder and active_pet and "name" in active_pet:
        extra_items = 1  # Always get at least one extra item
        drop_count += extra_items
        chest_chance += pet_treasure_bonus  # Increased chest chance

        # Pet found extra treasure notification
        pet_name = active_pet.get("name", "Your pet")
        print_animated(f"{CYAN}{pet_name} found {extra_items} extra treasure(s)!{ENDC}", delay=0.02)
        print_animated(f"{YELLOW}Chest discovery chance increased by {int(pet_treasure_bonus*100)}%{ENDC}", delay=0.02)

    # Prepare loot table
    all_drops = []

    # Add base drops from monster definition
    for item in base_drops:
        all_drops.append({
            "name": item,
            "type": "base",
            "rarity": "Common" if item != "Gold Coin" else "Currency"
        })

    # Check for chest
    found_chest = random.random() < chest_chance
    if found_chest:
        chest_tier = "Common"
        if is_boss:
            # Boss chests are better
            if monster_level > 20:
                chest_tier = random.choice(["Epic", "Legendary"])
            elif monster_level > 10:
                chest_tier = random.choice(["Rare", "Epic"])
            else:
                chest_tier = random.choice(["Common", "Uncommon", "Rare"])
        else:
            # Regular monster chests
            rarity_roll = random.random()
            if rarity_roll < 0.1 * (monster_level / 20):  # Higher level monsters have better chest chance
                chest_tier = "Legendary"
            elif rarity_roll < 0.2 * (monster_level / 15):
                chest_tier = "Epic"
            elif rarity_roll < 0.4 * (monster_level / 10):
                chest_tier = "Rare"
            elif rarity_roll < 0.6:
                chest_tier = "Uncommon"

        all_drops.append({
            "name": f"{chest_tier} Chest",
            "type": "chest",
            "rarity": chest_tier
        })

    # Add random gold based on monster level
    gold_amount = random.randint(5, 15) * max(1, monster_level // 2)
    if is_boss:
        gold_amount *= 3  # Triple gold for bosses

    all_drops.append({
        "name": f"{gold_amount} Gold",
        "type": "gold",
        "rarity": "Currency",
        "amount": gold_amount
    })

    # Add random material drops based on area and monster type
    if "type" in monster:
        monster_type = monster["type"]
        material_chance = 0.3 + (monster_level * 0.02)  # 30% base + 2% per level

        if random.random() < material_chance:
            if monster_type == "undead":
                material = random.choice(["Bone Dust", "Spectral Essence", "Grave Soil"])
            elif monster_type == "beast":
                material = random.choice(["Beast Hide", "Sharp Claw", "Monster Tooth"])
            elif monster_type == "elemental":
                material = random.choice(["Elemental Core", "Pure Essence", "Crystallized Magic"])
            elif monster_type == "dragon":
                material = random.choice(["Dragon Scale", "Dragon Tooth", "Dragon Blood"])
            elif monster_type == "demon":
                material = random.choice(["Demon Horn", "Infernal Ash", "Corrupted Essence"])
            else:
                material = random.choice(["Strange Dust", "Magical Residue", "Creature Part"])

            rarity = "Common"
            if random.random() < 0.2:
                rarity = "Uncommon"
            if random.random() < 0.1:
                rarity = "Rare"

            all_drops.append({
                "name": material,
                "type": "material",
                "rarity": rarity
            })

    # Add random equipment drop for higher level monsters or bosses
    equipment_chance = 0.05 + (monster_level * 0.01)  # 5% base + 1% per level
    if is_boss:
        equipment_chance = 0.5 + (monster_level * 0.02)  # 50% base + 2% per level for bosses

    if random.random() < equipment_chance:
        equip_type = random.choice(["weapon", "armor", "accessory"])

        if equip_type == "weapon":
            weapons = ["Sword", "Axe", "Dagger", "Staff", "Bow", "Wand", "Hammer", "Spear"]
            equip_name = random.choice(weapons)
        elif equip_type == "armor":
            armors = ["Helmet", "Chestplate", "Leggings", "Boots", "Gauntlets", "Shield"]
            equip_name = random.choice(armors)
        else:  # accessory
            accessories = ["Ring", "Amulet", "Charm", "Bracelet", "Belt", "Earring"]
            equip_name = random.choice(accessories)

        # Determine rarity
        rarity_roll = random.random()
        if rarity_roll < 0.05 * (monster_level / 20):  # Higher level = better chance
            rarity = "Legendary"
            prefix = random.choice(["Ancient", "Mythical", "Godly", "Supreme", "Ultimate"])
        elif rarity_roll < 0.15 * (monster_level / 15):
            rarity = "Epic"
            prefix = random.choice(["Magnificent", "Heroic", "Superior", "Masterful", "Elite"])
        elif rarity_roll < 0.3 * (monster_level / 10):
            rarity = "Rare"
            prefix = random.choice(["Exceptional", "Valuable", "Quality", "Refined", "Pristine"])
        elif rarity_roll < 0.5:
            rarity = "Uncommon"
            prefix = random.choice(["Fine", "Strong", "Sturdy", "Keen", "Reinforced"])
        else:
            rarity = "Common"
            prefix = random.choice(["Basic", "Simple", "Standard", "Plain", "Ordinary"])

        # Add effects based on rarity
        effect_value = 0
        if rarity == "Legendary":
            effect_value = 15 + monster_level // 2
        elif rarity == "Epic":
            effect_value = 10 + monster_level // 3
        elif rarity == "Rare":
            effect_value = 7 + monster_level // 4
        elif rarity == "Uncommon":
            effect_value = 5 + monster_level // 5
        else:
            effect_value = 3 + monster_level // 7

        # Sometimes add a random element
        has_element = random.random() < 0.3
        element = None
        if has_element:
            element = random.choice(["Fire", "Water", "Earth", "Air", "Lightning", "Ice", "Light", "Dark"])

        # Build the full item name
        if element:
            full_name = f"{prefix} {element} {equip_name}"
        else:
            full_name = f"{prefix} {equip_name}"

        all_drops.append({
            "name": full_name,
            "type": "equipment",
            "rarity": rarity,
            "equip_type": equip_type,
            "effect": effect_value,
            "element": element
        })

    # Display all drops with colors based on rarity
    print_animated("\nLoot found:", delay=0.02)

    # Group items by type for better display
    grouped_drops = {}
    for i, drop in enumerate(all_drops):
        drop_type = drop["type"]
        if drop_type not in grouped_drops:
            grouped_drops[drop_type] = []
        # Add the index so we can refer back to the original list
        drop["index"] = i
        grouped_drops[drop_type].append(drop)

    # Display loot by category with colors
    current_idx = 1
    display_drops = []

    # 1. Equipment (most exciting)
    if "equipment" in grouped_drops:
        print_animated(f"\n{BOLD}Equipment:{ENDC}", delay=0.01)
        for item in grouped_drops["equipment"]:
            rarity_color = get_rarity_color(item["rarity"])
            print_animated(f"{current_idx}. {rarity_color}{item['name']}{ENDC} ({item['rarity']} {item['equip_type'].capitalize()})", delay=0.02)
            item["display_index"] = current_idx
            display_drops.append(item)
            current_idx += 1

    # 2. Chests
    if "chest" in grouped_drops:
        print_animated(f"\n{BOLD}Treasures:{ENDC}", delay=0.01)
        for item in grouped_drops["chest"]:
            rarity_color = get_rarity_color(item["rarity"])
            print_animated(f"{current_idx}. {rarity_color}{item['name']}{ENDC}", delay=0.02)
            item["display_index"] = current_idx
            display_drops.append(item)
            current_idx += 1

    # 3. Materials
    if "material" in grouped_drops:
        print_animated(f"\n{BOLD}Materials:{ENDC}", delay=0.01)
        for item in grouped_drops["material"]:
            rarity_color = get_rarity_color(item["rarity"])
            print_animated(f"{current_idx}. {rarity_color}{item['name']}{ENDC} ({item['rarity']})", delay=0.02)
            item["display_index"] = current_idx
            display_drops.append(item)
            current_idx += 1

    # 4. Basic drops
    if "base" in grouped_drops:
        print_animated(f"\n{BOLD}Other Items:{ENDC}", delay=0.01)
        for item in grouped_drops["base"]:
            rarity_color = get_rarity_color(item["rarity"])
            print_animated(f"{current_idx}. {rarity_color}{item['name']}{ENDC}", delay=0.02)
            item["display_index"] = current_idx
            display_drops.append(item)
            current_idx += 1

    # 5. Gold (always shown)
    if "gold" in grouped_drops:
        print_animated(f"\n{BOLD}Currency:{ENDC}", delay=0.01)
        for item in grouped_drops["gold"]:
            print_animated(f"{current_idx}. {LIGHTYELLOW}{item['name']}{ENDC}", delay=0.02)
            item["display_index"] = current_idx
            display_drops.append(item)
            current_idx += 1

    # 6. Special pet-found items if pet has Find Treasure ability
    if has_treasure_finder and active_pet and "name" in active_pet and "pet_stats" in user_data and active_pet["name"] in user_data["pet_stats"]:
        # Chance for bonus rare materials scales with pet level and loyalty
        pet_level = user_data["pet_stats"][active_pet["name"]].get("level", 1)
        pet_loyalty = user_data["pet_stats"][active_pet["name"]].get("loyalty", 50)
        rare_chance = 0.15 + (pet_level * 0.02) + (pet_loyalty * 0.001)  # 15% base + bonuses

        if random.random() < rare_chance:
            # Select a rare bonus material
            rare_bonus_materials = [
                "Fire Essence", "Water Essence", "Earth Essence", "Air Essence", 
                "Lightning Essence", "Arcane Dust", "Mythril", "Stardust",
                "Dragon Scale", "Phoenix Feather", "Enchanted Gem"
            ]
            bonus_material = random.choice(rare_bonus_materials)

            # Create the item
            pet_item = {
                "name": bonus_material,
                "type": "material",
                "quantity": 1,
                "rarity": "Rare",
                "pet_bonus": True  # Mark as pet-found
            }

            # Add to display drops
            print_animated(f"\n{BOLD}{MAGENTA}Pet Discovery:{ENDC}", delay=0.01)
            print_animated(f"{current_idx}. {CYAN}[Pet Find] {get_rarity_color('Rare')}{bonus_material}{ENDC} ✨", delay=0.03)
            pet_item["display_index"] = current_idx
            display_drops.append(pet_item)
            current_idx += 1

    # Handle loot selection with improved UI
    print_animated(f"\n{BOLD}You can select one item to loot.{ENDC}", delay=0.02)
    print_animated("Type 'all' to take everything or press Enter to skip.", delay=0.02)

    while True:
        try:
            choice = input(f"{CYAN}Choose loot (1-{len(display_drops)}, 'all', or press Enter): {ENDC}").strip().lower()

            # Take all loot
            if choice == "all":
                print_animated(f"{BG_GREEN}{BLACK} LOOTING ALL ITEMS {ENDC}", delay=0.02)
                # Process each item
                for item in display_drops:
                    process_loot_item(item)
                break

            # Skip looting
            elif choice == "":
                print_animated(f"{YELLOW}No loot taken.{ENDC}", delay=0.02)
                break

            # Take specific item
            else:
                choice_int = int(choice)
                if 1 <= choice_int <= len(display_drops):
                    selected_item = next((item for item in display_drops if item["display_index"] == choice_int), None)
                    if selected_item:
                        # Process the selected item
                        process_loot_item(selected_item)
                        break
                else:
                    print(f"{YELLOW}Invalid choice, please try again.{ENDC}")

        except ValueError:
            print(f"{YELLOW}Invalid input, please enter a number, 'all', or press Enter to skip.{ENDC}")

def process_loot_item(item: Dict[str, Any]) -> None:
    """Process a single loot item based on its type"""
    global user_data

    item_type = item["type"]
    item_name = item["name"]

    # Check if item was found by pet
    pet_bonus = item.get("pet_bonus", False)
    pet_prefix = f"{CYAN}[Pet Find] {ENDC}" if pet_bonus else ""

    if item_type == "gold":
        gold_amount = item["amount"]
        user_data["gold"] += gold_amount
        print_animated(f"{pet_prefix}Gained {LIGHTYELLOW}{gold_amount} gold{ENDC}!", delay=0.02)

    elif item_type == "chest":
        print_animated(f"{pet_prefix}{CYAN}You've found a {get_rarity_color(item['rarity'])}{item_name}{ENDC}!", delay=0.02)
        # Directly open the chest
        open_chest(item["rarity"])

    elif item_type == "equipment":
        # Add equipment to inventory with properties
        equip_item = {
            "name": item["name"],
            "type": item["equip_type"],
            "rarity": item["rarity"],
            "effect": item["effect"]
        }
        if "element" in item and item["element"]:
            equip_item["element"] = item["element"]

        # Check if inventory has equipment section
        if "equipment" not in user_data:
            user_data["equipment"] = []

        user_data["equipment"].append(equip_item)
        print_animated(f"{pet_prefix}Added {get_rarity_color(item['rarity'])}{item_name}{ENDC} to your equipment!", delay=0.02)

    else:  # base items, materials, etc.
        user_data["inventory"].append(item_name)
        print_animated(f"{pet_prefix}Added {get_rarity_color(item.get('rarity', 'Common'))}{item_name}{ENDC} to inventory!", delay=0.02)

def get_rarity_color(rarity: str) -> str:
    """Returns the appropriate color code for an item rarity"""
    rarity_colors = {
        "Common": WHITE,
        "Uncommon": LIGHTGREEN,
        "Rare": LIGHTBLUE,
        "Epic": LIGHTMAGENTA,
        "Legendary": LIGHTYELLOW,
        "Currency": LIGHTYELLOW
    }
    return rarity_colors.get(rarity, WHITE)

# Function to enter a dungeon
def enter_dungeon(dungeon_name: str) -> None:
    try:
        dungeon = next((d for d in dungeons if d["name"].lower() == dungeon_name.lower()), None)
        if not dungeon:
            print(f"{FAIL}Dungeon '{dungeon_name}' not found!{ENDC}")
            return

        print_header(f"Entering {dungeon['name']}...")
        print_colored("Prepare yourself for tough battles and great loot!", CYAN)

        # Check if dungeon has any boss monsters
        boss_monsters = []
        for monster_name in dungeon["monsters"]:
            monster = next((m for m in monsters if m["name"].lower() == monster_name.lower()), None)
            if monster and monster.get("boss", False):
                boss_monsters.append(monster)

        # If no boss monsters, limit number of monsters fought to random 10-15
        max_monsters = len(dungeon["monsters"])
        if not boss_monsters:
            max_monsters = random.randint(10, 15)
            max_monsters = min(max_monsters, len(dungeon["monsters"]))

        monsters_fought = 0
        all_monsters_defeated = True
        for monster_name in dungeon["monsters"]:
            if monsters_fought >= max_monsters:
                print_colored(f"Reached limit of {max_monsters} monsters for this dungeon (no boss present).", YELLOW)
                break
            try:
                monster = next(m for m in monsters if m["name"].lower() == monster_name.lower())
                if user_data["health"] <= 0:
                    print_colored("You were defeated! Dungeon run failed.", FAIL)
                    all_monsters_defeated = False
                    return
                # If monster is a boss, print special styled name
                if monster.get("boss", False):
                    boss_name = f"⋆༺ 𓆩{monster['name'].upper()}𓆪 ༻ ⋆"
                    print_colored(boss_name, FAIL)
                else:
                    print_colored(f"Encountered: {monster['name']}", CYAN)
                fight(monster)
                if user_data["health"] <= 0:
                    all_monsters_defeated = False
                    break
                monsters_fought += 1
            except StopIteration:
                print_colored(f"Warning: Monster '{monster_name}' not found in database", WARNING)
                continue

        if user_data["health"] > 0 and all_monsters_defeated:
            print_colored(f"You have completed the {dungeon['name']}!", OKGREEN)

            # Mark dungeon as completed
            if dungeon['name'] not in user_data.get("dungeons_completed", []):
                user_data.setdefault("dungeons_completed", []).append(dungeon['name'])
                print_colored(f"Dungeon {dungeon['name']} has been marked as completed!", OKGREEN)

                # Additional reward for first completion
                reward_gold = 500
                reward_exp = 1000
                user_data["gold"] += reward_gold
                user_data["exp"] += reward_exp
                print_colored(f"You received {reward_gold} gold and {reward_exp} experience as a completion reward!", MAGENTA)

            # Get loot regardless of completion status
            loot_item = random.choice(dungeon["loot"])
            print_colored(f"At the end of the dungeon, you found: {loot_item}", MAGENTA)
            user_data["inventory"].append(loot_item)
    except Exception as e:
        print_colored(f"Error in dungeon: {e}", FAIL)

# Shop functions
def visit_shop() -> None:
    print_header("Shop")
    print("Welcome to the shop! What would you like to buy?")
    for idx, item in enumerate(shop_items):
        print(f"{idx + 1}. {item['name']} - {item['price']} gold")
    print(f"{len(shop_items) + 1}. Exit shop")

    choice = int(input("Choose an item to buy (1-{}): ".format(len(shop_items) + 1)))
    if 1 <= choice <= len(shop_items):
        buy_item(choice - 1)
    elif choice == len(shop_items) + 1:
        print("Exiting shop...")
    else:
        print("Invalid choice.")

def buy_item(item_index: int) -> None:
    global user_data
    item = shop_items[item_index]
    if user_data["gold"] >= item["price"]:
        user_data["gold"] -= item["price"]
        user_data["inventory"].append(item["name"])
        print(f"You bought {item['name']} for {item['price']} gold!")
    else:
        print("You don't have enough gold!")

def equip_item(item_name: str) -> None:
    if not user_data["class"]:
        print(f"{FAIL}You need to create a character first! Use /new{ENDC}")
        return

    try:
        # Case-insensitive match for item in inventory
        item = next((i for i in user_data["inventory"] if i.lower() == item_name.lower()), None)
        if not item:
            print(f"{WARNING}You don't have {item_name} in your inventory.{ENDC}")
            return

        item_type = None
        effect = 0

        # Check if item is a weapon (case-insensitive)
        weapon_key = next((w for w in WEAPONS if w.lower() == item.lower()), None)
        if weapon_key:
            item_type = "weapon"
            effect = WEAPONS[weapon_key]["damage"]
        # Check if item is armor by keywords
        elif any(armor_type in item for armor_type in ["Armor", "Shield", "Helmet", "Boots"]):
            item_type = "armor"
            armor_tier = item.split()[0]
            effect = {
                "Bone": 5,
                "Iron": 10,
                "Steel": 15,
                "Dark": 15,
                "Dragon": 20
            }.get(armor_tier, 5)

        if item_type:
            user_data["equipped"][item_type] = {"name": item, "effect": effect}
            print_header("Equip Item")
            print(f"{OKGREEN}You equipped {item}!{ENDC}")
        else:
            print(f"{WARNING}{item} cannot be equipped.{ENDC}")
    except Exception as e:
        print(f"{FAIL}Error equipping item: {e}{ENDC}")

def show_stats() -> None:
    print_header("Your Stats")
    print(f"{BOLD}Level:{ENDC} {user_data['level']}")
    print(f"{BOLD}Health:{ENDC} {user_data['health']}/{user_data['max_health']}")
    print(f"{BOLD}Attack:{ENDC} {user_data['attack'] + (user_data['equipped']['weapon']['effect'] if user_data['equipped']['weapon'] else 0)}")
    print(f"{BOLD}Defense:{ENDC} {user_data['defense'] + (user_data['equipped']['armor']['effect'] if user_data['equipped']['armor'] else 0)}")
    print(f"{BOLD}Gold:{ENDC} {user_data['gold']}")
    print(f"{BOLD}Equipped Weapon:{ENDC} {user_data['equipped']['weapon']['name'] if user_data['equipped']['weapon'] else 'None'}")
    print(f"{BOLD}Equipped Armor:{ENDC} {user_data['equipped']['armor']['name'] if user_data['equipped']['armor'] else 'None'}")

# New functions for additional commands
def list_dungeons() -> None:
    print_header("Dungeon List")
    # Group dungeons by area
    dungeons_by_area = {}
    for dungeon in dungeons:
        area = dungeon.get('area', 'Unknown Area')
        if area not in dungeons_by_area:
            dungeons_by_area[area] = []
        dungeons_by_area[area].append(dungeon)

    # Display dungeons by area with completion status
    for area, area_dungeons in sorted(dungeons_by_area.items()):
        print(f"\n{BOLD}{CYAN}{area}:{ENDC}")
        for dungeon in sorted(area_dungeons, key=lambda x: x['name']):
            name = dungeon['name']
            completed = name in user_data.get("dungeons_completed", [])
            if completed:
                print(f"{OKGREEN}✓ {name}{ENDC}")
                # Show rewards if completed
                if "loot" in dungeon:
                    print(f"  Rewards collected: {', '.join(dungeon['loot'])}")
            else:
                # Show requirements if not completed
                reqs = []
                if "level_required" in dungeon:
                    reqs.append(f"Level {dungeon['level_required']}")
                if reqs:
                    print(f"{FAIL}✗ {name} (Required: {', '.join(reqs)}){ENDC}")
                else:
                    print(f"{FAIL}✗ {name}{ENDC}")
            # Show monsters
            if "monsters" in dungeon:
                print(f"  Monsters: {', '.join(dungeon['monsters'])}")

def show_bestiary() -> None:
    print_header("Bestiary")
    for monster in monsters:
        print(f"Name: {monster['name']}, Level: {monster['level']}, Health: {monster['health']}, Attack: {monster['attack']}, Drops: {', '.join(monster['drops'])}")

def show_support() -> None:
    print_header("Support Information")
    print_animated("For support, visit our Discord server or check the wiki.", CYAN, 0.01)

# Guild management commands
def get_next_rank(current_rank: str) -> Optional[str]:
    ranks = [
        {"name": "Novice", "level_req": 1, "quest_req": 0, "boss_req": 0},
        {"name": "Apprentice", "level_req": 5, "quest_req": 10, "boss_req": 1},
        {"name": "Journeyman", "level_req": 10, "quest_req": 25, "boss_req": 3},
        {"name": "Adventurer", "level_req": 15, "quest_req": 50, "boss_req": 5},
        {"name": "Veteran", "level_req": 20, "quest_req": 75, "boss_req": 10},
        {"name": "Elite", "level_req": 25, "quest_req": 100, "boss_req": 15},
        {"name": "Master", "level_req": 30, "quest_req": 150, "boss_req": 20},
        {"name": "Grandmaster", "level_req": 40, "quest_req": 200, "boss_req": 30},
        {"name": "Legend", "level_req": 50, "quest_req": 300, "boss_req": 50},
        {"name": "Hero", "level_req": 60, "quest_req": 400, "boss_req": 75},
        {"name": "Champion", "level_req": 70, "quest_req": 500, "boss_req": 100}
    ]

    for i, rank in enumerate(ranks):
        if rank["name"] == current_rank and i < len(ranks) - 1:
            return ranks[i + 1]
    return None

def get_adventurer_level_rewards(level: int) -> Dict[str, Any]:
    rewards = {
        1: {"description": "Access to basic quests", "bonuses": {}},
        2: {"description": "+5% Gold from monsters", "bonuses": {"gold_bonus": 0.05}},
        3: {"description": "Access to the Guild Shop", "bonuses": {"unlock_shop": True}},
        5: {"description": "+10% XP from all sources", "bonuses": {"xp_bonus": 0.10}},
        7: {"description": "Access to uncommon materials", "bonuses": {"unlock_materials": "uncommon"}},
        10: {"description": "+15% Damage against bosses", "bonuses": {"boss_damage": 0.15}},
        12: {"description": "Access to rare materials", "bonuses": {"unlock_materials": "rare"}},
        15: {"description": "+10% Crafting success chance", "bonuses": {"craft_bonus": 0.10}},
        20: {"description": "+20% Health in dungeons", "bonuses": {"dungeon_health": 0.20}},
        25: {"description": "Access to epic materials", "bonuses": {"unlock_materials": "epic"}},
        30: {"description": "Unique weapon for your class", "bonuses": {"unique_weapon": True}},
        35: {"description": "Pet evolution unlocked", "bonuses": {"pet_evolution": True}},
        40: {"description": "+25% All stats in trials", "bonuses": {"trial_stats": 0.25}},
        50: {"description": "Legendary equipment crafting", "bonuses": {"legendary_craft": True}},
        60: {"description": "Dimensional travel discount", "bonuses": {"dimension_discount": 0.50}},
        70: {"description": "Hero's equipment set", "bonuses": {"hero_set": True}}
    }

    return rewards.get(level, None)

def add_adventurer_exp(amount: int) -> None:
    """Add experience to the adventurer and check for level up

    Args:
        amount: Amount of experience to add
    """
    # Initialize adventurer data if it doesn't exist
    if "adventurer" not in user_data:
        user_data["adventurer"] = {
            "rank": "Novice",
            "exp": 0,
            "level": 1,
            "total_quests": 0,
            "bosses_defeated": 0,
            "reputation": 0
        }

    adv = user_data["adventurer"]

    # Add the experience
    adv["exp"] += amount

    # Check for level up
    exp_required = adv["level"] * 100

    # While we have enough exp for next level
    while adv["exp"] >= exp_required:
        adv["exp"] -= exp_required
        adv["level"] += 1
        exp_required = adv["level"] * 100

        rewards = get_adventurer_level_rewards(adv["level"])

        print_animated(f"\n{OKGREEN}◆◆◆ ADVENTURER LEVEL UP! ◆◆◆{ENDC}", delay=0.05)
        print_animated(f"{OKGREEN}You are now level {adv['level']}!{ENDC}", delay=0.05)

        if rewards:
            print_animated(f"{OKGREEN}New Reward: {rewards['description']}{ENDC}", delay=0.05)

        # Check if new rank is available
        check_rank_advancement()

def check_rank_advancement() -> None:
    """Check if adventurer qualifies for a rank advancement"""
    adv = user_data["adventurer"]
    next_rank = get_next_rank(adv["rank"])

    if next_rank and adv["level"] >= next_rank["level_req"] and \
       adv["total_quests"] >= next_rank["quest_req"] and \
       adv["bosses_defeated"] >= next_rank["boss_req"]:

        old_rank = adv["rank"]
        adv["rank"] = next_rank["name"]

        print_animated(f"\n{HEADER}▓▓▓ ADVENTURER RANK ADVANCEMENT! ▓▓▓{ENDC}", delay=0.05)
        print_animated(f"{CYAN}You have been promoted from {old_rank} to {next_rank['name']}!{ENDC}", delay=0.05)
        print_animated(f"{YELLOW}Visit the Adventurer's Guild to learn about your new benefits.{ENDC}", delay=0.05)

        # Add some gold as a reward
        reward_gold = adv["level"] * 100
        user_data["gold"] += reward_gold
        print_animated(f"{LIGHTYELLOW}You received {reward_gold} gold for your promotion!{ENDC}", delay=0.05)

def guild_join(guild_name: str) -> None:
    print(f"{YELLOW}The adventurer system has been updated!{ENDC}")
    print("You are now automatically part of the Adventurer's Guild.")
    print("Use '/guild' to view your adventurer status and guild information.")

def guild_leave() -> None:
    print(f"{YELLOW}You cannot leave the Adventurer's Guild.{ENDC}")
    print("All players are members of the guild for quest tracking and rewards.")
    print("Use '/guild' to view your adventurer status and guild information.")

def guild_list() -> None:
    print_header("Available Factions")
    # List of factions in the game world
    factions = [
        {"name": "Empire of Aetheria", "alignment": "Order", "description": "A powerful empire ruling the central kingdoms with strict laws and military might."},
        {"name": "Northern Tribes", "alignment": "Freedom", "description": "Independent clans of the frozen north, valuing strength and personal liberty."},
        {"name": "Order of the Sacred Flame", "alignment": "Light", "description": "Devotees of celestial powers, focusing on healing, protection, and banishing darkness."},
        {"name": "Shadowveil Syndicate", "alignment": "Shadow", "description": "A secretive network of spies, assassins, and information brokers."},
        {"name": "Arcane Confluence", "alignment": "Knowledge", "description": "Scholars and mages dedicated to the pursuit of magical knowledge."},
        {"name": "Wildwalker Coalition", "alignment": "Nature", "description": "Protectors of nature who draw power from the primal forces of the world."},
        {"name": "Ironheart Mercenary Company", "alignment": "Neutral", "description": "Elite mercenaries who sell their combat services to the highest bidder."},
        {"name": "Children of the Void", "alignment": "Chaos", "description": "Cultists who worship ancient entities from beyond reality."},
        {"name": "The Eternal Vigil", "alignment": "Spirit", "description": "Those who maintain the balance between the living world and spirit realm."},
        {"name": "Techsmith's Guild", "alignment": "Progress", "description": "Inventors and engineers pushing the boundaries of what's possible without magic."}
    ]

    # The Old Legacy factions
    print(f"{LIGHTBLUE}Original Factions:{ENDC}")
    print(f"- {CYAN}Warriors Guild{ENDC}: Combat specialists")
    print(f"- {BLUE}Mages Guild{ENDC}: Magic practitioners")
    print(f"- {YELLOW}Rogues Guild{ENDC}: Masters of stealth")
    print(f"- {OKGREEN}Paladins Guild{ENDC}: Holy warriors")
    print(f"- {LIGHTRED}Hunters Guild{ENDC}: Beast trackers")

    # Print the new factions
    print(f"\n{LIGHTMAGENTA}Major World Factions:{ENDC}")
    for faction in factions:
        print(f"- {BOLD}{faction['name']}{ENDC} ({faction['alignment']}): {faction['description']}")

    print(f"\n{YELLOW}Note:{ENDC} Factions represent the major powers in the world.")
    print("Your reputation with these factions affects quests, prices, and dialogue options.")
    print("The Adventurer's Guild remains neutral, working with all factions as needed.")

# Trading system
def trading_system() -> None:
    print_header("Trading System")
    print("Trading system is under development. Stay tuned!")

# Professions system
def professions_system() -> None:
    print_header("Professions System")
    if user_data["has_chosen_profession"]:
        print(f"You are currently a {user_data['profession']}.")
    else:
        print("You have not chosen a profession yet.")
        print("Available professions:")
        for prof in PROFESSIONS:
            print(f"- {prof}")
        choice = input("Choose a profession: ").capitalize()
        if choice in PROFESSIONS:
            user_data["profession"] = choice
            user_data["has_chosen_profession"] = True
            print(f"You are now a {choice}.")
        else:
            print("Invalid profession choice.")

def get_active_pet() -> Optional[Dict]:
    """Returns the currently active pet or None if no pet is active"""
    active_pet_name = user_data.get("active_pet", None)
    if not active_pet_name or active_pet_name not in user_data["pets"]:
        return None

    pet_info = PETS.get(active_pet_name, None)
    if not pet_info:
        return None

    # Initialize additional pet stats if they don't exist yet
    if "pet_stats" not in user_data:
        user_data["pet_stats"] = {}

    if active_pet_name not in user_data["pet_stats"]:
        pet_level = 1
        user_data["pet_stats"][active_pet_name] = {
            "level": pet_level,
            "exp": 0,
            "exp_next": 100 * pet_level,
            "loyalty": 50,  # 0-100 scale
            "abilities": [],
            "element": pet_info.get("element", "Nullum")
        }

    # Combine base pet info with pet stats
    full_pet_info = {**pet_info, **user_data["pet_stats"][active_pet_name]}
    full_pet_info["name"] = active_pet_name

    return full_pet_info

def pet_level_up(pet_name: str) -> bool:
    """Level up a pet if it has enough experience
    Returns True if level up successful, False otherwise
    """
    if pet_name not in user_data["pets"] or pet_name not in user_data.get("pet_stats", {}):
        return False

    pet_stats = user_data["pet_stats"][pet_name]
    if pet_stats["exp"] >= pet_stats["exp_next"]:
        pet_stats["level"] += 1
        pet_stats["exp"] = pet_stats["exp"] - pet_stats["exp_next"]
        pet_stats["exp_next"] = 100 * pet_stats["level"]

        # Check for new abilities at certain levels
        pet_base = PETS.get(pet_name, {})
        pet_abilities = pet_base.get("abilities", {})

        for level, ability in pet_abilities.items():
            if str(pet_stats["level"]) == level and ability not in pet_stats["abilities"]:
                pet_stats["abilities"].append(ability)
                print(f"{CYAN}Your pet {pet_name} learned a new ability: {ability}!{ENDC}")

        return True
    return False

def train_pet(pet_name: str) -> None:
    """Train your pet to increase its experience and loyalty"""
    print_header("Pet Training")

    if pet_name not in user_data["pets"]:
        print(f"You do not own a pet named {pet_name}.")
        return

    # Initialize pet stats if needed
    if "pet_stats" not in user_data:
        user_data["pet_stats"] = {}

    if pet_name not in user_data["pet_stats"]:
        user_data["pet_stats"][pet_name] = {
            "level": 1,
            "exp": 0,
            "exp_next": 100,
            "loyalty": 50,
            "abilities": [],
            "element": PETS.get(pet_name, {}).get("element", "Nullum")
        }

    print(f"Training {pet_name}...")

    # Training options
    print("\nTraining Activities:")
    print("1. Basic Training (+10 exp, +2 loyalty)")
    print("2. Advanced Drills (+25 exp, +1 loyalty)")
    print("3. Elemental Focus (+15 exp, chance to unlock elemental ability)")
    print("4. Loyalty Building (+5 exp, +5 loyalty)")
    print("0. Cancel")

    choice = input("\nChoose a training activity: ").strip()

    if choice == "0":
        return

    pet_stats = user_data["pet_stats"][pet_name]
    # We'll use pet stats directly instead of base pet data
    pet_element = pet_stats.get("element", "Nullum")

    training_cost = 10  # Base gold cost for training

    if user_data["gold"] < training_cost:
        print(f"{RED}You need {training_cost} gold to train your pet.{ENDC}")
        return

    user_data["gold"] -= training_cost

    if choice == "1":  # Basic Training
        exp_gain = 10
        loyalty_gain = 2
        print(f"{GREEN}You complete basic training with {pet_name}.{ENDC}")

    elif choice == "2":  # Advanced Drills
        exp_gain = 25
        loyalty_gain = 1
        print(f"{GREEN}You push {pet_name} through some challenging drills.{ENDC}")

    elif choice == "3":  # Elemental Focus
        exp_gain = 15
        loyalty_gain = 0

        # If pet doesn't have an element yet, chance to develop one
        if pet_element == "Nullum":
            element_choices = ["Fire", "Water", "Earth", "Air", "Lightning"]
            if random.random() < 0.25:  # 25% chance
                new_element = random.choice(element_choices)
                pet_stats["element"] = new_element
                print(f"{CYAN}Success! {pet_name} has connected with the {new_element} element!{ENDC}")
            else:
                print(f"You train {pet_name} to focus on elemental energy, but no connection forms yet.")
        else:
            print(f"You help {pet_name} strengthen their {pet_element} elemental connection.")
            # Chance to learn an elemental ability if at appropriate level
            if pet_stats["level"] >= 3 and random.random() < 0.2:  # 20% chance if level 3+
                elemental_abilities = {
                    "Fire": "Flame Burst",
                    "Water": "Healing Mist",
                    "Earth": "Stone Shield",
                    "Air": "Swift Movement",
                    "Lightning": "Shock Strike"
                }

                ability = elemental_abilities.get(pet_element, "Energy Pulse")
                if ability not in pet_stats["abilities"]:
                    pet_stats["abilities"].append(ability)
                    print(f"{CYAN}{pet_name} learned {ability}!{ENDC}")

    elif choice == "4":  # Loyalty Building
        exp_gain = 5
        loyalty_gain = 5
        print(f"{GREEN}You spend quality time bonding with {pet_name}.{ENDC}")

    else:
        print("Invalid choice.")
        return

    # Apply experience and loyalty gains
    pet_stats["exp"] += exp_gain
    pet_stats["loyalty"] = min(100, pet_stats["loyalty"] + loyalty_gain)

    print(f"Experience gained: {exp_gain}")
    print(f"Current EXP: {pet_stats['exp']}/{pet_stats['exp_next']}")
    print(f"Loyalty: {pet_stats['loyalty']}/100")

    # Check for level up
    if pet_level_up(pet_name):
        print(f"{YELLOW}{pet_name} leveled up to level {pet_stats['level']}!{ENDC}")

    # Learning chance based on loyalty
    if pet_stats["loyalty"] >= 75 and random.random() < 0.1:  # 10% chance if loyalty is high
        general_abilities = ["Quick Attack", "Protective Stance", "Find Treasure", "Scouting"]
        potential_ability = random.choice(general_abilities)

        if potential_ability not in pet_stats["abilities"]:
            pet_stats["abilities"].append(potential_ability)
            print(f"{CYAN}Due to your strong bond, {pet_name} learned {potential_ability}!{ENDC}")

def equip_pet(pet_name: str = "") -> None:
    """Equip or unequip a pet to accompany you in battle"""
    print_header("Equip Pet")

    if pet_name == "":
        # Show available pets
        if not user_data["pets"]:
            print("You have no pets to equip.")
            return

        current_pet = user_data.get("active_pet", None)
        if current_pet:
            print(f"Currently equipped: {current_pet}")
        else:
            print("No pet currently equipped.")

        print("\nAvailable pets:")
        for i, pet in enumerate(user_data["pets"], 1):
            print(f"{i}. {pet}")

        choice = input("\nEnter pet number to equip, or 0 to unequip current pet: ").strip()

        if choice == "0":
            if current_pet:
                user_data["active_pet"] = None
                print(f"Unequipped {current_pet}.")
            else:
                print("No pet is currently equipped.")
            return

        try:
            choice_idx = int(choice) - 1
            if 0 <= choice_idx < len(user_data["pets"]):
                pet_name = user_data["pets"][choice_idx]
            else:
                print("Invalid selection.")
                return
        except ValueError:
            print("Please enter a valid number.")
            return

    # Equip the selected pet
    if pet_name in user_data["pets"]:
        user_data["active_pet"] = pet_name
        print(f"Equipped {pet_name} as your active companion.")

        # Initialize pet stats if this is first time equipping
        if "pet_stats" not in user_data:
            user_data["pet_stats"] = {}

        if pet_name not in user_data["pet_stats"]:
            user_data["pet_stats"][pet_name] = {
                "level": 1,
                "exp": 0,
                "exp_next": 100,
                "loyalty": 50,
                "abilities": [],
                "element": PETS.get(pet_name, {}).get("element", "Nullum")
            }
    else:
        print(f"You don't have a pet named {pet_name}.")

def show_pets() -> None:
    """Display a detailed view of all owned pets"""
    print_header("Your Pets")

    if not user_data["pets"]:
        print("You have no pets.")
        return

    active_pet = user_data.get("active_pet", None)

    for pet_name in user_data["pets"]:
        pet_info = PETS.get(pet_name, None)
        if not pet_info:
            print(f"{pet_name} - A mysterious companion.")
            continue

        # Check if this is the active pet
        active_marker = f" {GREEN}[ACTIVE]{ENDC}" if pet_name == active_pet else ""

        # Get color based on pet rarity/type
        pet_color = CYAN if pet_name == "Hylit" else YELLOW if "Dragon" in pet_name or "Phoenix" in pet_name else WHITE

        # Display pet name with color and active status
        print(f"\n{pet_color}{pet_name}{ENDC}{active_marker}")
        print(f"Description: {pet_info['description']}")

        # Get pet stats if available
        if "pet_stats" in user_data and pet_name in user_data["pet_stats"]:
            pet_stats = user_data["pet_stats"][pet_name]

            # Display level and exp
            level = pet_stats["level"]
            exp = pet_stats["exp"]
            exp_next = pet_stats["exp_next"]
            loyalty = pet_stats["loyalty"]

            # Create progress bars
            exp_percent = exp / exp_next
            exp_bar = create_progress_bar(exp_percent, 15)

            # Set loyalty color based on percentage (without creating unused variable)
            loyalty_color = RED if loyalty < 30 else YELLOW if loyalty < 70 else GREEN

            print(f"Level: {level}")
            print(f"EXP: {exp_bar} {exp}/{exp_next}")
            print(f"Loyalty: {loyalty_color}{loyalty}/100{ENDC}")

            # Display element if any
            element = pet_stats.get("element", "Nullum")
            if element != "Nullum":
                element_color = get_element_color(element)
                print(f"Element: {element_color}{element}{ENDC}")

            # Display abilities
            abilities = pet_stats.get("abilities", [])
            if abilities:
                print("Abilities:")
                for ability in abilities:
                    print(f"  - {MAGENTA}{ability}{ENDC}")

        # Display base stat boosts
        boost_str = ", ".join(f"+{v} {k}" for k, v in pet_info.get("boost", {}).items())
        if boost_str:
            print(f"Stat Bonuses: {boost_str}")

    # Display commands for pet interaction
    print("\nPet Commands:")
    print("/equip_pet - Equip a pet for battle")
    print("/train_pet <name> - Train your pet to increase its level and abilities")
    print("/pet_info <name> - View detailed information about a specific pet")
    print("/feed_pet <name> - Feed your pet to increase loyalty")

def evolve_pet(pet_name: str) -> None:
    """Evolve a pet to its next form if requirements are met

    Args:
        pet_name: The name of the pet to evolve
    """
    print_header("Pet Evolution")

    # Check if pet exists
    if pet_name not in user_data["pets"]:
        print(f"{RED}You don't have a pet named '{pet_name}'.{ENDC}")
        return

    # Check if adventurer level requirement is met
    if "adventurer" not in user_data or user_data["adventurer"]["level"] < 35:
        print(f"{YELLOW}Pet evolution requires Adventurer Level 35.{ENDC}")
        print(f"Your current level: {user_data.get('adventurer', {}).get('level', 0)}")
        print("Continue advancing in the Adventurer's Guild to unlock this feature.")
        return

    # Check if pet has an evolution
    pet_base = PETS.get(pet_name, {})
    next_evolution = pet_base.get("evolution")

    if not next_evolution:
        print(f"{YELLOW}{pet_name} cannot evolve further.{ENDC}")
        return

    # Get evolution requirements
    if pet_name not in PET_EVOLUTIONS:
        print(f"{RED}Evolution data not found for {pet_name}.{ENDC}")
        return

    evolution_data = PET_EVOLUTIONS[pet_name]
    level_req = evolution_data.get("level_required", 0)
    loyalty_req = evolution_data.get("loyalty_required", 0)
    materials_req = evolution_data.get("materials_required", [])

    # Initialize pet stats if needed
    if "pet_stats" not in user_data:
        user_data["pet_stats"] = {}

    if pet_name not in user_data["pet_stats"]:
        user_data["pet_stats"][pet_name] = {
            "level": 1,
            "exp": 0,
            "exp_next": 100,
            "loyalty": 50,
            "abilities": [],
            "element": pet_base.get("element", "Nullum")
        }

    pet_stats = user_data["pet_stats"][pet_name]

    # Check requirements
    print(f"{CYAN}Evolution Target:{ENDC} {next_evolution}")
    print(f"\n{CYAN}Requirements:{ENDC}")

    # Level check
    level_ok = pet_stats["level"] >= level_req
    level_status = f"{GREEN}✓{ENDC}" if level_ok else f"{RED}✗{ENDC}"
    print(f"{level_status} Level {pet_stats['level']}/{level_req}")

    # Loyalty check
    loyalty_ok = pet_stats["loyalty"] >= loyalty_req
    loyalty_status = f"{GREEN}✓{ENDC}" if loyalty_ok else f"{RED}✗{ENDC}"
    print(f"{loyalty_status} Loyalty {pet_stats['loyalty']}/{loyalty_req}")

    # Materials check
    print(f"\n{CYAN}Required Materials:{ENDC}")
    materials_ok = True
    for material in materials_req:
        material_count = sum(1 for item in user_data.get("materials", []) if item == material)
        material_status = f"{GREEN}✓{ENDC}" if material_count > 0 else f"{RED}✗{ENDC}"
        print(f"{material_status} {material}: {material_count}/1")
        if material_count < 1:
            materials_ok = False

    # Check if all requirements are met
    if not (level_ok and loyalty_ok and materials_ok):
        print(f"\n{YELLOW}Cannot evolve yet. Please meet all requirements first.{ENDC}")
        return

    # Confirm evolution
    print(f"\n{CYAN}Your {pet_name} is ready to evolve into {next_evolution}!{ENDC}")
    confirm = input("Proceed with evolution? This will consume the required materials. (y/n): ").lower()

    if confirm != 'y':
        print("Evolution cancelled.")
        return

    # Process evolution - consume materials
    for material in materials_req:
        # Find and remove one instance of each required material
        for i, item in enumerate(user_data.get("materials", [])):
            if item == material:
                user_data["materials"].pop(i)
                break

    # Replace old pet with evolved form
    user_data["pets"].remove(pet_name)
    user_data["pets"].append(next_evolution)

    # Transfer pet stats to evolved form
    evolved_stats = pet_stats.copy()
    evolved_stats["element"] = PETS.get(next_evolution, {}).get("element", evolved_stats["element"])
    user_data["pet_stats"][next_evolution] = evolved_stats

    # If pet was active, update active pet
    if user_data.get("active_pet") == pet_name:
        user_data["active_pet"] = next_evolution

    # Clear old pet stats
    del user_data["pet_stats"][pet_name]

    # Show evolution animation
    print("\n")
    print_animated(f"{HEADER}✧・゚: *✧・゚:* EVOLUTION *:・゚✧*:・゚✧{ENDC}", delay=0.05)
    print_animated(f"{YELLOW}Your {pet_name} is evolving...{ENDC}", delay=0.1)
    time.sleep(1)

    for _ in range(5):
        print_animated(".", delay=0.3)

    print("\n")
    print_animated(f"{MAGENTA}Congratulations! {pet_name} has evolved into {next_evolution}!{ENDC}", delay=0.05)

    # Show new pet abilities
    new_abilities = PETS.get(next_evolution, {}).get("abilities", {})
    print(f"\n{CYAN}New Abilities:{ENDC}")
    for level, ability in new_abilities.items():
        print(f"- Level {level}: {ability}")

    # Add achievement
    # This should be added to the achievement system
    print(f"\n{GREEN}Achievement Unlocked: First Evolution{ENDC}")

    # Update adventurer experience
    add_adventurer_exp(50)  # Award exp for evolving a pet

def pet_info(pet_name: str) -> None:
    """Display detailed information about a specific pet"""
    print_header("Pet Information")

    if pet_name not in user_data["pets"]:
        print(f"You don't have a pet named {pet_name}.")
        return

    pet_base = PETS.get(pet_name, {})
    if not pet_base:
        print(f"No information available for {pet_name}.")
        return

    # Display pet details
    print(f"{YELLOW}Name:{ENDC} {pet_name}")
    print(f"{YELLOW}Description:{ENDC} {pet_base.get('description', 'A mysterious companion')}")
    print(f"{YELLOW}Rarity:{ENDC} {pet_base.get('rarity', 'Common')}")
    print(f"{YELLOW}Element:{ENDC} {pet_base.get('element', 'Nullum')}")
    print(f"{YELLOW}Combat Style:{ENDC} {pet_base.get('combat_style', 'Balanced')}")

    # Display evolution information
    evolution = pet_base.get("evolution")
    if evolution:
        print(f"\n{MAGENTA}Evolution Path:{ENDC} {pet_name} → {evolution}")

        if pet_name in PET_EVOLUTIONS:
            evo_data = PET_EVOLUTIONS[pet_name]
            print(f"{MAGENTA}Evolution Requirements:{ENDC}")
            print(f"- Level: {evo_data.get('level_required', 'Unknown')}")
            print(f"- Loyalty: {evo_data.get('loyalty_required', 'Unknown')}")
            materials = evo_data.get('materials_required', [])
            if materials:
                print(f"- Materials: {', '.join(materials)}")

            # Show adventurer level requirement
            print("- Adventurer Level: 35 (Evolution Feature)")
            print(f"\n{CYAN}Use '/evolve_pet {pet_name}' to evolve this pet when requirements are met.{ENDC}")
    else:
        print(f"\n{YELLOW}Evolution:{ENDC} Max evolution reached")

    # Display base stats
    boosts = pet_base.get("boost", {})
    if boosts:
        print(f"\n{YELLOW}Base Stat Bonuses:{ENDC}")
        for stat, value in boosts.items():
            print(f"  {stat.capitalize()}: +{value}")

    # Display additional stats if available
    if "pet_stats" in user_data and pet_name in user_data["pet_stats"]:
        pet_stats = user_data["pet_stats"][pet_name]

        print(f"\n{YELLOW}Current Stats:{ENDC}")
        print(f"Level: {pet_stats['level']}")

        # Calculate actual bonuses based on level
        level_multiplier = 1 + (pet_stats['level'] - 1) * 0.1  # 10% increase per level
        print(f"Stat Multiplier: x{level_multiplier:.1f} (from level)")

        print(f"\n{YELLOW}Calculated Combat Bonuses:{ENDC}")
        for stat, base_value in boosts.items():
            actual_value = round(base_value * level_multiplier)
            print(f"  {stat.capitalize()}: +{actual_value}")

        # Display element
        element = pet_stats.get("element", "Nullum")
        if element != "Nullum":
            element_color = get_element_color(element)
            print(f"\n{YELLOW}Element:{ENDC} {element_color}{element}{ENDC}")

        # Display abilities
        abilities = pet_stats.get("abilities", [])
        if abilities:
            print(f"\n{YELLOW}Abilities:{ENDC}")
            for ability in abilities:
                print(f"  - {MAGENTA}{ability}{ENDC}")

                # Display ability descriptions
                ability_desc = ABILITY_DESCRIPTIONS.get(ability, "No description available")
                print(f"    {ability_desc}")

        # Display loyalty and effects
        loyalty = pet_stats.get("loyalty", 0)
        loyalty_color = RED if loyalty < 30 else YELLOW if loyalty < 70 else GREEN

        print(f"\n{YELLOW}Loyalty:{ENDC} {loyalty_color}{loyalty}/100{ENDC}")

        # Loyalty effects
        if loyalty < 30:
            print("  Low loyalty: Pet may occasionally refuse to use abilities")
        elif loyalty < 70:
            print("  Moderate loyalty: Pet performs as expected")
        else:
            print("  High loyalty: Pet may occasionally perform critical hits")

def feed_pet(pet_name: str) -> None:
    """Feed your pet to increase loyalty"""
    print_header("Feed Pet")

    if pet_name not in user_data["pets"]:
        print(f"You don't have a pet named {pet_name}.")
        return

    # Initialize pet stats if needed
    if "pet_stats" not in user_data:
        user_data["pet_stats"] = {}

    if pet_name not in user_data["pet_stats"]:
        user_data["pet_stats"][pet_name] = {
            "level": 1,
            "exp": 0,
            "exp_next": 100,
            "loyalty": 50,
            "abilities": [],
            "element": PETS.get(pet_name, {}).get("element", "Nullum")
        }

    # Get food from inventory
    food_items = [item for item in user_data["inventory"] if "Food" in item or "Treat" in item or "Fish" in item or "Meat" in item or "Fruit" in item]

    if not food_items:
        print("You don't have any food items to feed your pet.")
        print("You can find food by hunting, fishing, or purchasing from shops.")
        return

    print(f"Selected pet: {pet_name}")
    print(f"Current loyalty: {user_data['pet_stats'][pet_name]['loyalty']}/100")
    print("\nAvailable food items:")

    for i, food in enumerate(food_items, 1):
        print(f"{i}. {food}")

    print("0. Cancel")

    choice = input("\nSelect food to give to your pet: ").strip()

    if choice == "0":
        return

    try:
        choice_idx = int(choice) - 1
        if 0 <= choice_idx < len(food_items):
            selected_food = food_items[choice_idx]

            # Remove the food from inventory
            user_data["inventory"].remove(selected_food)

            # Calculate loyalty and exp gain based on food type
            loyalty_gain = 5  # Base gain
            exp_gain = 2  # Base gain

            if "Premium" in selected_food:
                loyalty_gain += 10
                exp_gain += 5
            elif "Rare" in selected_food:
                loyalty_gain += 7
                exp_gain += 3

            if "Treat" in selected_food:
                loyalty_gain += 3
            elif "Meat" in selected_food:
                exp_gain += 2

            # Apply gains
            user_data["pet_stats"][pet_name]["loyalty"] = min(100, user_data["pet_stats"][pet_name]["loyalty"] + loyalty_gain)
            user_data["pet_stats"][pet_name]["exp"] += exp_gain

            print(f"\n{GREEN}You feed {selected_food} to {pet_name}.{ENDC}")
            print(f"Loyalty increased by {loyalty_gain}!")
            print(f"Experience gained: {exp_gain}")
            print(f"Current loyalty: {user_data['pet_stats'][pet_name]['loyalty']}/100")

            # Check for level up
            if pet_level_up(pet_name):
                print(f"{YELLOW}{pet_name} leveled up to level {user_data['pet_stats'][pet_name]['level']}!{ENDC}")

            # Special interactions based on pet
            if pet_name == "Hylit":
                print(f"{CYAN}Hylit: 'Thank you for the delicious food!'{ENDC}")
            elif "Dragon" in pet_name:
                print(f"{RED}Your dragon pet breathes a small flame of appreciation.{ENDC}")
            elif "Cat" in pet_name:
                print("Your cat purrs contentedly.")
            elif "Dog" in pet_name:
                print("Your dog wags its tail excitedly!")
        else:
            print("Invalid selection.")
    except ValueError:
        print("Please enter a valid number.")

# Achievements system
achievements = []

# Second show_achievements function removed (duplicate)
# Using the more complete version defined earlier

# Inventory management commands
def sort_inventory() -> None:
    user_data["inventory"].sort()
    print("Inventory sorted alphabetically.")

def filter_inventory() -> None:
    filter_term = input("Enter filter term: ").lower()
    filtered = [item for item in user_data["inventory"] if filter_term in item.lower()]
    print(f"Filtered inventory items containing '{filter_term}':")
    for item in filtered:
        print(f"- {item}")

# Quest management commands
def list_active_quests() -> None:
    print_header("Active Quests")
    if not user_data["active_quests"]:
        print("You have no active quests.")
        return
    for quest in user_data["active_quests"]:
        print(f"- {quest['name']}: {quest['description']}")

def complete_quest(quest_name: str) -> None:
    quest = next((q for q in user_data["active_quests"] if q["name"].lower() == quest_name.lower()), None)
    if quest:
        user_data["active_quests"].remove(quest)
        user_data["completed_quests"].append(quest["id"])
        reward = quest.get("reward", {})
        gold = reward.get("gold", 0)
        exp = reward.get("exp", 0)
        user_data["gold"] += gold
        user_data["exp"] += exp

        # Add adventurer experience (50% of regular exp, minimum 10)
        adv_exp = max(10, int(exp * 0.5))
        add_adventurer_exp(adv_exp)

        # Increment quest counter in adventurer data
        if "adventurer" in user_data:
            user_data["adventurer"]["total_quests"] += 1
            # Check if rank advancement is available

        # Award Stellarstones based on quest difficulty if gacha system is active
        if "gacha" in user_data:
            # Determine quest difficulty based on reward
            difficulty = "Easy"
            if gold >= 200 or exp >= 100:
                difficulty = "Medium"
            if gold >= 400 or exp >= 200:
                difficulty = "Hard"
            if gold >= 700 or exp >= 400:
                difficulty = "Very Hard"
            if gold >= 1000 or exp >= 600:
                difficulty = "Legendary"

            # Award Stellarstones through the hook
            hook_quest_reward(difficulty)
            check_rank_advancement()

        print(f"Quest '{quest['name']}' completed! You received {gold} gold and {exp} experience.")
        print(f"{CYAN}Adventurer Guild:{ENDC} +{adv_exp} adventurer exp")
        check_level_up()
        # Grant Hylit pet after completing quest 1
        if quest["id"] == 101 and "Hylit" not in user_data["pets"]:
            user_data["pets"].append("Hylit")
            print("Hylit has joined you as a companion!")
    else:
        print(f"No active quest named '{quest_name}' found.")

# Character definitions for gacha system
GACHA_CHARACTERS = {
    # Ancient Ruins Characters
    "Oracle of Ruins": {
        "rarity": "Legendary",
        "element": "Arcane",
        "weapon": "Staff",
        "class": "Mage",
        "background": "A mysterious seer who communes with the ancient spirits of the ruins. Her prophecies have guided many adventurers to treasure and safety.",
        "abilities": ["Ancient Revelation", "Time Echo", "Ruin's Whisper"],
        "sea_of_memories": ["Memory Shard I: Increases Arcane damage by 15%", 
                           "Memory Shard II: Ancient Revelation has a 25% chance to reveal enemy weaknesses",
                           "Memory Shard III: Time Echo can now rewind time for 3 seconds",
                           "Memory Shard IV: Gain 20% resistance to all status effects",
                           "Memory Shard V: Ruin's Whisper can now silence enemies for 2 turns",
                           "Memory Shard VI: Summon an Ancient Guardian once per battle"]
    },
    "Relic Hunter": {
        "rarity": "Epic",
        "element": "Earth",
        "weapon": "Whip",
        "class": "Hunter",
        "background": "A daring treasure hunter who has mapped most of the Ancient Ruins. She's as quick with a clever quip as she is with her trusty whip.",
        "abilities": ["Relic Sense", "Quickdraw", "Trap Disarmer"],
        "sea_of_memories": ["Memory Shard I: 15% chance to find additional loot", 
                           "Memory Shard II: Quickdraw attack speed increased by 20%",
                           "Memory Shard III: Can detect and disarm traps with 80% success rate",
                           "Memory Shard IV: 25% damage bonus against Constructs and Undead",
                           "Memory Shard V: Can use enemy weapons against them for one turn",
                           "Memory Shard VI: Find a Legendary relic once per dungeon"]
    },

    # Crystal Cave Characters
    "Crystal Harmonist": {
        "rarity": "Legendary",
        "element": "Light",
        "weapon": "Crystal Harp",
        "class": "Bard",
        "background": "A mystical musician who learned to communicate with the living crystals of the deep caves. Her music can heal allies or shatter enemies.",
        "abilities": ["Crystal Symphony", "Resonance Wave", "Prismatic Shield"],
        "sea_of_memories": ["Memory Shard I: Crystal Symphony heals 15% more", 
                           "Memory Shard II: Resonance Wave can stun enemies for 1 turn",
                           "Memory Shard III: Prismatic Shield reflects 20% damage back to attackers",
                           "Memory Shard IV: Music now affects a larger area (3 meter radius)",
                           "Memory Shard V: Can attune to crystals to gain their elemental properties",
                           "Memory Shard VI: Once per battle, can summon a Crystal Guardian"]
    },
    "Geode Sculptor": {
        "rarity": "Rare",
        "element": "Earth",
        "weapon": "Chisel and Hammer",
        "class": "Craftsman",
        "background": "A master artisan who can shape the cave's crystals into powerful tools and weapons. His sculptures sometimes seem to have a life of their own.",
        "abilities": ["Stone Shaper", "Crystal Infusion", "Geode Barrier"],
        "sea_of_memories": ["Memory Shard I: Can create temporary stone weapons", 
                           "Memory Shard II: Crystal Infusion adds elemental damage to weapons",
                           "Memory Shard III: Geode Barrier absorbs 30% more damage",
                           "Memory Shard IV: Can shape stone terrain to gain tactical advantage",
                           "Memory Shard V: Created sculptures can now attack autonomously",
                           "Memory Shard VI: Can transform into living crystal form for 3 turns"]
    },

    # Forest Characters
    "Guardian of the Grove": {
        "rarity": "Epic",
        "element": "Nature",
        "weapon": "Living Bow",
        "class": "Ranger",
        "background": "A forest protector blessed by the ancient tree spirits. She moves unseen through the woods and commands the forest itself to fight alongside her.",
        "abilities": ["Verdant Shot", "Nature's Command", "Forest Stride"],
        "sea_of_memories": ["Memory Shard I: Verdant Shot entangles targets", 
                           "Memory Shard II: Can command forest creatures to aid in battle",
                           "Memory Shard III: Forest Stride increases dodge rate by 30%",
                           "Memory Shard IV: Arrows can split to hit multiple targets",
                           "Memory Shard V: Can temporarily animate trees as guardians",
                           "Memory Shard VI: Once per battle, can summon a legendary forest beast"]
    },
    "Dryad Healer": {
        "rarity": "Rare",
        "element": "Nature",
        "weapon": "Staff of Seasons",
        "class": "Healer",
        "background": "A forest spirit in human form who channels the restorative powers of nature. Her healing changes with the seasons, each offering unique benefits.",
        "abilities": ["Seasonal Blessing", "Rejuvenation", "Thorn Ward"],
        "sea_of_memories": ["Memory Shard I: Healing effects increased by 20%", 
                           "Memory Shard II: Rejuvenation now removes one negative status effect",
                           "Memory Shard III: Thorn Ward reflects 15% damage to attackers",
                           "Memory Shard IV: Can now switch seasons at will rather than following natural cycle",
                           "Memory Shard V: Healing now spreads to nearby allies at 50% effectiveness",
                           "Memory Shard VI: Can temporarily transform allies into forest spirits"]
    },

    # Mountain Characters
    "Summit King": {
        "rarity": "Legendary",
        "element": "Ice",
        "weapon": "Great Axe",
        "class": "Warrior",
        "background": "The uncontested ruler of the highest peaks, he has survived storms and battles that would kill lesser beings. His roar can trigger avalanches.",
        "abilities": ["Mountain's Might", "Avalanche", "Frost Armor"],
        "sea_of_memories": ["Memory Shard I: Damage increased by 15% when at higher elevation", 
                           "Memory Shard II: Avalanche ability area of effect increased by 5 meters",
                           "Memory Shard III: Frost Armor reduces incoming damage by 30%",
                           "Memory Shard IV: Immune to cold and high-altitude effects",
                           "Memory Shard V: Can create ice constructs that fight alongside him",
                           "Memory Shard VI: Once per battle, can summon a blizzard that damages all enemies"]
    },
    "Eagle Rider": {
        "rarity": "Epic",
        "element": "Air",
        "weapon": "Twin Daggers",
        "class": "Scout",
        "background": "A fearless scout who bonded with a giant mountain eagle. Together they patrol the skies, dropping down on enemies with deadly precision.",
        "abilities": ["Diving Strike", "Eagle Eye", "Wind Dash"],
        "sea_of_memories": ["Memory Shard I: Diving Strike causes 20% more damage", 
                           "Memory Shard II: Eagle Eye reveals hidden enemies and traps",
                           "Memory Shard III: Wind Dash can be used twice in succession",
                           "Memory Shard IV: Eagle companion can now attack independently",
                           "Memory Shard V: Can create wind barriers that deflect projectiles",
                           "Memory Shard VI: Can temporarily grant flight to the entire party"]
    },

    # Temple Characters
    "Oracle Priestess": {
        "rarity": "Epic",
        "element": "Light",
        "weapon": "Sacred Texts",
        "class": "Mystic",
        "background": "A devoted servant of the temple who has been granted divine foresight. Her prophecies can reveal enemy weaknesses or hidden pathways.",
        "abilities": ["Divine Insight", "Blessing of Light", "Banishment"],
        "sea_of_memories": ["Memory Shard I: Divine Insight reveals additional information", 
                           "Memory Shard II: Blessing of Light heals and provides damage shield",
                           "Memory Shard III: Banishment has 25% chance to instantly defeat undead enemies",
                           "Memory Shard IV: Can predict enemy moves one turn in advance",
                           "Memory Shard V: Light abilities deal 50% more damage to dark enemies",
                           "Memory Shard VI: Once per battle, can channel divine intervention"]
    },
    "Temple Guardian": {
        "rarity": "Rare",
        "element": "Earth",
        "weapon": "Temple Shield and Mace",
        "class": "Guardian",
        "background": "A stoic protector enchanted to defend the sacred temple grounds. Once a stone statue, now imbued with life and purpose.",
        "abilities": ["Unyielding Defense", "Consecrated Ground", "Stone Form"],
        "sea_of_memories": ["Memory Shard I: Damage reduction increased by 15%", 
                           "Memory Shard II: Consecrated Ground heals allies in area by 5% per turn",
                           "Memory Shard III: Stone Form provides immunity to critical hits",
                           "Memory Shard IV: Can create walls of sacred stone",
                           "Memory Shard V: Attacks have 20% chance to stun enemies",
                           "Memory Shard VI: Can temporarily animate other statues to fight"]
    },

    # Swamp Characters
    "Bog Witch": {
        "rarity": "Epic",
        "element": "Nature",
        "weapon": "Cursed Staff",
        "class": "Witch",
        "background": "A reclusive witch who draws power from the murky swamps. Her concoctions can heal or harm, and few dare to seek her out.",
        "abilities": ["Miasma Cloud", "Bog Familiar", "Swamp Stride"],
        "sea_of_memories": ["Memory Shard I: Miasma Cloud affects larger area", 
                           "Memory Shard II: Bog Familiar can scout ahead without being detected",
                           "Memory Shard III: Swamp Stride allows faster movement through difficult terrain",
                           "Memory Shard IV: Poison effects last 2 turns longer",
                           "Memory Shard V: Can turn enemies into toads temporarily",
                           "Memory Shard VI: Can control swamp monsters to fight for her"]
    },
    "Venom Alchemist": {
        "rarity": "Rare",
        "element": "Nature",
        "weapon": "Poison Darts",
        "class": "Alchemist",
        "background": "A mysterious figure who studies the deadly creatures of the swamp. He has survived countless poisonings and now incorporates toxins into his weapons.",
        "abilities": ["Toxic Concoction", "Antidote", "Poison Resistance"],
        "sea_of_memories": ["Memory Shard I: Poison damage increased by 20%", 
                           "Memory Shard II: Antidote can cure any poison or disease",
                           "Memory Shard III: Complete immunity to poison effects",
                           "Memory Shard IV: Weapons automatically apply poison effect",
                           "Memory Shard V: Can extract venom from defeated enemies",
                           "Memory Shard VI: Can transform into poisonous mist form"]
    },

    # Desert characters
    "Mirage Walker": {
        "rarity": "Epic",
        "element": "Fire",
        "weapon": "Heat Blades",
        "class": "Nomad",
        "background": "A wanderer of the scorching deserts who has learned to manipulate heat and create illusions to survive. The blazing sun is both ally and weapon.",
        "abilities": ["Heat Mirage", "Sand Veil", "Sun's Fury"],
        "sea_of_memories": ["Memory Shard I: Heat Mirage creates decoys that confuse enemies", 
                           "Memory Shard II: Sand Veil provides 30% evasion in desert terrain",
                           "Memory Shard III: Sun's Fury deals 25% more damage at noon",
                           "Memory Shard IV: Can summon sandstorms that blind enemies",
                           "Memory Shard V: Heat attacks have a chance to cause Dehydration status",
                           "Memory Shard VI: Can transform into living flame to pass through barriers"]
    },
    "Dune Oracle": {
        "rarity": "Legendary",
        "element": "Arcane",
        "weapon": "Ancient Tablet",
        "class": "Prophet",
        "background": "A mystic who communes with ancient desert spirits and can read the future in the shifting sands. Their prophecies have never been wrong.",
        "abilities": ["Sand Divination", "Desert Whispers", "Temporal Glimpse"],
        "sea_of_memories": ["Memory Shard I: Sand Divination reveals hidden treasures in a wide area", 
                           "Memory Shard II: Desert Whispers allows communication with desert creatures",
                           "Memory Shard III: Temporal Glimpse shows enemy attack patterns before they happen",
                           "Memory Shard IV: Can summon ancient desert guardians to fight",
                           "Memory Shard V: Gains ability to temporarily stop time for 3 seconds",
                           "Memory Shard VI: Can create oases that heal all allies and restore resources"]
    },

    # Coastal/Ocean characters
    "Tide Caller": {
        "rarity": "Epic",
        "element": "Water",
        "weapon": "Coral Trident",
        "class": "Sea Shaman",
        "background": "Born during a tsunami, this coastal tribe member can control the tides and communicate with marine life. The ocean answers their call.",
        "abilities": ["Tidal Wave", "Marine Bond", "Whirlpool"],
        "sea_of_memories": ["Memory Shard I: Tidal Wave can push enemies back 50% further", 
                           "Memory Shard II: Marine Bond allows summoning of sea creatures to assist",
                           "Memory Shard III: Whirlpool traps enemies for 3 additional seconds",
                           "Memory Shard IV: Water attacks have 25% chance to cause Drowning status",
                           "Memory Shard V: Can breathe underwater indefinitely and swim at double speed",
                           "Memory Shard VI: Can part waters to create dry passages through water bodies"]
    },
    "Deep Navigator": {
        "rarity": "Rare",
        "element": "Water",
        "weapon": "Abyssal Harpoon",
        "class": "Diver",
        "background": "An explorer of the ocean depths who has adapted to the crushing pressure of the abyss. They've discovered ancient secrets in the darkest waters.",
        "abilities": ["Pressure Resistance", "Bioluminescence", "Depth Charge"],
        "sea_of_memories": ["Memory Shard I: Pressure Resistance reduces physical damage by 20%", 
                           "Memory Shard II: Bioluminescence reveals hidden enemies in darkness",
                           "Memory Shard III: Depth Charge can stun multiple enemies in a line",
                           "Memory Shard IV: Gains ability to communicate with deep sea creatures",
                           "Memory Shard V: Water pressure can be weaponized to crush armored foes",
                           "Memory Shard VI: Can create water spheres that function as portable breathing environments"]
    },

    # Volcano characters
    "Magma Sculptor": {
        "rarity": "Epic",
        "element": "Fire",
        "weapon": "Obsidian Hammer",
        "class": "Forgemaster",
        "background": "A master craftsman who lives within an active volcano and shapes molten rock with bare hands. Their creations are prized across all lands.",
        "abilities": ["Lava Shaping", "Heat Forge", "Magma Shield"],
        "sea_of_memories": ["Memory Shard I: Lava Shaping creates barriers that damage enemies on contact", 
                           "Memory Shard II: Heat Forge can temporarily enhance ally weapons with fire damage",
                           "Memory Shard III: Magma Shield absorbs 50% of incoming damage",
                           "Memory Shard IV: Can summon volcanic eruptions in small targeted areas",
                           "Memory Shard V: Fire immunity extends to allies within 10 meter radius",
                           "Memory Shard VI: Can create living magma golems that fight independently"]
    },
    "Ash Walker": {
        "rarity": "Uncommon",
        "element": "Fire",
        "weapon": "Charred Staff",
        "class": "Survivor",
        "background": "The sole survivor of a village destroyed by a volcanic eruption, they've learned to commune with the spirits of the ash and smoke.",
        "abilities": ["Ash Cloud", "Smoke Form", "Ember Sight"],
        "sea_of_memories": ["Memory Shard I: Ash Cloud blinds enemies for 3 seconds", 
                           "Memory Shard II: Smoke Form allows brief intangibility to pass through obstacles",
                           "Memory Shard III: Ember Sight can detect heat signatures through walls",
                           "Memory Shard IV: Ash attacks have chance to cause Choking status",
                           "Memory Shard V: Can resurrect once per day with 50% health if defeated",
                           "Memory Shard VI: Can draw power from fallen foes, gaining strength from defeats"]
    },

    # Tundra/Snow characters
    "Frost Weaver": {
        "rarity": "Epic",
        "element": "Ice",
        "weapon": "Crystal Scepter",
        "class": "Winter Mage",
        "background": "Born during the centennial blizzard, this mage can create intricate structures of living ice and bend the winter winds to their will.",
        "abilities": ["Ice Architecture", "Winter's Breath", "Glacial Spike"],
        "sea_of_memories": ["Memory Shard I: Ice Architecture creates complex structures that last 3x longer", 
                           "Memory Shard II: Winter's Breath can freeze water surfaces instantly",
                           "Memory Shard III: Glacial Spike damage increased by 40%",
                           "Memory Shard IV: Can create ice bridges to traverse gaps and chasms",
                           "Memory Shard V: Ice attacks have 30% chance to cause Frostbite status",
                           "Memory Shard VI: Can summon a legendary snow phoenix that heals and protects"]
    },
    "Aurora Hunter": {
        "rarity": "Rare",
        "element": "Light",
        "weapon": "Northern Bow",
        "class": "Pathfinder",
        "background": "A guide who navigates by the polar lights and has learned to harness their energy. They never lose their way, even in the most ferocious blizzards.",
        "abilities": ["Light Navigation", "Aurora Arrow", "Polar Sight"],
        "sea_of_memories": ["Memory Shard I: Light Navigation prevents party from getting lost in any terrain", 
                           "Memory Shard II: Aurora Arrow pierces through multiple enemies",
                           "Memory Shard III: Polar Sight allows vision through snowstorms and darkness",
                           "Memory Shard IV: Light attacks restore small amount of energy to allies",
                           "Memory Shard V: Can create illusions using aurora energy",
                           "Memory Shard VI: Can briefly stop a blizzard in a large area by absorbing its energy"]
    }
}

# Character rarity definitions
CHARACTER_RARITIES = {
    "Common": {
        "color": WHITE,
        "pull_rate": 60.0,  # 60% chance
        "stars": 1,
        "pity_increase": 0,
        "max_level": 40
    },
    "Uncommon": {
        "color": GREEN,
        "pull_rate": 25.0,  # 25% chance
        "stars": 2,
        "pity_increase": 1,
        "max_level": 50
    },
    "Rare": {
        "color": BLUE,
        "pull_rate": 10.0,  # 10% chance
        "stars": 3,
        "pity_increase": 2,
        "max_level": 60
    },
    "Epic": {
        "color": PURPLE,
        "pull_rate": 4.0,  # 4% chance
        "stars": 4,
        "pity_increase": 5,
        "max_level": 70
    },
    "Legendary": {
        "color": YELLOW,
        "pull_rate": 1.0,  # 1% chance
        "stars": 5,
        "pity_increase": 10,
        "max_level": 90
    }
}

# Character element definitions with color coding
CHARACTER_ELEMENTS = {
    "Fire": RED,
    "Water": BLUE,
    "Earth": DARKGRAY,
    "Air": CYAN,
    "Light": YELLOW,
    "Dark": DARKGRAY,
    "Lightning": LIGHTBLUE,
    "Ice": LIGHTCYAN,
    "Nature": GREEN,
    "Arcane": PURPLE
}

# Weapon rarities with colors and pull rates
WEAPON_RARITIES = {
    "Common": {
        "color": WHITE,
        "pull_rate": 60.0,  # 60% of weapon pulls (48% of total pulls)
        "stars": 1,
        "max_level": 20,
        "max_refinement": 5
    },
    "Uncommon": {
        "color": GREEN,
        "pull_rate": 25.0,  # 25% of weapon pulls (20% of total pulls)
        "stars": 2,
        "max_level": 40,
        "max_refinement": 5
    },
    "Rare": {
        "color": BLUE,
        "pull_rate": 10.0,  # 10% of weapon pulls (8% of total pulls)
        "stars": 3,
        "max_level": 50,
        "max_refinement": 5
    },
    "Epic": {
        "color": PURPLE,
        "pull_rate": 4.0,  # 4% of weapon pulls (3.2% of total pulls)
        "stars": 4,
        "max_level": 70,
        "max_refinement": 5
    },
    "Legendary": {
        "color": YELLOW,
        "pull_rate": 1.0,  # 1% of weapon pulls (0.8% of total pulls)
        "stars": 5,
        "max_level": 90,
        "max_refinement": 5
    }
}

# Banner rotation system
BANNER_ROTATION = {
    "last_update": None,  # Last time banners were updated
    "update_interval": 20,  # Days between banner updates
    "current_featured_character": None,  # Current featured 5* character
    "current_featured_weapons": [],  # Current featured 5* weapons (up to 2)
    "history": []  # History of past banners
}

# Character-specific weapons
CHARACTER_WEAPONS = {
    # Ancient Ruins Weapons
    "Oracle's Insight": {
        "type": "Staff",
        "rarity": "Legendary",
        "element": "Arcane",
        "base_attack": 45,
        "special_effect": "Increases Arcane damage by 25%",
        "description": "A staff of ancient origin, resonating with the knowledge of civilizations long past.",
        "for_character": "Oracle of Ruins"
    },
    "Crystal Greatsword": {
        "type": "Greatsword",
        "rarity": "Epic",
        "element": "Earth",
        "base_attack": 38,
        "special_effect": "15% chance to create crystal spikes when attacking",
        "description": "A massive sword with a blade of pure crystal that can manipulate the earth itself.",
        "for_character": "Crystal Knight"
    },

    # Forest Weapons
    "Living Bow": {
        "type": "Bow",
        "rarity": "Epic",
        "element": "Nature",
        "base_attack": 36,
        "special_effect": "Arrows have a 20% chance to entangle targets",
        "description": "A bow grown from a sacred tree, still alive and forming arrows from its own essence.",
        "for_character": "Guardian of the Grove"
    },
    "Staff of Seasons": {
        "type": "Staff",
        "rarity": "Rare",
        "element": "Nature",
        "base_attack": 30,
        "special_effect": "Healing effects change with seasons: Spring (HP), Summer (ATK), Fall (DEF), Winter (Resistance)",
        "description": "A staff that channels the power of the changing seasons, its appearance shifting throughout the year.",
        "for_character": "Dryad Healer"
    },

    # Mountain Weapons
    "Avalanche Axe": {
        "type": "Great Axe",
        "rarity": "Legendary",
        "element": "Ice",
        "base_attack": 48,
        "special_effect": "10% chance to trigger an avalanche, damaging all enemies",
        "description": "A massive axe eternally frosted with the coldest ice from the highest peaks.",
        "for_character": "Summit King"
    },
    "Alpine Longbow": {
        "type": "Longbow",
        "rarity": "Epic",
        "element": "Air",
        "base_attack": 37,
        "special_effect": "Arrows travel 50% faster and further at high altitudes",
        "description": "A bow designed for the thin air of mountain peaks, allowing for incredible range.",
        "for_character": "Alpine Hunter"
    },

    # Temple Weapons
    "Soul Mirror": {
        "type": "Catalyst",
        "rarity": "Legendary",
        "element": "Light",
        "base_attack": 42,
        "special_effect": "Reflects 15% of damage taken back to attacker",
        "description": "A sacred mirror that reveals one's true soul and reflects harmful intent.",
        "for_character": "Luminous Monk"
    },
    "Spirit Lance": {
        "type": "Polearm",
        "rarity": "Epic",
        "element": "Light",
        "base_attack": 39,
        "special_effect": "Attacks have a 25% chance to pierce defense",
        "description": "A lance infused with holy energy that can pierce through both physical and spiritual armor.",
        "for_character": "Temple Guardian"
    },

    # Swamp Weapons
    "Venomfang": {
        "type": "Dagger",
        "rarity": "Epic",
        "element": "Nature",
        "base_attack": 33,
        "special_effect": "Applies Poison status effect (20% chance)",
        "description": "A curved dagger extracted from the fang of a legendary venomous beast that lurked in the deepest swamps.",
        "for_character": "Marsh Stalker"
    },
    "Bogwood Staff": {
        "type": "Staff",
        "rarity": "Rare",
        "element": "Water",
        "base_attack": 28,
        "special_effect": "Creates a healing mist that restores 5% HP per turn in swampy areas",
        "description": "A staff carved from the ancient wood of a bog tree, imbued with restorative properties.",
        "for_character": "Swamp Witch"
    },

    # Desert Weapons
    "Sun's Fury": {
        "type": "Scimitar",
        "rarity": "Legendary",
        "element": "Fire",
        "base_attack": 45,
        "special_effect": "During daytime, increases attack by 30%",
        "description": "A curved blade that harnesses the scorching power of the desert sun.",
        "for_character": "Sandstorm Warrior"
    },
    "Dune Staff": {
        "type": "Staff",
        "rarity": "Epic",
        "element": "Earth",
        "base_attack": 36,
        "special_effect": "Can create quicksand under enemies (15% chance)",
        "description": "A staff topped with a sphere of compressed sand that can manipulate the desert itself.",
        "for_character": "Mirage Mage"
    },

    # Coastal Weapons
    "Tidecaller": {
        "type": "Trident",
        "rarity": "Legendary",
        "element": "Water",
        "base_attack": 44,
        "special_effect": "Creates a tidal wave dealing AoE damage once per battle",
        "description": "A trident forged from coral and enchanted pearls, said to be blessed by the sea gods.",
        "for_character": "Coastal Guardian"
    },
    "Coral Blade": {
        "type": "Sword",
        "rarity": "Epic",
        "element": "Water",
        "base_attack": 37,
        "special_effect": "Increases movement speed by 20% in water",
        "description": "A sword formed from living coral that remains sharp even underwater.",
        "for_character": "Reef Hunter"
    },

    # Volcano Weapons
    "Magma Hammer": {
        "type": "Hammer",
        "rarity": "Legendary",
        "element": "Fire",
        "base_attack": 50,
        "special_effect": "Creates a lava pool on critical hits, dealing damage over time",
        "description": "A massive hammer with a head of ever-molten stone from the heart of a volcano.",
        "for_character": "Lava King"
    },
    "Obsidian Daggers": {
        "type": "Dual Daggers",
        "rarity": "Epic",
        "element": "Fire",
        "base_attack": 34,
        "special_effect": "Attacks ignore 20% of enemy defense",
        "description": "Twin daggers of volcanic glass sharper than any steel, capable of slicing through almost anything.",
        "for_character": "Ashen Rogue"
    },

    # Tundra Weapons
    "Permafrost": {
        "type": "Sword",
        "rarity": "Legendary",
        "element": "Ice",
        "base_attack": 46,
        "special_effect": "25% chance to freeze targets for 1 turn",
        "description": "A sword of eternal ice that never melts, freezing anything it touches.",
        "for_character": "Frost Monarch"
    },
    "Aurora Bow": {
        "type": "Bow",
        "rarity": "Epic",
        "element": "Ice",
        "base_attack": 38,
        "special_effect": "Arrows leave a trail of ice, slowing enemies that cross it",
        "description": "A bow that channels the ethereal lights of the polar sky, creating arrows of pure cold light.",
        "for_character": "Tundra Hunter"
    }
}

def gacha_system() -> None:
    """Main interface for the character gacha system"""
    # Initialize gacha data if not present
    if "gacha" not in user_data:
        user_data["gacha"] = {
            "characters": [],  # List of owned character IDs
            "memory_shards": {},  # Character ID -> memory shard level (0-6)
            "pity_counter": 0,  # Pity counter for 5-star characters
            "pity_counter_4star": 0,  # Pity counter for 4-star characters
            "current_party": [],  # Active characters in battle party (max 4)
            "standard_pulls": 0,  # Total pulls on standard banner
            "limited_pulls": 0,  # Total pulls on limited banners
            "stellarstones": 1600,  # Starting currency for pulls
            "memory_dust": 0,  # Currency from duplicates
            "last_daily_check": None  # For daily rewards
        }

    clear_screen()
    print_header("Character Wish System")
    print_colored("Collect powerful characters to aid you on your journey!", CYAN)
    print()

    print_colored(f"Primogems: {user_data['gacha']['primogems']}", CYAN)
    print_colored(f"Stardust: {user_data['gacha']['stardust']}", BLUE)
    print()

    print_colored("1. Standard Wish (160 Primogems per pull)", WHITE)
    print_colored("2. Limited Character Wish (160 Primogems per pull)", WHITE)
    print_colored("3. View Character Collection", WHITE)
    print_colored("4. Manage Party", WHITE)
    print_colored("5. Character Details", WHITE)
    print_colored("6. Shop", WHITE)
    print_colored("7. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-7): {ENDC}"))

        if choice == 1:
            wish_standard_banner()
        elif choice == 2:
            wish_limited_banner()
        elif choice == 3:
            view_character_collection()
        elif choice == 4:
            manage_party()
        elif choice == 5:
            view_character_details()
        elif choice == 6:
            gacha_shop()
        elif choice == 7:
            return
        else:
            print_colored("Invalid choice. Please select 1-7.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    # Return to gacha menu after completing action
    wait_for_input()
    gacha_system()

def wish_standard_banner() -> None:
    """Pull from the standard banner with 85% weapons, 15% characters"""
    clear_screen()
    print_header("Standard Wish")

    # Check banner rotation
    check_banner_rotation()

    # Check if player has enough Stellarstones
    stones = user_data["gacha"]["stellarstones"]
    if stones < 160:
        print_colored(f"Not enough Stellarstones! You have {stones}, but need 160 for a wish.", RED)
        wait_for_input()
        return

    # Confirm wish
    print_colored(f"You have {stones} Stellarstones.", CYAN)
    print_colored("Standard Wish costs 160 Stellarstones per pull.", CYAN)
    print_colored("Pull rates: 85% weapons, 15% characters", YELLOW)
    print_colored("Weapon rates: 80% normal weapons, 20% 5★ weapons", YELLOW)
    print_colored("1. Single Wish (160 Stellarstones)", WHITE)
    print_colored("2. 10x Wish (1600 Stellarstones)", WHITE)
    print_colored("3. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-3): {ENDC}"))

        if choice == 1:
            # Single pull
            if stones >= 160:
                user_data["gacha"]["stellarstones"] -= 160
                user_data["gacha"]["standard_pulls"] += 1
                pull_character("standard")
            else:
                print_colored("Not enough Stellarstones!", RED)
        elif choice == 2:
            # 10x pull
            if stones >= 1600:
                user_data["gacha"]["stellarstones"] -= 1600
                user_data["gacha"]["standard_pulls"] += 10

                print_header("10x Wish Results")
                for _ in range(10):
                    pull_character("standard")
                    time.sleep(0.5)  # Dramatic pause between pulls
            else:
                print_colored("Not enough Primogems for 10 wishes!", RED)
        elif choice == 3:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

def check_banner_rotation() -> None:
    """Check if banners need to be rotated based on time elapsed"""
    # Initialize banner rotation data if not present
    if "banner_rotation" not in user_data:
        user_data["banner_rotation"] = {
            "last_update": datetime.now().strftime("%Y-%m-%d"),
            "current_featured_character": "Elysia",  # Default character
            "current_featured_weapons": ["Oracle's Insight", "Avalanche Axe"],  # Default weapons
            "history": []
        }

    # Check if it's time to rotate banners
    last_update_str = user_data["banner_rotation"]["last_update"]
    try:
        last_update = datetime.strptime(last_update_str, "%Y-%m-%d")
        current_date = datetime.now()
        days_passed = (current_date - last_update).days

        if days_passed >= BANNER_ROTATION["update_interval"] or user_data["banner_rotation"]["current_featured_character"] is None:
            rotate_banners()
    except (ValueError, TypeError):
        # If there's an error with the date format, force a rotation
        rotate_banners()

def rotate_banners() -> None:
    """Rotate the current banner to feature new characters and weapons"""
    # Get all legendary characters
    legendary_characters = [name for name, data in GACHA_CHARACTERS.items() 
                            if data.get("rarity") == "Legendary"]

    # Get all legendary weapons
    legendary_weapons = [name for name, data in CHARACTER_WEAPONS.items() 
                         if data.get("rarity") == "Legendary"]

    # If no legendary items found, use defaults
    if not legendary_characters:
        legendary_characters = ["Elysia"]

    if not legendary_weapons:
        legendary_weapons = ["Oracle's Insight", "Avalanche Axe"]

    # Select a new featured character that's different from the current one
    current_featured = user_data["banner_rotation"].get("current_featured_character")
    available_characters = [c for c in legendary_characters if c != current_featured]

    if not available_characters:
        available_characters = legendary_characters

    new_featured_character = random.choice(available_characters)

    # Select new featured weapons that are different from current ones
    current_weapons = user_data["banner_rotation"].get("current_featured_weapons", [])
    available_weapons = [w for w in legendary_weapons if w not in current_weapons]

    if len(available_weapons) < 2:
        available_weapons = legendary_weapons

    new_featured_weapons = random.sample(available_weapons, min(2, len(available_weapons)))

    # Store the history of the previous banner
    if current_featured:
        user_data["banner_rotation"]["history"].append({
            "character": current_featured,
            "weapons": current_weapons,
            "end_date": datetime.now().strftime("%Y-%m-%d")
        })

    # Update banner information
    user_data["banner_rotation"].update({
        "last_update": datetime.now().strftime("%Y-%m-%d"),
        "current_featured_character": new_featured_character,
        "current_featured_weapons": new_featured_weapons
    })

    print_colored("✨ The wish banners have been updated with new featured items! ✨", CYAN)
    print_colored(f"Featured Character: {new_featured_character}", YELLOW)
    print_colored(f"Featured Weapons: {', '.join(new_featured_weapons)}", YELLOW)

def wish_limited_banner() -> None:
    """Pull from the limited-time banner with featured items"""
    clear_screen()
    print_header("Limited Wish")

    # Check for banner rotation and fix error with missing definition
    check_banner_rotation()

    # Get current featured items
    featured_character = user_data["banner_rotation"].get("current_featured_character")
    featured_weapons = user_data["banner_rotation"].get("current_featured_weapons", [])

    # Get character data for display
    char_data = GACHA_CHARACTERS.get(featured_character, {})
    char_rarity = char_data.get("rarity", "Legendary")
    char_element = char_data.get("element", "Unknown")

    char_color = CHARACTER_RARITIES.get(char_rarity, {}).get("color", YELLOW)
    element_color = CHARACTER_ELEMENTS.get(char_element, WHITE)

    # Display banner information
    print_colored(f"Featured 5★ Character: {char_color}{featured_character}{ENDC} ({element_color}{char_element}{ENDC})", CYAN)
    print_colored("Featured 5★ Weapons:", CYAN)
    for weapon in featured_weapons:
        weapon_data = CHARACTER_WEAPONS.get(weapon, {})
        weapon_type = weapon_data.get("type", "Unknown")
        weapon_color = WEAPON_RARITIES.get(weapon_data.get("rarity", "Legendary"), {}).get("color", YELLOW)
        print_colored(f"  • {weapon_color}{weapon}{ENDC} ({weapon_type})", WHITE)

    print()
    print_colored("Pull rates: 85% weapons, 15% characters", YELLOW)
    print_colored("For characters: 50% chance to get featured 5★ when pulling a 5★!", YELLOW)
    print_colored("For weapons: 50% chance to get featured 5★ when pulling a 5★ weapon!", YELLOW)
    print_colored("If your last 5★ wasn't the featured item, the next one is guaranteed!", CYAN)

    # Last banner rotation date
    last_update = user_data["banner_rotation"].get("last_update", "Unknown")
    days_left = 20
    if last_update != "Unknown":
        try:
            last_date = datetime.strptime(last_update, "%Y-%m-%d")
            current_date = datetime.now()
            days_passed = (current_date - last_date).days
            days_left = max(0, BANNER_ROTATION["update_interval"] - days_passed)
        except (ValueError, TypeError):
            days_left = "Unknown"

    print_colored(f"Banner changes in {days_left} days", LIGHTGRAY)
    print()

    # Check if player has enough Stellarstones
    stones = user_data["gacha"]["stellarstones"]
    if stones < 160:
        print_colored(f"Not enough Stellarstones! You have {stones}, but need 160 for a wish.", RED)
        wait_for_input()
        return

    # Confirm wish options
    print_colored(f"You have {stones} Stellarstones.", CYAN)
    print_colored("Limited Wish costs 160 Stellarstones per pull.", CYAN)
    print_colored("1. Single Wish (160 Stellarstones)", WHITE)
    print_colored("2. 10x Wish (1600 Stellarstones)", WHITE)
    print_colored("3. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-3): {ENDC}"))

        if choice == 1:
            # Single pull
            if stones >= 160:
                user_data["gacha"]["stellarstones"] -= 160
                user_data["gacha"]["limited_pulls"] += 1

                # Use the featured character from banner rotation
                featured_character = user_data["banner_rotation"].get("current_featured_character")

                # Calculate the odds and perform pull with new rates:
                # 85% chance for weapons, 15% chance for characters
                item_type = random.choices(["weapon", "character"], weights=[85, 15], k=1)[0]

                if item_type == "weapon":
                    # Use pull_weapon function instead of perform_weapon_pull
                    pulled_item = pull_weapon(is_limited=True)
                    print_colored(f"You received a weapon: {pulled_item}", CYAN)
                else:
                    # Use pull_character function instead of perform_character_pull
                    pulled_character = pull_character("limited", featured_character)
            else:
                print_colored("Not enough Stellarstones!", RED)
        elif choice == 2:
            # 10x pull
            if stones >= 1600:
                user_data["gacha"]["stellarstones"] -= 1600
                user_data["gacha"]["limited_pulls"] += 10

                # Use the featured character from banner rotation
                featured_character = user_data["banner_rotation"].get("current_featured_character")

                print_header("10x Wish Results")
                # Guarantee at least one 4* or higher item in 10 pulls
                has_guaranteed_4star = False

                for i in range(10):
                    # For the last pull, ensure a 4* or higher if none received yet
                    if i == 9 and not has_guaranteed_4star:
                        # Force a 4* or higher pull
                        if random.random() < 0.2:  # 20% chance for character vs weapon for guaranteed
                            featured_character = user_data["banner_rotation"].get("current_featured_character")
                            pulled_character = pull_character("limited", featured_character, force_rarity="Epic")
                        else:
                            pulled_item = pull_weapon(is_limited=True, force_rarity="Epic")
                        has_guaranteed_4star = True
                    else:
                        # Normal pull with 85/15 split
                        item_type = random.choices(["weapon", "character"], weights=[85, 15], k=1)[0]

                        if item_type == "weapon":
                            pulled_item = pull_weapon(is_limited=True)
                            weapon_data = CHARACTER_WEAPONS.get(pulled_item, {})
                            weapon_rarity = weapon_data.get("rarity", "Common")
                            if weapon_rarity in ["Epic", "Legendary"]:
                                has_guaranteed_4star = True
                        else:
                            featured_character = user_data["banner_rotation"].get("current_featured_character")
                            pulled_character = pull_character("limited", featured_character)
                            char_data = GACHA_CHARACTERS.get(pulled_character, {})
                            char_rarity = char_data.get("rarity", "Common")
                            if char_rarity in ["Epic", "Legendary"]:
                                has_guaranteed_4star = True

                    time.sleep(0.5)  # Dramatic pause between pulls
            else:
                print_colored("Not enough Stellarstones for 10 wishes!", RED)
        elif choice == 3:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

def legacy_pull_character(banner_type: str, featured_character: Optional[str] = None) -> str:
    """
    Legacy pull function (replaced by enhanced pull_character)

    Args:
        banner_type: "standard" or "limited"
        featured_character: Name of the featured character on limited banner

    Returns:
        The name of the pulled character
    """
    # Use the new pull system instead
    featured_char = featured_character if featured_character is not None else ""
    return pull_character(banner_type, featured_char)

def view_character_collection() -> None:
    """View all characters in the collection"""
    clear_screen()
    print_header("Character Collection")

    characters = user_data["gacha"]["characters"]
    if not characters:
        print_colored("You haven't obtained any characters yet.", YELLOW)
        print_colored("Use the Wish system to obtain characters!", CYAN)
        wait_for_input()
        return

    # Group characters by rarity for better display
    characters_by_rarity = {
        "Legendary": [],
        "Epic": [],
        "Rare": [],
        "Uncommon": [],
        "Common": []
    }

    for char_name in characters:
        if char_name and char_name in GACHA_CHARACTERS:
            char_data = GACHA_CHARACTERS[char_name]
            rarity = char_data.get("rarity", "Common")
            characters_by_rarity[rarity].append(char_name)

    # Display collection stats
    total_chars = len(characters)
    total_possible = len(GACHA_CHARACTERS)
    collection_percent = int((total_chars / total_possible) * 100) if total_possible > 0 else 0

    # Create a visual progress bar for collection
    progress_bar = create_progress_bar(collection_percent / 100.0)
    print_colored(f"Collection Progress: {progress_bar} {collection_percent}% ({total_chars}/{total_possible})", CYAN)
    print()

    # Display characters by rarity (highest first)
    for rarity, chars in characters_by_rarity.items():
        if chars:
            rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)
            stars = CHARACTER_RARITIES.get(rarity, {}).get("stars", 1)
            star_display = "★" * stars

            print_colored(f"{rarity_color}{rarity} Characters ({star_display}){ENDC}", rarity_color + BOLD)

            for char_name in chars:
                char_data = GACHA_CHARACTERS.get(char_name, {})
                element = char_data.get("element", "")
                constellation = user_data["gacha"]["constellation_levels"].get(char_name, 0)

                element_color = CHARACTER_ELEMENTS.get(element, WHITE)

                # Show if character is in current party
                in_party = char_name in user_data["gacha"]["current_party"]
                party_indicator = f"{GREEN}[Active]{ENDC} " if in_party else ""

                print_colored(f"  {party_indicator}{char_name} - {element_color}{element}{ENDC} - C{constellation}", rarity_color)

    wait_for_input()

def view_character_details() -> None:
    """View detailed information about a specific character"""
    clear_screen()
    print_header("Character Details")

    characters = user_data["gacha"]["characters"]
    if not characters:
        print_colored("You haven't obtained any characters yet.", YELLOW)
        wait_for_input()
        return

    # Display characters with numbers for selection
    for i, char_name in enumerate(characters, 1):
        char_data = GACHA_CHARACTERS.get(char_name, {})
        rarity = char_data.get("rarity", "Common")
        element = char_data.get("element", "")

        rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)
        element_color = CHARACTER_ELEMENTS.get(element, WHITE)

        print_colored(f"{i}. {rarity_color}{char_name}{ENDC} - {element_color}{element}{ENDC}", WHITE)

    print_colored(f"{len(characters)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Select a character (1-{len(characters)+1}): {ENDC}"))

        if choice == len(characters)+1:
            return

        if 1 <= choice <= len(characters):
            selected_char = characters[choice-1]
            display_character_profile(selected_char)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def display_character_profile(character_name: str) -> None:
    """Display detailed profile for a specific character with Sea of Memories details"""
    clear_screen()
    print_header(f"Character Profile: {character_name}")

    if character_name not in GACHA_CHARACTERS:
        print_colored("Character not found in database.", RED)
        wait_for_input()
        return

    char_data = GACHA_CHARACTERS[character_name]

    # Get character details
    rarity = char_data.get("rarity", "Common")
    element = char_data.get("element", "None")
    weapon = char_data.get("weapon", "None")
    char_class = char_data.get("class", "None")
    background = char_data.get("background", "No background information available.")
    abilities = char_data.get("abilities", [])

    # Get colors for display
    rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)
    element_color = CHARACTER_ELEMENTS.get(element, WHITE)

    # Display character info
    stars = CHARACTER_RARITIES.get(rarity, {}).get("stars", 1)
    star_display = "★" * stars

    print_colored(f"Rarity: {rarity_color}{rarity} {star_display}{ENDC}", WHITE)
    print_colored(f"Element: {element_color}{element}{ENDC}", WHITE)
    print_colored(f"Weapon: {weapon}", WHITE)
    print_colored(f"Class: {char_class}", WHITE)
    print()

    print_colored("Background:", CYAN)
    print_colored(f"{background}", LIGHTGRAY)
    print()

    # Display abilities
    print_colored("Abilities:", CYAN)
    for ability in abilities:
        print_colored(f"- {ability}", GREEN)
    print()

    # Display Sea of Memories (formerly constellations)
    memory_level = user_data["gacha"]["memory_shards"].get(character_name, 0)
    print_colored(f"Sea of Memories (Unlocked: {memory_level}/6):", MAGENTA)

    sea_memories = char_data.get("sea_of_memories", [])
    for i, memory in enumerate(sea_memories):
        if i <= memory_level:
            # Unlocked memory
            print_colored(f"✓ {memory}", GREEN)
        else:
            # Locked memory
            print_colored(f"? {memory}", DARKGRAY)

    print()
    print_colored("Note: Obtain multiple copies of this character to unlock Memory Shards!", YELLOW)
    wait_for_input()

# Removed first occurrence of manage_party to fix duplication

def daily_login_rewards() -> None:
    """Daily login rewards for the gacha system"""
    clear_screen()
    print_header("Daily Login Rewards")

    # Initialize login rewards data if not present
    if "login_rewards" not in user_data:
        user_data["login_rewards"] = {
            "last_login": None,
            "consecutive_days": 0,
            "total_logins": 0,
            "claimed_milestones": []
        }

    # Check if already claimed today
    current_date = datetime.now().strftime("%Y-%m-%d")
    last_login = user_data["login_rewards"].get("last_login")

    if last_login == current_date:
        print_colored("You've already claimed your daily rewards today!", YELLOW)
        print_colored("Come back tomorrow for more rewards.", CYAN)

        # Show consecutive login info
        consecutive_days = user_data["login_rewards"]["consecutive_days"]
        total_logins = user_data["login_rewards"]["total_logins"]
        print_colored(f"Current login streak: {consecutive_days} days", GREEN)
        print_colored(f"Total login days: {total_logins}", BLUE)

        # Display next milestone
        _display_login_milestones()

        wait_for_input()
        return

    # Check if consecutive or missed days
    is_consecutive = False
    if last_login:
        try:
            last_date = datetime.strptime(last_login, "%Y-%m-%d")
            current_date_obj = datetime.strptime(current_date, "%Y-%m-%d")
            days_diff = (current_date_obj - last_date).days

            if days_diff == 1:
                is_consecutive = True
            elif days_diff > 1:
                # Streak broken
                print_colored(f"Your login streak has been reset! You missed {days_diff-1} days.", RED)
                user_data["login_rewards"]["consecutive_days"] = 0
        except (ValueError, TypeError):
            # Invalid date format
            is_consecutive = False

    # Update login data
    user_data["login_rewards"]["last_login"] = current_date
    user_data["login_rewards"]["total_logins"] += 1

    if is_consecutive:
        user_data["login_rewards"]["consecutive_days"] += 1
    else:
        user_data["login_rewards"]["consecutive_days"] = 1

    consecutive_days = user_data["login_rewards"]["consecutive_days"]
    total_logins = user_data["login_rewards"]["total_logins"]

    # Award daily rewards
    stellarstones = 40  # Base daily reward

    # Bonus for consecutive days
    if consecutive_days >= 30:
        stellarstones += 60  # 100 total for 30+ days streak
    elif consecutive_days >= 14:
        stellarstones += 40  # 80 total for 14+ days streak
    elif consecutive_days >= 7:
        stellarstones += 20  # 60 total for 7+ days streak

    user_data["gacha"]["stellarstones"] += stellarstones

    # Random materials reward
    materials = ["Character EXP Material", "Weapon Enhancement Crystal", "Refinement Ore", "Ascension Material"]
    material = random.choice(materials)
    amount = random.randint(3, 8)

    # Initialize materials inventory if needed
    if "materials" not in user_data:
        user_data["materials"] = {}

    if material not in user_data["materials"]:
        user_data["materials"][material] = 0

    user_data["materials"][material] += amount

    # Check for milestone rewards
    _check_login_milestones()

    # Display rewards
    print_colored(f"Daily Login Bonus - Day {consecutive_days}", GREEN)
    print_colored(f"You received {stellarstones} Stellarstones!", CYAN)
    print_colored(f"You received {amount} {material}!", BLUE)

    # Weekly bonus every 7 days
    if consecutive_days % 7 == 0:
        bonus_stones = 100
        user_data["gacha"]["stellarstones"] += bonus_stones
        print_colored(f"Weekly Bonus: +{bonus_stones} Stellarstones!", YELLOW)

    # Show streak info
    print()
    print_colored(f"Current login streak: {consecutive_days} days", GREEN)
    print_colored(f"Total login days: {total_logins}", BLUE)

    # Display login milestones
    _display_login_milestones()

    wait_for_input()

def _check_login_milestones() -> None:
    """Check and award login milestone rewards"""
    milestones = {
        7: {"reward": "Free 4★ Weapon", "description": "Choose one 4★ weapon"},
        14: {"reward": "1000 Stellarstones", "description": "1000 Stellarstones"},
        30: {"reward": "Free 4★ Character", "description": "Choose one 4★ character"},
        60: {"reward": "2000 Stellarstones", "description": "2000 Stellarstones"},
        90: {"reward": "3000 Stellarstones", "description": "3000 Stellarstones"},
        180: {"reward": "Free 5★ Character", "description": "Choose one 5★ character"},
        365: {"reward": "Free 5★ Weapon", "description": "Choose one 5★ weapon"}
    }

    total_days = user_data["login_rewards"]["total_logins"]
    claimed = user_data["login_rewards"].get("claimed_milestones", [])

    for days, reward_info in milestones.items():
        if total_days >= days and days not in claimed:
            print_colored("\n🎁 MILESTONE REWARD UNLOCKED! 🎁", YELLOW + BOLD)
            print_colored(f"Login Milestone: {days} days", GREEN)
            print_colored(f"Reward: {reward_info['reward']}", CYAN)
            print_colored("Claim this reward in the Milestone Rewards menu!", MAGENTA)

            # Mark as available but not claimed yet
            if "available_milestones" not in user_data["login_rewards"]:
                user_data["login_rewards"]["available_milestones"] = []

            if days not in user_data["login_rewards"]["available_milestones"]:
                user_data["login_rewards"]["available_milestones"].append(days)

def _display_login_milestones() -> None:
    """Display login milestone rewards"""
    milestones = {
        7: {"reward": "Free 4★ Weapon", "description": "Choose one 4★ weapon"},
        14: {"reward": "1000 Stellarstones", "description": "1000 Stellarstones"},
        30: {"reward": "Free 4★ Character", "description": "Choose one 4★ character"},
        60: {"reward": "2000 Stellarstones", "description": "2000 Stellarstones"},
        90: {"reward": "3000 Stellarstones", "description": "3000 Stellarstones"},
        180: {"reward": "Free 5★ Character", "description": "Choose one 5★ character"},
        365: {"reward": "Free 5★ Weapon", "description": "Choose one 5★ weapon"}
    }

    total_days = user_data["login_rewards"]["total_logins"]
    claimed = user_data["login_rewards"].get("claimed_milestones", [])
    available = user_data["login_rewards"].get("available_milestones", [])

    print()
    print_colored("Login Milestones:", CYAN + BOLD)

    for days, reward_info in sorted(milestones.items()):
        if days in claimed:
            status = f"{GREEN}[CLAIMED]{ENDC}"
        elif days in available:
            status = f"{YELLOW}[AVAILABLE]{ENDC}"
        elif total_days >= days:
            status = f"{YELLOW}[AVAILABLE]{ENDC}"
        else:
            status = f"{RED}[LOCKED]{ENDC} ({days-total_days} days left)"

        print_colored(f"  • Day {days}: {reward_info['reward']} {status}", WHITE)

def character_ascension() -> None:
    """Character leveling and ascension system"""
    clear_screen()
    print_header("Character Ascension")

    # Check if user has any characters
    if "gacha" not in user_data or not user_data["gacha"]["characters"]:
        print_colored("You don't have any characters to level up yet.", YELLOW)
        wait_for_input()
        return

    # Initialize character levels if not present
    if "character_levels" not in user_data["gacha"]:
        user_data["gacha"]["character_levels"] = {}

    if "character_ascensions" not in user_data["gacha"]:
        user_data["gacha"]["character_ascensions"] = {}

    # Initialize materials
    if "materials" not in user_data:
        user_data["materials"] = {
            "Character EXP Material": 50,  # Starting materials
            "Ascension Material": 20
        }

    # Display owned characters for selection
    characters = user_data["gacha"]["characters"]

    print_colored("Select a character to level up or ascend:", WHITE)
    for i, char_name in enumerate(characters, 1):
        char_data = GACHA_CHARACTERS.get(char_name, {})
        char_rarity = char_data.get("rarity", "Common")
        char_element = char_data.get("element", "None")

        # Get current level and ascension
        char_level = user_data["gacha"]["character_levels"].get(char_name, 1)
        char_ascension = user_data["gacha"]["character_ascensions"].get(char_name, 0)

        # Get maximum level based on rarity and ascension
        max_base_level = CHARACTER_RARITIES.get(char_rarity, {}).get("max_level", 40)
        max_level = max_base_level + (char_ascension * 10)

        # Calculate level progress color
        level_ratio = char_level / max_level
        if level_ratio >= 0.9:
            level_color = GREEN
        elif level_ratio >= 0.7:
            level_color = CYAN
        elif level_ratio >= 0.4:
            level_color = YELLOW
        else:
            level_color = RED

        rarity_color = CHARACTER_RARITIES.get(char_rarity, {}).get("color", WHITE)
        element_color = CHARACTER_ELEMENTS.get(char_element, WHITE)

        print_colored(f"{i}. {rarity_color}{char_name}{ENDC} - {element_color}{char_element}{ENDC} - {level_color}Lv.{char_level}/{max_level}{ENDC} - Ascension {char_ascension}", WHITE)

    print_colored(f"{len(characters)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Select a character (1-{len(characters)+1}): {ENDC}"))

        if choice == len(characters)+1:
            return

        if 1 <= choice <= len(characters):
            selected_char = characters[choice-1]
            ascend_character_menu(selected_char)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()
    character_ascension()

def open_weapon_refinement() -> None:
    """Opens the weapon refinement menu from other contexts"""
    # Call the main weapon refinement implementation
    # No need to set special flags as we're just redirecting
    weapon_refinement()

def pull_weapon(is_limited: bool = False, force_rarity: Optional[str] = None) -> str:
    """Pull a weapon from the weapon pool

    Args:
        is_limited: Whether this is a pull on the limited banner
        force_rarity: Force a specific rarity (for 10-pull guarantees)

    Returns:
        Name of the pulled weapon
    """
    # Get all available weapons
    all_weapons = list(CHARACTER_WEAPONS.keys())

    if not all_weapons:
        print_colored("No weapons available in the pool.", RED)
        return "No Weapon Found"

    # Initialize weapon categories by rarity
    weapons_by_rarity = {
        "Common": [],
        "Uncommon": [],
        "Rare": [],
        "Epic": [],
        "Legendary": []
    }

    # Group weapons by rarity
    for weapon_name in all_weapons:
        weapon_data = CHARACTER_WEAPONS.get(weapon_name, {})
        rarity = weapon_data.get("rarity", "Common")
        weapons_by_rarity[rarity].append(weapon_name)

    # Check for 5-star pity (weapon)
    if "weapon_pity_5star" not in user_data["gacha"]:
        user_data["gacha"]["weapon_pity_5star"] = 0

    if "weapon_pity_4star" not in user_data["gacha"]:
        user_data["gacha"]["weapon_pity_4star"] = 0

    # Increment pity counters
    user_data["gacha"]["weapon_pity_5star"] += 1
    user_data["gacha"]["weapon_pity_4star"] += 1

    # Generate probabilities - 80% of weapon pulls are normal, 20% are 5-star
    if force_rarity:
        rarity = force_rarity
    else:
        # Check for 5-star pity (80 pulls guaranteed)
        if user_data["gacha"]["weapon_pity_5star"] >= 80:
            rarity = "Legendary"
            user_data["gacha"]["weapon_pity_5star"] = 0
        # Check for 4-star pity (10 pulls guaranteed)
        elif user_data["gacha"]["weapon_pity_4star"] >= 10:
            # Determine if 4 or 5 star
            if random.random() < 0.1:  # 10% chance for 5-star
                rarity = "Legendary"
            else:
                rarity = "Epic"
            user_data["gacha"]["weapon_pity_4star"] = 0
        # Regular probability check
        else:
            rarities = ["Common", "Uncommon", "Rare", "Epic", "Legendary"]
            weights = [60.0, 25.0, 10.0, 4.0, 1.0]  # Based on WEAPON_RARITIES pull_rate
            rarity = random.choices(rarities, weights=weights, k=1)[0]

            if rarity == "Legendary":
                user_data["gacha"]["weapon_pity_5star"] = 0
            if rarity in ["Epic", "Legendary"]:
                user_data["gacha"]["weapon_pity_4star"] = 0

    # Get the weapon based on rarity
    if rarity == "Legendary" and is_limited and user_data["banner_rotation"].get("current_featured_weapons"):
        featured_weapons = user_data["banner_rotation"]["current_featured_weapons"]
        # 50/50 chance to get featured weapon vs random 5-star
        if random.random() < 0.5:
            pulled_weapon = random.choice(featured_weapons)
            print_colored("✨ You won the 50/50 and got a featured weapon! ✨", YELLOW)
        else:
            # Random legendary weapon
            legendary_weapons = weapons_by_rarity["Legendary"]
            if legendary_weapons:
                pulled_weapon = random.choice(legendary_weapons)
            else:
                pulled_weapon = random.choice(all_weapons)
    else:
        # Get weapon from selected rarity pool
        if weapons_by_rarity[rarity]:
            pulled_weapon = random.choice(weapons_by_rarity[rarity])
        else:
            # Fallback to any weapon
            pulled_weapon = random.choice(all_weapons)

    # Store the weapon
    if "weapons" not in user_data["gacha"]:
        user_data["gacha"]["weapons"] = []

    # Check if user already has this weapon
    is_new = pulled_weapon not in user_data["gacha"]["weapons"]
    if is_new:
        user_data["gacha"]["weapons"].append(pulled_weapon)
    else:
        # Grant weapon refinement materials instead
        if "refinement_materials" not in user_data["materials"]:
            user_data["materials"]["Refinement Ore"] = 0

        # Get weapon rarity for refinement value
        weapon_data = CHARACTER_WEAPONS.get(pulled_weapon, {})
        weapon_rarity = weapon_data.get("rarity", "Common")

        # Higher rarity gives more refinement materials
        refinement_bonus = {
            "Common": 1,
            "Uncommon": 2,
            "Rare": 3,
            "Epic": 5,
            "Legendary": 10
        }.get(weapon_rarity, 1)

        user_data["materials"]["Refinement Ore"] = user_data["materials"].get("Refinement Ore", 0) + refinement_bonus
        print_colored(f"Duplicate weapon: +{refinement_bonus} Refinement Ore", BLUE)

    # Display the result
    weapon_data = CHARACTER_WEAPONS.get(pulled_weapon, {})
    weapon_rarity = weapon_data.get("rarity", "Common")
    weapon_type = weapon_data.get("type", "Weapon")
    rarity_color = WEAPON_RARITIES.get(weapon_rarity, {}).get("color", WHITE)

    # Generate stars based on rarity
    stars = WEAPON_RARITIES.get(weapon_rarity, {}).get("stars", 1)
    star_display = "★" * stars

    # Show special effect if it exists
    special_effect = weapon_data.get("special_effect", "")

    # Print result
    print_colored(f"\n{is_new and 'NEW! ' or ''}Weapon: {rarity_color}{pulled_weapon}{ENDC} ({weapon_type}) - {rarity_color}{star_display}{ENDC}", rarity_color)
    if special_effect:
        print_colored(f"  Special Effect: {special_effect}", CYAN)

    # Assign the weapon automatically if it's specific to a character
    for_character = weapon_data.get("for_character")
    if for_character and for_character in user_data["gacha"]["characters"]:
        # Check if "equipped_weapons" exists
        if "equipped_weapons" not in user_data["gacha"]:
            user_data["gacha"]["equipped_weapons"] = {}

        # Equip the weapon to its character
        user_data["gacha"]["equipped_weapons"][for_character] = pulled_weapon
        print_colored(f"Automatically equipped {pulled_weapon} to {for_character}!", GREEN)

    return pulled_weapon

def pull_character(banner_type: str = "standard", featured_character: str = "", force_rarity: Optional[str] = None) -> str:
    """Pull a character from the character pool

    Args:
        banner_type: The type of banner to pull from ('standard', 'limited', etc.)
        featured_character: The featured character on the banner
        force_rarity: Force a specific rarity (for 10-pull guarantees)

    Returns:
        Name of the pulled character
    """
    # Get all available characters
    all_characters = list(GACHA_CHARACTERS.keys())

    if not all_characters:
        print_colored("No characters available in the pool.", RED)
        return "No Character Found"

    # Initialize character categories by rarity
    characters_by_rarity = {
        "Common": [],
        "Uncommon": [],
        "Rare": [],
        "Epic": [],
        "Legendary": []
    }

    # Group characters by rarity
    for char_name in all_characters:
        char_data = GACHA_CHARACTERS.get(char_name, {})
        rarity = char_data.get("rarity", "Common")
        characters_by_rarity[rarity].append(char_name)

    # Check for 5-star pity
    if "character_pity_5star" not in user_data["gacha"]:
        user_data["gacha"]["character_pity_5star"] = 0

    if "character_pity_4star" not in user_data["gacha"]:
        user_data["gacha"]["character_pity_4star"] = 0

    # Check for 50/50 pity (losing 50/50 guarantees next 5-star is featured)
    if "character_guaranteed_featured" not in user_data["gacha"]:
        user_data["gacha"]["character_guaranteed_featured"] = False

    # Increment pity counters
    user_data["gacha"]["character_pity_5star"] += 1
    user_data["gacha"]["character_pity_4star"] += 1

    # Generate probabilities
    if force_rarity:
        rarity = force_rarity
    else:
        # Check for 5-star pity (90 pulls guaranteed)
        if user_data["gacha"]["character_pity_5star"] >= 90:
            rarity = "Legendary"
            user_data["gacha"]["character_pity_5star"] = 0
        # Check for 4-star pity (10 pulls guaranteed)
        elif user_data["gacha"]["character_pity_4star"] >= 10:
            # Determine if 4 or 5 star
            if random.random() < 0.05:  # 5% chance for 5-star on 4-star pity
                rarity = "Legendary"
            else:
                rarity = "Epic"
            user_data["gacha"]["character_pity_4star"] = 0
        # Regular probability check
        else:
            rarities = ["Common", "Uncommon", "Rare", "Epic", "Legendary"]
            weights = [30.0, 35.0, 20.0, 13.0, 2.0]  # Based on CHARACTER_RARITIES pull_rate
            rarity = random.choices(rarities, weights=weights, k=1)[0]

            if rarity == "Legendary":
                user_data["gacha"]["character_pity_5star"] = 0
            if rarity in ["Epic", "Legendary"]:
                user_data["gacha"]["character_pity_4star"] = 0

    # Get the character based on rarity
    pulled_character = "None"

    # 50/50 chance for featured character on limited banner for 5-stars
    if rarity == "Legendary" and banner_type == "limited" and featured_character:
        if user_data["gacha"]["character_guaranteed_featured"]:
            # Guaranteed featured character
            pulled_character = featured_character
            user_data["gacha"]["character_guaranteed_featured"] = False
            print_colored("✨ Guaranteed featured character! ✨", YELLOW)
        elif random.random() < 0.5:  # 50% chance to get featured
            pulled_character = featured_character
            print_colored("✨ You won the 50/50 and got the featured character! ✨", YELLOW)
            user_data["gacha"]["character_guaranteed_featured"] = False
        else:
            # Lost 50/50, get a random legendary character
            non_featured_legendaries = [c for c in characters_by_rarity["Legendary"] if c != featured_character]
            if non_featured_legendaries:
                pulled_character = random.choice(non_featured_legendaries)
            else:
                pulled_character = random.choice(all_characters)  # Fallback

            # Set guaranteed for next 5-star
            user_data["gacha"]["character_guaranteed_featured"] = True
            print_colored("💔 You lost the 50/50, but your next 5-star is guaranteed to be the featured character! 💔", MAGENTA)
    else:
        # Get character from selected rarity pool
        if characters_by_rarity[rarity]:
            pulled_character = random.choice(characters_by_rarity[rarity])
        else:
            # Fallback to any character
            pulled_character = random.choice(all_characters)

    # Store the character
    if "characters" not in user_data["gacha"]:
        user_data["gacha"]["characters"] = []

    # Check if user already has this character
    is_new = pulled_character not in user_data["gacha"]["characters"]
    if is_new:
        user_data["gacha"]["characters"].append(pulled_character)
    else:
        # Grant memory shards instead
        if "memory_shards" not in user_data["gacha"]:
            user_data["gacha"]["memory_shards"] = {}

        if pulled_character not in user_data["gacha"]["memory_shards"]:
            user_data["gacha"]["memory_shards"][pulled_character] = 0

        # Get character rarity for shard value
        char_data = GACHA_CHARACTERS.get(pulled_character, {})
        char_rarity = char_data.get("rarity", "Common")

        # Higher rarity gives more shards
        shard_bonus = {
            "Common": 1,
            "Uncommon": 2,
            "Rare": 5,
            "Epic": 10,
            "Legendary": 25
        }.get(char_rarity, 1)

        user_data["gacha"]["memory_shards"][pulled_character] += shard_bonus
        print_colored(f"Duplicate character: +{shard_bonus} Memory Shards for {pulled_character}", BLUE)

    # Display the result
    char_data = GACHA_CHARACTERS.get(pulled_character, {})
    char_rarity = char_data.get("rarity", "Common")
    char_element = char_data.get("element", "None")
    rarity_color = CHARACTER_RARITIES.get(char_rarity, {}).get("color", WHITE)
    element_color = CHARACTER_ELEMENTS.get(char_element, WHITE)

    # Generate stars based on rarity
    stars = CHARACTER_RARITIES.get(char_rarity, {}).get("stars", 1)
    star_display = "★" * stars

    # Print result
    print_colored(f"\n{is_new and 'NEW! ' or ''}Character: {rarity_color}{pulled_character}{ENDC} - {element_color}{char_element}{ENDC} - {rarity_color}{star_display}{ENDC}", rarity_color)

    # Check if there's a special weapon for this character
    if is_new:
        for weapon_name, weapon_data in CHARACTER_WEAPONS.items():
            if weapon_data.get("for_character") == pulled_character:
                # Check if we have this weapon
                if "weapons" in user_data["gacha"] and weapon_name in user_data["gacha"]["weapons"]:
                    # Auto-equip the weapon
                    if "equipped_weapons" not in user_data["gacha"]:
                        user_data["gacha"]["equipped_weapons"] = {}

                    user_data["gacha"]["equipped_weapons"][pulled_character] = weapon_name
                    print_colored(f"Automatically equipped {weapon_name} to {pulled_character}!", GREEN)

    return pulled_character

def view_weapon_materials() -> None:
    """View weapon enhancement and refinement materials"""
    clear_screen()
    print_header("Weapon Enhancement Materials")

    # Check current materials
    enhancement_crystals = user_data["materials"].get("Weapon Enhancement Crystal", 0)
    refinement_ores = user_data["materials"].get("Refinement Ore", 0)

    print_colored("Current Materials:", CYAN)
    print_colored(f"• Weapon Enhancement Crystals: {enhancement_crystals}", GREEN)
    print_colored(f"• Refinement Ores: {refinement_ores}", BLUE)

    print()
    print_colored("Material Usage:", CYAN)
    print_colored("• Enhancement Crystals are used to level up weapons", GREEN)
    print_colored("• Refinement Ores are used to increase a weapon's special effect strength", BLUE)

    print()
    print_colored("Ways to Obtain Materials:", CYAN)
    print_colored("• Daily login rewards", WHITE)
    print_colored("• Duplicate weapons from gacha pulls", WHITE)
    print_colored("• Material farming at specific locations", WHITE)
    print_colored("• Weekend material bonuses", WHITE)

    wait_for_input()

def ascend_character(character_name: str) -> None:
    """Ascend a character to increase their level cap"""
    clear_screen()

    char_data = GACHA_CHARACTERS.get(character_name, {})
    char_rarity = char_data.get("rarity", "Common")

    # Get current level and ascension
    char_level = user_data["gacha"]["character_levels"].get(character_name, 1)
    char_ascension = user_data["gacha"]["character_ascensions"].get(character_name, 0)

    # Get maximum level based on rarity and ascension
    max_base_level = CHARACTER_RARITIES.get(char_rarity, {}).get("max_level", 40)
    max_level = max_base_level + (char_ascension * 10)

    # Get max possible ascension based on rarity
    max_ascension = {
        "Common": 2,
        "Uncommon": 3,
        "Rare": 4,
        "Epic": 5,
        "Legendary": 6
    }.get(char_rarity, 2)

    # Check if already at max ascension
    if char_ascension >= max_ascension:
        print_colored(f"{character_name} is already at maximum ascension ({max_ascension}).", YELLOW)
        wait_for_input()
        return

    # Check if character is at appropriate level for ascension
    if char_level < max_level:
        print_colored(f"{character_name} needs to be at level {max_level} before ascending.", RED)
        print_colored(f"Current level: {char_level}/{max_level}", YELLOW)
        wait_for_input()
        return

    # Materials needed based on rarity and current ascension
    base_materials = {
        "Common": 5,
        "Uncommon": 8,
        "Rare": 12,
        "Epic": 20,
        "Legendary": 30
    }.get(char_rarity, 10)

    # Materials increase with each ascension
    materials_needed = base_materials + (char_ascension * 5)

    # Materials owned
    ascension_materials = user_data["materials"].get("Ascension Material", 0)

    # Display info
    print_header(f"Ascend {character_name}")
    print_colored(f"Current Ascension: {char_ascension}/{max_ascension}", CYAN)
    print_colored(f"Current Level: {char_level}/{max_level}", GREEN)
    print_colored(f"Ascension Materials available: {ascension_materials}", BLUE)
    print_colored(f"Materials needed for ascension: {materials_needed}", YELLOW)

    print()
    print_colored("After ascending:", WHITE)
    new_max_level = max_base_level + ((char_ascension + 1) * 10)
    print_colored(f"• New level cap will be {new_max_level}", GREEN)
    print_colored("• Character stats will increase", CYAN)

    print()
    print_colored("1. Ascend Character", WHITE)
    print_colored("2. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-2): {ENDC}"))

        if choice == 1:
            if ascension_materials >= materials_needed:
                user_data["materials"]["Ascension Material"] -= materials_needed
                user_data["gacha"]["character_ascensions"][character_name] = char_ascension + 1
                print_colored(f"{character_name} ascended to phase {char_ascension + 1}!", GREEN)
                print_colored(f"New level cap: {new_max_level}", CYAN)
            else:
                print_colored(f"Not enough Ascension Materials. Need {materials_needed}, have {ascension_materials}.", RED)
        elif choice == 2:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def view_ascension_materials() -> None:
    """View character ascension materials"""
    clear_screen()
    print_header("Character Ascension Materials")

    # Check current materials
    ascension_materials = user_data["materials"].get("Ascension Material", 0)
    exp_materials = user_data["materials"].get("Character EXP Material", 0)

    print_colored("Current Materials:", CYAN)
    print_colored(f"• Character EXP Materials: {exp_materials}", GREEN)
    print_colored(f"• Ascension Materials: {ascension_materials}", BLUE)

    print()
    print_colored("Material Usage:", CYAN)
    print_colored("• EXP Materials are used to level up characters", GREEN)
    print_colored("• Ascension Materials are used to increase a character's level cap", BLUE)

    print()
    print_colored("Ascension Level Caps:", YELLOW)
    for rarity, data in CHARACTER_RARITIES.items():
        max_level = data.get("max_level", 40)
        rarity_color = data.get("color", WHITE)

        max_ascension = {
            "Common": 2,
            "Uncommon": 3,
            "Rare": 4,
            "Epic": 5,
            "Legendary": 6
        }.get(rarity, 2)

        print_colored(f"• {rarity_color}{rarity}{ENDC} characters:", WHITE)
        print_colored(f"  - Base level cap: {max_level}", WHITE)

        for ascension in range(1, max_ascension + 1):
            new_cap = max_level + (ascension * 10)
            print_colored(f"  - Ascension {ascension}: Level cap {new_cap}", WHITE)

    print()
    print_colored("Ways to Obtain Materials:", CYAN)
    print_colored("• Daily login rewards", WHITE)
    print_colored("• Material farming at specific locations", WHITE)
    print_colored("• Weekend material bonuses", WHITE)

    wait_for_input()

def weapon_refinement() -> None:
    """Main weapon refinement menu to select weapons"""
    clear_screen()
    print_header("Weapon Refinement")

    # Check if user has weapons
    if "gacha" not in user_data or "weapons" not in user_data["gacha"] or not user_data["gacha"]["weapons"]:
        print_colored("You don't have any weapons to refine yet.", YELLOW)
        wait_for_input()
        return

    # Initialize weapon levels and refinement if not present
    if "weapon_levels" not in user_data["gacha"]:
        user_data["gacha"]["weapon_levels"] = {}

    if "weapon_refinements" not in user_data["gacha"]:
        user_data["gacha"]["weapon_refinements"] = {}

    # Initialize materials
    if "materials" not in user_data:
        user_data["materials"] = {
            "Weapon Enhancement Crystal": 50,  # Starting materials
            "Refinement Ore": 20
        }

    # Display owned weapons for selection
    weapons = user_data["gacha"]["weapons"]

    print_colored("Select a weapon to enhance or refine:", WHITE)
    for i, weapon_name in enumerate(weapons, 1):
        weapon_data = CHARACTER_WEAPONS.get(weapon_name, {})
        if not weapon_data:
            continue

        weapon_rarity = weapon_data.get("rarity", "Common")
        weapon_type = weapon_data.get("type", "Unknown")

        # Get current level and refinement
        weapon_level = user_data["gacha"]["weapon_levels"].get(weapon_name, 1)
        weapon_refinement = user_data["gacha"]["weapon_refinements"].get(weapon_name, 1)

        # Get maximum level based on rarity
        max_level = WEAPON_RARITIES.get(weapon_rarity, {}).get("max_level", 20)
        max_refinement = WEAPON_RARITIES.get(weapon_rarity, {}).get("max_refinement", 5)

        # For display: calculate color based on refinement level
        if weapon_refinement >= max_refinement:
            refinement_color = YELLOW
        elif weapon_refinement >= 3:
            refinement_color = GREEN
        else:
            refinement_color = WHITE

        rarity_color = WEAPON_RARITIES.get(weapon_rarity, {}).get("color", WHITE)

        # Show if equipped by character
        equipped_by = ""
        if "equipped_weapons" in user_data["gacha"]:
            for char, char_weapon in user_data["gacha"]["equipped_weapons"].items():
                if char_weapon == weapon_name:
                    equipped_by = f" (Equipped by {char})"
                    break

        print_colored(f"{i}. {rarity_color}{weapon_name}{ENDC} - {weapon_type} - Lv.{weapon_level}/{max_level} - {refinement_color}R{weapon_refinement}{ENDC}{equipped_by}", WHITE)

    print_colored(f"{len(weapons)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Select a weapon (1-{len(weapons)+1}): {ENDC}"))

        if choice == len(weapons)+1:
            return

        if 1 <= choice <= len(weapons):
            selected_weapon = weapons[choice-1]
            refine_weapon_menu(selected_weapon)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()
    # Avoid recursion, just return to previous menu
    return

def refine_weapon_menu(weapon_name: str) -> None:
    """Menu for enhancing and refining a specific weapon"""
    while True:
        clear_screen()

        weapon_data = CHARACTER_WEAPONS.get(weapon_name, {})
        weapon_rarity = weapon_data.get("rarity", "Common")
        weapon_type = weapon_data.get("type", "Unknown")

        # Get current level and refinement
        weapon_level = user_data["gacha"]["weapon_levels"].get(weapon_name, 1)
        weapon_refinement = user_data["gacha"]["weapon_refinements"].get(weapon_name, 1)

        # Get maximum level based on rarity
        max_level = WEAPON_RARITIES.get(weapon_rarity, {}).get("max_level", 20)
        max_refinement = WEAPON_RARITIES.get(weapon_rarity, {}).get("max_refinement", 5)

        # Materials owned
        enhancement_crystals = user_data["materials"].get("Weapon Enhancement Crystal", 0)
        refinement_ores = user_data["materials"].get("Refinement Ore", 0)

        # Header with weapon info
        print_header(f"Weapon: {weapon_name}")

        rarity_color = WEAPON_RARITIES.get(weapon_rarity, {}).get("color", WHITE)

        print_colored(f"Rarity: {rarity_color}{weapon_rarity}{ENDC} ({rarity_color}{'★' * WEAPON_RARITIES.get(weapon_rarity, {}).get('stars', 1)}{ENDC})", WHITE)
        print_colored(f"Type: {weapon_type}", WHITE)
        print_colored(f"Level: {weapon_level}/{max_level}", CYAN)
        print_colored(f"Refinement: {weapon_refinement}/{max_refinement}", YELLOW)

        # Display weapon stats
        base_attack = weapon_data.get("base_attack", 0)
        current_attack = base_attack + (weapon_level * 2)  # Simple formula for attack growth

        print_colored(f"Base ATK: {current_attack}", GREEN)

        # Special effect with refinement bonus
        special_effect = weapon_data.get("special_effect", "None")
        if special_effect != "None":
            refinement_bonus = (weapon_refinement - 1) * 0.1  # 10% increase per refinement rank
            print_colored(f"Special Effect: {special_effect}", CYAN)
            if refinement_bonus > 0:
                print_colored(f"Refinement Bonus: +{int(refinement_bonus*100)}% effect strength", YELLOW)

        print()
        print_colored(f"Enhancement Crystals: {enhancement_crystals}", GREEN)
        print_colored(f"Refinement Ores: {refinement_ores}", BLUE)

        print()
        print_colored("1. Enhance Weapon (Level Up)", WHITE)
        print_colored("2. Refine Weapon (Increase Refinement Rank)", WHITE)
        print_colored("3. View Enhancement Materials", WHITE)
        print_colored("4. Back", RED)

        try:
            choice = int(input(f"\n{YELLOW}Choose an option (1-4): {ENDC}"))

            if choice == 1:
                enhance_weapon(weapon_name)
            elif choice == 2:
                refine_weapon(weapon_name)
            elif choice == 3:
                view_weapon_materials()
            elif choice == 4:
                return
            else:
                print_colored("Invalid choice.", RED)
                wait_for_input()
        except ValueError:
            print_colored("Please enter a number.", RED)
            wait_for_input()

def enhance_weapon(weapon_name: str) -> None:
    """Level up a weapon using Enhancement Crystals"""
    clear_screen()

    weapon_data = CHARACTER_WEAPONS.get(weapon_name, {})
    weapon_rarity = weapon_data.get("rarity", "Common")

    # Get current level
    weapon_level = user_data["gacha"]["weapon_levels"].get(weapon_name, 1)

    # Get maximum level based on rarity
    max_level = WEAPON_RARITIES.get(weapon_rarity, {}).get("max_level", 20)

    # Check if weapon is already at max level
    if weapon_level >= max_level:
        print_colored(f"{weapon_name} is already at the maximum level ({max_level}).", YELLOW)
        wait_for_input()
        return

    # Materials owned
    enhancement_crystals = user_data["materials"].get("Weapon Enhancement Crystal", 0)

    # EXP per crystal based on weapon rarity
    exp_per_crystal = {
        "Common": 100,
        "Uncommon": 120,
        "Rare": 150,
        "Epic": 200,
        "Legendary": 250
    }.get(weapon_rarity, 100)

    # Calculate EXP needed per level
    exp_needed_per_level = {
        "Common": 50,
        "Uncommon": 100,
        "Rare": 150,
        "Epic": 200,
        "Legendary": 250
    }.get(weapon_rarity, 100)

    # Calculate EXP needed to reach max level
    total_exp_needed = 0
    for level in range(weapon_level, max_level):
        # EXP increases with level
        level_exp = exp_needed_per_level + (level * 10)
        total_exp_needed += level_exp

    # Calculate how many crystals needed
    crystals_needed = math.ceil(total_exp_needed / exp_per_crystal)

    # Display info
    print_header(f"Enhance {weapon_name}")
    print_colored(f"Current Level: {weapon_level}/{max_level}", CYAN)
    print_colored(f"Enhancement Crystals available: {enhancement_crystals}", GREEN)
    print_colored(f"Crystals needed to reach max level: {crystals_needed}", YELLOW)
    print_colored(f"EXP per crystal: {exp_per_crystal}", BLUE)

    print()
    print_colored("How many crystals would you like to use?", WHITE)
    print_colored("1. Use just enough to level up once", WHITE)
    print_colored("2. Use all crystals needed to reach max level", WHITE)
    print_colored("3. Use custom amount", WHITE)
    print_colored("4. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-4): {ENDC}"))

        if choice == 1:
            # Level up once
            exp_for_one_level = exp_needed_per_level + (weapon_level * 10)
            crystals_for_one = math.ceil(exp_for_one_level / exp_per_crystal)

            if enhancement_crystals >= crystals_for_one:
                user_data["materials"]["Weapon Enhancement Crystal"] -= crystals_for_one
                user_data["gacha"]["weapon_levels"][weapon_name] = weapon_level + 1
                print_colored(f"{weapon_name} enhanced to Level {weapon_level + 1}!", GREEN)
            else:
                print_colored(f"Not enough crystals. Need {crystals_for_one}, have {enhancement_crystals}.", RED)

        elif choice == 2:
            # Max level
            if enhancement_crystals >= crystals_needed:
                user_data["materials"]["Weapon Enhancement Crystal"] -= crystals_needed
                user_data["gacha"]["weapon_levels"][weapon_name] = max_level
                print_colored(f"{weapon_name} enhanced to maximum Level {max_level}!", GREEN)
            else:
                # Use what we can
                levels_gained = 0
                crystals_used = 0
                new_level = weapon_level

                while crystals_used < enhancement_crystals and new_level < max_level:
                    level_exp = exp_needed_per_level + (new_level * 10)
                    crystals_for_level = math.ceil(level_exp / exp_per_crystal)

                    if crystals_used + crystals_for_level <= enhancement_crystals:
                        crystals_used += crystals_for_level
                        new_level += 1
                        levels_gained += 1
                    else:
                        break

                if levels_gained > 0:
                    user_data["materials"]["Weapon Enhancement Crystal"] -= crystals_used
                    user_data["gacha"]["weapon_levels"][weapon_name] = new_level
                    print_colored(f"{weapon_name} enhanced to Level {new_level}! (+{levels_gained} levels)", GREEN)
                else:
                    print_colored(f"Not enough crystals. Need at least {crystals_needed - enhancement_crystals} more.", RED)

        elif choice == 3:
            # Custom amount
            max_usable = min(enhancement_crystals, crystals_needed)
            try:
                amount = int(input(f"\n{YELLOW}Enter amount to use (1-{max_usable}): {ENDC}"))

                if 1 <= amount <= max_usable:
                    # Calculate levels gained
                    exp_gained = amount * exp_per_crystal
                    levels_gained = 0
                    total_exp_used = 0
                    new_level = weapon_level

                    while total_exp_used < exp_gained and new_level < max_level:
                        level_exp = exp_needed_per_level + (new_level * 10)

                        if total_exp_used + level_exp <= exp_gained:
                            total_exp_used += level_exp
                            new_level += 1
                            levels_gained += 1
                        else:
                            break

                    if levels_gained > 0:
                        user_data["materials"]["Weapon Enhancement Crystal"] -= amount
                        user_data["gacha"]["weapon_levels"][weapon_name] = new_level
                        print_colored(f"{weapon_name} enhanced to Level {new_level}! (+{levels_gained} levels)", GREEN)
                    else:
                        print_colored("Not enough crystals to gain a level.", RED)
                else:
                    print_colored("Invalid amount.", RED)
            except ValueError:
                print_colored("Please enter a valid number.", RED)

        elif choice == 4:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def refine_weapon(weapon_name: str) -> None:
    """Refine a weapon to increase its special effect strength"""
    clear_screen()

    weapon_data = CHARACTER_WEAPONS.get(weapon_name, {})
    weapon_rarity = weapon_data.get("rarity", "Common")

    # Get current refinement
    weapon_refinement = user_data["gacha"]["weapon_refinements"].get(weapon_name, 1)

    # Get maximum refinement based on rarity
    max_refinement = WEAPON_RARITIES.get(weapon_rarity, {}).get("max_refinement", 5)

    # Check if weapon is already at max refinement
    if weapon_refinement >= max_refinement:
        print_colored(f"{weapon_name} is already at maximum refinement rank (R{max_refinement}).", YELLOW)
        wait_for_input()
        return

    # Get special effect
    special_effect = weapon_data.get("special_effect", "None")

    # Materials owned
    refinement_ores = user_data["materials"].get("Refinement Ore", 0)

    # Ores required based on rarity and current refinement
    base_ores_needed = {
        "Common": 2,
        "Uncommon": 3,
        "Rare": 5,
        "Epic": 7,
        "Legendary": 10
    }.get(weapon_rarity, 3)

    # Ore requirement increases with refinement level
    ores_needed = base_ores_needed + ((weapon_refinement - 1) * 2)

    # Display info
    print_header(f"Refine {weapon_name}")
    print_colored(f"Current Refinement: R{weapon_refinement}/{max_refinement}", CYAN)
    print_colored(f"Refinement Ores available: {refinement_ores}", GREEN)
    print_colored(f"Ores needed for next refinement: {ores_needed}", YELLOW)

    if special_effect != "None":
        current_bonus = (weapon_refinement - 1) * 0.1  # 10% increase per refinement rank
        next_bonus = weapon_refinement * 0.1

        print()
        print_colored("Special Effect:", MAGENTA)
        print_colored(f"  {special_effect}", CYAN)
        print_colored(f"Current Bonus: +{int(current_bonus*100)}% effect strength", YELLOW)
        print_colored(f"Next Rank Bonus: +{int(next_bonus*100)}% effect strength", GREEN)
    else:
        print_colored("This weapon has no special effect to enhance.", YELLOW)

    print()
    print_colored("1. Refine Weapon", WHITE)
    print_colored("2. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-2): {ENDC}"))

        if choice == 1:
            if refinement_ores >= ores_needed:
                user_data["materials"]["Refinement Ore"] -= ores_needed
                user_data["gacha"]["weapon_refinements"][weapon_name] = weapon_refinement + 1
                print_colored(f"{weapon_name} refined to Rank {weapon_refinement + 1}!", GREEN)

                if special_effect != "None":
                    new_bonus = weapon_refinement * 0.1
                    print_colored(f"Special effect strength increased to +{int(new_bonus*100)}%!", YELLOW)
            else:
                print_colored(f"Not enough Refinement Ores. Need {ores_needed}, have {refinement_ores}.", RED)
        elif choice == 2:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def material_farming_locations() -> None:
    """Display available locations for farming character and weapon materials"""
    clear_screen()
    print_header("Material Farming Locations")

    # Define material locations
    material_locations = {
        "Character EXP Material": {
            "Ancient Ruins": "Common drops from ruins guardians. (20% drop chance)",
            "Temple": "Abundant in sacred shrines. (30% drop chance)",
            "Crystal Cave": "Found in crystal formations. (25% drop chance)",
            "Greenwood Village": "Sold by village merchants for 100 gold each."
        },
        "Weapon Enhancement Crystal": {
            "Mountain": "Mined from mountain veins. (25% drop chance)",
            "Cave": "Common in deep caverns. (30% drop chance)",
            "Ancient Ruins": "Ancient forge remnants. (20% drop chance)",
            "Stormhaven": "Sold by blacksmiths for 120 gold each."
        },
        "Refinement Ore": {
            "Crystal Cave": "Rare crystal formations. (15% drop chance)",
            "Mountain": "Special mountain peak deposits. (10% drop chance)",
            "Temple": "Sacred forging materials. (12% drop chance)",
            "Shadowmere": "Sold by mystical vendors for 300 gold each."
        },
        "Ascension Material": {
            "Ancient Ruins": "Ancient power sources. (15% drop chance)",
            "Temple": "Blessed offerings. (20% drop chance)",
            "Dragon's Peak": "Dragon scales and essence. (10% drop chance)",
            "Shadowmere": "Sold by dark market dealers for 500 gold each."
        }
    }

    # Display available materials and their locations
    print_colored("Material Farming Guide", CYAN)
    print_colored("Visit these locations to gather materials for enhancing characters and weapons:", WHITE)
    print()

    for material, locations in material_locations.items():
        # Choose color based on material type
        if "Character" in material:
            material_color = GREEN
        elif "Weapon" in material:
            material_color = BLUE
        elif "Refinement" in material:
            material_color = YELLOW
        else:
            material_color = MAGENTA

        print_colored(f"{material_color}{material}:{ENDC}", BOLD)

        for location, description in locations.items():
            # Colorize location names
            if "Ancient" in location or "Temple" in location:
                location_color = YELLOW
            elif "Mountain" in location or "Cave" in location:
                location_color = CYAN
            elif "Village" in location or "haven" in location:
                location_color = GREEN
            else:
                location_color = PURPLE

            print_colored(f"  • {location_color}{location}{ENDC}: {description}", WHITE)

        print()

    # Expedition feature teaser
    print_colored("Material Expeditions (Coming Soon)", CYAN + BOLD)
    print_colored("Send your characters on expeditions to automatically gather materials over time!", YELLOW)
    print_colored("Higher level characters will gather materials more efficiently.", WHITE)

    # Daily material rotation info
    print_colored("\nDaily Material Rotation:", CYAN + BOLD)

    # Use current day to determine available materials (pseudo-random based on day)
    current_day = datetime.now().weekday()
    days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    day_name = days[current_day]

    daily_rotations = {
        0: {"material": "Character EXP Material", "location": "Temple"},
        1: {"material": "Weapon Enhancement Crystal", "location": "Cave"},
        2: {"material": "Refinement Ore", "location": "Crystal Cave"},
        3: {"material": "Character EXP Material", "location": "Ancient Ruins"},
        4: {"material": "Weapon Enhancement Crystal", "location": "Mountain"},
        5: {"material": "All Materials", "location": "All Locations (Weekend Bonus)"},
        6: {"material": "All Materials", "location": "All Locations (Weekend Bonus)"}
    }

    today_rotation = daily_rotations.get(current_day, {})
    print_colored(f"Today ({day_name}): {today_rotation.get('material', 'No bonus')} - Increased drop rate in {today_rotation.get('location', 'No location')}", GREEN)

    # If it's not weekend, show next rotation
    if current_day < 5:
        next_day = (current_day + 1) % 7
        next_rotation = daily_rotations.get(next_day, {})
        print_colored(f"Tomorrow ({days[next_day]}): {next_rotation.get('material', 'No bonus')} - Increased drop rate in {next_rotation.get('location', 'No location')}", YELLOW)

    wait_for_input()

def ascend_character_menu(character_name: str) -> None:
    """Menu for leveling up and ascending a specific character"""
    while True:
        clear_screen()

        char_data = GACHA_CHARACTERS.get(character_name, {})
        char_rarity = char_data.get("rarity", "Common")
        char_element = char_data.get("element", "None")

        # Get current level and ascension
        char_level = user_data["gacha"]["character_levels"].get(character_name, 1)
        char_ascension = user_data["gacha"]["character_ascensions"].get(character_name, 0)

        # Get maximum level based on rarity and ascension
        max_base_level = CHARACTER_RARITIES.get(char_rarity, {}).get("max_level", 40)
        max_level = max_base_level + (char_ascension * 10)

        # Get max possible ascension based on rarity
        max_ascension = {
            "Common": 2,
            "Uncommon": 3,
            "Rare": 4,
            "Epic": 5,
            "Legendary": 6
        }.get(char_rarity, 2)

        # Materials owned
        exp_materials = user_data["materials"].get("Character EXP Material", 0)
        ascension_materials = user_data["materials"].get("Ascension Material", 0)

        # Header with character info
        print_header(f"Character: {character_name}")

        rarity_color = CHARACTER_RARITIES.get(char_rarity, {}).get("color", WHITE)
        element_color = CHARACTER_ELEMENTS.get(char_element, WHITE)

        print_colored(f"Rarity: {rarity_color}{char_rarity}{ENDC} ({rarity_color}{'★' * CHARACTER_RARITIES.get(char_rarity, {}).get('stars', 1)}{ENDC})", WHITE)
        print_colored(f"Element: {element_color}{char_element}{ENDC}", WHITE)
        print_colored(f"Level: {char_level}/{max_level}", CYAN)
        print_colored(f"Ascension: {char_ascension}/{max_ascension}", PURPLE)

        print()
        print_colored(f"EXP Materials: {exp_materials}", GREEN)
        print_colored(f"Ascension Materials: {ascension_materials}", BLUE)

        print()
        print_colored("1. Level Up Character", WHITE)
        print_colored("2. Ascend Character", WHITE)
        print_colored("3. View Ascension Materials", WHITE)
        print_colored("4. Back", RED)

        try:
            choice = int(input(f"\n{YELLOW}Choose an option (1-4): {ENDC}"))

            if choice == 1:
                level_up_character(character_name)
            elif choice == 2:
                ascend_character(character_name)
            elif choice == 3:
                view_ascension_materials()
            elif choice == 4:
                return
            else:
                print_colored("Invalid choice.", RED)
                wait_for_input()
        except ValueError:
            print_colored("Please enter a number.", RED)
            wait_for_input()

def level_up_character(character_name: str) -> None:
    """Level up a character using EXP materials"""
    clear_screen()

    char_data = GACHA_CHARACTERS.get(character_name, {})
    char_rarity = char_data.get("rarity", "Common")

    # Get current level and ascension
    char_level = user_data["gacha"]["character_levels"].get(character_name, 1)
    char_ascension = user_data["gacha"]["character_ascensions"].get(character_name, 0)

    # Get maximum level based on rarity and ascension
    max_base_level = CHARACTER_RARITIES.get(char_rarity, {}).get("max_level", 40)
    max_level = max_base_level + (char_ascension * 10)

    # Check if character is already at max level
    if char_level >= max_level:
        print_colored(f"{character_name} is already at the maximum level for current ascension.", YELLOW)
        print_colored(f"Ascend the character to increase the level cap beyond {max_level}.", CYAN)
        wait_for_input()
        return

    # Materials owned
    exp_materials = user_data["materials"].get("Character EXP Material", 0)

    # EXP per material based on character rarity
    exp_per_material = {
        "Common": 1000,
        "Uncommon": 1200,
        "Rare": 1500,
        "Epic": 2000,
        "Legendary": 2500
    }.get(char_rarity, 1000)

    # Calculate EXP needed per level
    exp_needed_per_level = {
        "Common": 500,
        "Uncommon": 1000,
        "Rare": 1500,
        "Epic": 2000,
        "Legendary": 2500
    }.get(char_rarity, 1000)

    # Calculate EXP needed to reach max level
    total_exp_needed = 0
    for level in range(char_level, max_level):
        # EXP increases with level
        level_exp = exp_needed_per_level + (level * 100)
        total_exp_needed += level_exp

    # Calculate how many materials needed
    materials_needed = math.ceil(total_exp_needed / exp_per_material)

    # Display info
    print_header(f"Level Up {character_name}")
    print_colored(f"Current Level: {char_level}/{max_level}", CYAN)
    print_colored(f"EXP Materials available: {exp_materials}", GREEN)
    print_colored(f"Materials needed to reach max level: {materials_needed}", YELLOW)
    print_colored(f"EXP per material: {exp_per_material}", BLUE)

    print()
    print_colored("How many materials would you like to use?", WHITE)
    print_colored("1. Use just enough to level up once", WHITE)
    print_colored("2. Use all materials needed to reach max level", WHITE)
    print_colored("3. Use custom amount", WHITE)
    print_colored("4. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-4): {ENDC}"))

        if choice == 1:
            # Level up once
            exp_for_one_level = exp_needed_per_level + (char_level * 100)
            materials_for_one = math.ceil(exp_for_one_level / exp_per_material)

            if exp_materials >= materials_for_one:
                user_data["materials"]["Character EXP Material"] -= materials_for_one
                user_data["gacha"]["character_levels"][character_name] = char_level + 1
                print_colored(f"{character_name} leveled up to {char_level + 1}!", GREEN)
            else:
                print_colored(f"Not enough materials. Need {materials_for_one}, have {exp_materials}.", RED)

        elif choice == 2:
            # Max level
            if exp_materials >= materials_needed:
                user_data["materials"]["Character EXP Material"] -= materials_needed
                user_data["gacha"]["character_levels"][character_name] = max_level
                print_colored(f"{character_name} leveled up to {max_level}!", GREEN)
            else:
                # Use what we can
                levels_gained = 0
                materials_used = 0
                new_level = char_level

                while materials_used < exp_materials and new_level < max_level:
                    level_exp = exp_needed_per_level + (new_level * 100)
                    materials_for_level = math.ceil(level_exp / exp_per_material)

                    if materials_used + materials_for_level <= exp_materials:
                        materials_used += materials_for_level
                        new_level += 1
                        levels_gained += 1
                    else:
                        break

                if levels_gained > 0:
                    user_data["materials"]["Character EXP Material"] -= materials_used
                    user_data["gacha"]["character_levels"][character_name] = new_level
                    print_colored(f"{character_name} leveled up to {new_level}! (+{levels_gained} levels)", GREEN)
                else:
                    print_colored(f"Not enough materials. Need at least {materials_needed - exp_materials} more.", RED)

        elif choice == 3:
            # Custom amount
            max_usable = min(exp_materials, materials_needed)
            try:
                amount = int(input(f"\n{YELLOW}Enter amount to use (1-{max_usable}): {ENDC}"))

                if 1 <= amount <= max_usable:
                    # Calculate levels gained
                    exp_gained = amount * exp_per_material
                    levels_gained = 0
                    total_exp_used = 0
                    new_level = char_level

                    while total_exp_used < exp_gained and new_level < max_level:
                        level_exp = exp_needed_per_level + (new_level * 100)

                        if total_exp_used + level_exp <= exp_gained:
                            total_exp_used += level_exp
                            new_level += 1
                            levels_gained += 1
                        else:
                            break

                    if levels_gained > 0:
                        user_data["materials"]["Character EXP Material"] -= amount
                        user_data["gacha"]["character_levels"][character_name] = new_level
                        print_colored(f"{character_name} leveled up to {new_level}! (+{levels_gained} levels)", GREEN)
                    else:
                        print_colored("Not enough materials to gain a level.", RED)
                else:
                    print_colored("Invalid amount.", RED)
            except ValueError:
                print_colored("Please enter a valid number.", RED)

        elif choice == 4:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def view_party_synergy() -> None:
    """View the active party composition and synergy effects"""
    clear_screen()
    print_header("Party Synergy")

    # Check if user has gacha data
    if "gacha" not in user_data:
        print_colored("You haven't obtained any characters yet.", YELLOW)
        wait_for_input()
        return

    current_party = user_data["gacha"]["current_party"]
    if not current_party:
        print_colored("Your party is empty. Add characters to your party to see synergy effects.", YELLOW)
        wait_for_input()
        return

    # Display current party
    print_colored("Active Party:", BLUE + BOLD)
    element_count = {}

    for i, char_name in enumerate(current_party, 1):
        char_data = GACHA_CHARACTERS.get(char_name, {})
        rarity = char_data.get("rarity", "Common")
        element = char_data.get("element", "None")
        char_level = user_data["gacha"].get("character_levels", {}).get(char_name, 1)
        memory_level = user_data["gacha"]["memory_shards"].get(char_name, 0)

        # Count elements for resonance effects
        if element not in element_count:
            element_count[element] = 0
        element_count[element] += 1

        rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)
        element_color = CHARACTER_ELEMENTS.get(element, WHITE)

        # Get character's equipped weapon
        equipped_weapon = "None"
        if "equipped_weapons" in user_data["gacha"] and char_name in user_data["gacha"]["equipped_weapons"]:
            equipped_weapon = user_data["gacha"]["equipped_weapons"][char_name]

        print_colored(f"{i}. {rarity_color}{char_name}{ENDC} - {element_color}{element}{ENDC} - Lv.{char_level} - Memory Shards: {memory_level}/6", WHITE)
        print_colored(f"   Weapon: {equipped_weapon}", LIGHTGRAY)

    print()

    # Show element resonance
    print_colored("Element Resonance:", CYAN + BOLD)
    has_resonance = False

    for element, count in element_count.items():
        element_color = CHARACTER_ELEMENTS.get(element, WHITE)

        if count >= 2:
            has_resonance = True
            print_colored(f"{element_color}{element} Resonance{ENDC} ({count} characters)", WHITE)

            # Show element-specific resonance effects
            if element == "Fire":
                print_colored("  • +15% Fire damage", LIGHTYELLOW)
                print_colored("  • +10% ATK for all party members", LIGHTYELLOW)
            elif element == "Water":
                print_colored("  • +15% Water resistance", LIGHTBLUE)
                print_colored("  • +15% healing effectiveness", LIGHTBLUE)
            elif element == "Earth":
                print_colored("  • +20% physical defense", YELLOW)
                print_colored("  • -15% damage from critical hits", YELLOW)
            elif element == "Air":
                print_colored("  • +10% movement speed", LIGHTCYAN)
                print_colored("  • +10% evasion chance", LIGHTCYAN)
            elif element == "Lightning":
                print_colored("  • +10% critical hit chance", MAGENTA)
                print_colored("  • +15% critical hit damage", MAGENTA)
            elif element == "Ice":
                print_colored("  • +15% chance to freeze enemies", CYAN)
                print_colored("  • +20% duration of freeze effects", CYAN)
            elif element == "Light":
                print_colored("  • +15% healing effectiveness", WHITE)
                print_colored("  • +10% elemental resistance", WHITE)
            elif element == "Dark":
                print_colored("  • +15% damage against elite enemies", LIGHTGRAY)
                print_colored("  • +25% effect duration for debuffs", LIGHTGRAY)
            elif element == "Nature":
                print_colored("  • Regenerate 2% health per minute", GREEN)
                print_colored("  • +20% effectiveness for healing items", GREEN)
            elif element == "Arcane":
                print_colored("  • +15% to all elemental damage", LIGHTMAGENTA)
                print_colored("  • +10% elemental reaction damage", LIGHTMAGENTA)

    if not has_resonance:
        print_colored("No element resonance active. You need at least 2 characters of the same element.", YELLOW)

    wait_for_input()

def equip_character_weapon(character_name: str) -> None:
    """Allow equipping a specific weapon to a character"""
    clear_screen()
    print_header(f"Equip Weapon for {character_name}")

    # Get character data
    char_data = GACHA_CHARACTERS.get(character_name, {})
    if not char_data:
        print_colored(f"Character {character_name} not found.", RED)
        wait_for_input()
        return

    # Find character's preferred weapon
    character_weapon = None
    for weapon_name, weapon_data in CHARACTER_WEAPONS.items():
        if weapon_data.get("for_character") == character_name:
            character_weapon = {"name": weapon_name, "data": weapon_data}
            break

    if not character_weapon:
        print_colored(f"No specific weapon found for {character_name}.", YELLOW)
        wait_for_input()
        return

    # Show weapon details
    weapon_name = character_weapon["name"]
    weapon_data = character_weapon["data"]

    rarity = weapon_data.get("rarity", "Common")
    rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)

    print_colored(f"Weapon: {rarity_color}{weapon_name}{ENDC}", WHITE)
    print_colored(f"Type: {weapon_data.get('type', 'Unknown')}", WHITE)
    print_colored(f"Element: {weapon_data.get('element', 'None')}", CHARACTER_ELEMENTS.get(weapon_data.get('element', 'None'), WHITE))
    print_colored(f"Attack: {weapon_data.get('base_attack', 0)}", WHITE)
    print_colored(f"Special Effect: {weapon_data.get('special_effect', 'None')}", CYAN)
    print_colored(f"Description: {weapon_data.get('description', '')}", LIGHTGRAY)

    print()

    # Check if user has the weapon or materials to craft it
    has_weapon = False
    if "character_weapons" not in user_data:
        user_data["character_weapons"] = {}

    if character_name in user_data["character_weapons"]:
        has_weapon = True
        print_colored("You already have this weapon equipped.", GREEN)
    else:
        print_colored("You don't have this weapon yet.", YELLOW)
        print_colored("Let's craft it for your character!", CYAN)

        # For simplicity, just give them the weapon without requiring materials
        # In a real implementation, this would check crafting requirements
        user_data["character_weapons"][character_name] = {
            "name": weapon_name,
            "level": 1,
            "refinement": 0,
            "element": weapon_data.get("element", "None"),
            "base_attack": weapon_data.get("base_attack", 0)
        }
        has_weapon = True
        print_colored(f"You crafted {rarity_color}{weapon_name}{ENDC}!", GREEN)

    if has_weapon:
        print_colored(f"Character {character_name} will now use {weapon_name} in battle!", GREEN)

        # Update character's weapon reference
        if "equipped_weapons" not in user_data["gacha"]:
            user_data["gacha"]["equipped_weapons"] = {}

        user_data["gacha"]["equipped_weapons"][character_name] = weapon_name

    wait_for_input()

# Integrate Stellarstones with quests and battles
def give_stellarstones(amount: int, reason: str = "") -> None:
    """
    Award the player Stellarstones with a notification

    Args:
        amount: Amount of Stellarstones to give
        reason: Optional reason for receiving the stones
    """
    if "gacha" not in user_data:
        user_data["gacha"] = {
            "characters": [],
            "memory_shards": {},
            "pity_counter": 0,
            "pity_counter_4star": 0,
            "current_party": [],
            "standard_pulls": 0,
            "limited_pulls": 0,
            "stellarstones": 1600,
            "memory_dust": 0,
            "last_daily_check": None
        }

    user_data["gacha"]["stellarstones"] += amount

    # Display notification
    message = f"Received {amount} Stellarstones"
    if reason:
        message += f" for {reason}"

    print_colored(message + "!", CYAN)

    # Show current total
    total = user_data["gacha"]["stellarstones"]
    print_colored(f"Total Stellarstones: {total}", LIGHTGRAY)

def hook_battle_reward(monster_level: int) -> None:
    """Award Stellarstones after defeating a monster based on its level"""
    # Base reward for defeating a monster
    base_amount = 5

    # Bonus based on monster level (higher level = more stones)
    level_bonus = monster_level * 2

    # Random bonus (1-10 additional stones)
    random_bonus = random.randint(1, 10)

    # Calculate total reward
    total_reward = base_amount + level_bonus + random_bonus

    # Award the stones
    give_stellarstones(total_reward, "monster defeat")

def hook_quest_reward(quest_difficulty: str) -> None:
    """Award Stellarstones after completing a quest based on difficulty"""
    # Reward amounts based on quest difficulty
    difficulty_rewards = {
        "Easy": 50,
        "Medium": 100,
        "Hard": 200,
        "Very Hard": 350,
        "Legendary": 500
    }

    # Get reward amount based on difficulty (default to 25 if difficulty not found)
    reward_amount = difficulty_rewards.get(quest_difficulty, 25)

    # Award the stones
    give_stellarstones(reward_amount, f"completing a {quest_difficulty} quest")

# Complete rewritten function to replace duplicate implementations

def manage_party() -> None:
    """Manage active character party"""
    clear_screen()
    print_header("Party Management")

    characters = user_data["gacha"]["characters"]
    if not characters:
        print_colored("You haven't obtained any characters yet.", YELLOW)
        wait_for_input()
        return

    current_party = user_data["gacha"]["current_party"]

    # Display current party
    print_colored("Current Party:", BLUE + BOLD)
    if current_party:
        for i, char_name in enumerate(current_party, 1):
            char_data = GACHA_CHARACTERS.get(char_name, {})
            rarity = char_data.get("rarity", "Common")
            element = char_data.get("element", "None")

            rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)
            element_color = CHARACTER_ELEMENTS.get(element, WHITE)

            print_colored(f"  {i}. {rarity_color}{char_name}{ENDC} - {element_color}{element}{ENDC}", WHITE)
    else:
        print_colored("  No characters in party", YELLOW)

    print()
    print_colored("Choose an action:", CYAN)
    print_colored("1. Add Character to Party", WHITE)
    print_colored("2. Remove Character from Party", WHITE)
    print_colored("3. Clear Party", WHITE)
    print_colored("4. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an option (1-4): {ENDC}"))

        if choice == 1:
            add_character_to_party()
        elif choice == 2:
            remove_character_from_party()
        elif choice == 3:
            user_data["gacha"]["current_party"] = []
            print_colored("Party cleared.", GREEN)
        elif choice == 4:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()

def add_character_to_party() -> None:
    """Add a character to the active party"""
    clear_screen()
    print_header("Add Character to Party")

    current_party = user_data["gacha"]["current_party"]
    characters = user_data["gacha"]["characters"]

    # Check if party is full
    if len(current_party) >= 4:
        print_colored("Your party is full! Remove a character first.", RED)
        wait_for_input()
        return

    # Display available characters not in party
    available_chars = [char for char in characters if char not in current_party]

    if not available_chars:
        print_colored("All your characters are already in the party!", YELLOW)
        wait_for_input()
        return

    for i, char_name in enumerate(available_chars, 1):
        char_data = GACHA_CHARACTERS.get(char_name, {})
        rarity = char_data.get("rarity", "Common")
        element = char_data.get("element", "")

        rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)
        element_color = CHARACTER_ELEMENTS.get(element, WHITE)

        print_colored(f"{i}. {rarity_color}{char_name}{ENDC} - {element_color}{element}{ENDC}", WHITE)

    print_colored(f"{len(available_chars)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Select a character to add (1-{len(available_chars)+1}): {ENDC}"))

        if choice == len(available_chars)+1:
            return

        if 1 <= choice <= len(available_chars):
            selected_char = available_chars[choice-1]
            user_data["gacha"]["current_party"].append(selected_char)
            print_colored(f"{selected_char} added to party!", GREEN)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

def remove_character_from_party() -> None:
    """Remove a character from the active party"""
    clear_screen()
    print_header("Remove Character from Party")

    current_party = user_data["gacha"]["current_party"]

    if not current_party:
        print_colored("There are no characters in your party!", YELLOW)
        wait_for_input()
        return

    for i, char_name in enumerate(current_party, 1):
        char_data = GACHA_CHARACTERS.get(char_name, {})
        rarity = char_data.get("rarity", "Common")
        element = char_data.get("element", "")

        rarity_color = CHARACTER_RARITIES.get(rarity, {}).get("color", WHITE)
        element_color = CHARACTER_ELEMENTS.get(element, WHITE)

        print_colored(f"{i}. {rarity_color}{char_name}{ENDC} - {element_color}{element}{ENDC}", WHITE)

    print_colored(f"{len(current_party)+1}. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Select a character to remove (1-{len(current_party)+1}): {ENDC}"))

        if choice == len(current_party)+1:
            return

        if 1 <= choice <= len(current_party):
            removed_char = current_party.pop(choice-1)
            print_colored(f"{removed_char} removed from party!", GREEN)
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

def gacha_shop() -> None:
    """Shop for gacha-related items"""
    clear_screen()
    print_header("Wish Shop")

    primogems = user_data["gacha"]["primogems"]
    stardust = user_data["gacha"]["stardust"]

    print_colored(f"Your Primogems: {primogems}", CYAN)
    print_colored(f"Your Stardust: {stardust}", BLUE)
    print()

    print_colored("Available Items:", YELLOW)
    print_colored("1. 60 Primogems (100 Gold)", WHITE)
    print_colored("2. 300 Primogems (500 Gold)", WHITE)
    print_colored("3. 1 Wish (160 Primogems)", WHITE)
    print_colored("4. Character Enhancement Material (50 Stardust)", WHITE)
    print_colored("5. Back", RED)

    try:
        choice = int(input(f"\n{YELLOW}Choose an item to purchase (1-5): {ENDC}"))

        if choice == 1:
            if user_data["gold"] >= 100:
                user_data["gold"] -= 100
                user_data["gacha"]["primogems"] += 60
                print_colored("Purchased 60 Primogems!", GREEN)
            else:
                print_colored("Not enough Gold!", RED)
        elif choice == 2:
            if user_data["gold"] >= 500:
                user_data["gold"] -= 500
                user_data["gacha"]["primogems"] += 300
                print_colored("Purchased 300 Primogems!", GREEN)
            else:
                print_colored("Not enough Gold!", RED)
        elif choice == 3:
            if user_data["gacha"]["primogems"] >= 160:
                # Perform a wish
                user_data["gacha"]["primogems"] -= 160
                user_data["gacha"]["standard_pulls"] += 1
                print_colored("Performing a Standard Wish:", CYAN)
                pull_character("standard")
            else:
                print_colored("Not enough Primogems!", RED)
        elif choice == 4:
            if user_data["gacha"]["stardust"] >= 50:
                user_data["gacha"]["stardust"] -= 50
                # Give enhancement material (could be implemented fully in a future update)
                print_colored("Purchased Character Enhancement Material!", GREEN)
                print_colored("(This would be used to level up characters in a full implementation)", YELLOW)
            else:
                print_colored("Not enough Stardust!", RED)
        elif choice == 5:
            return
        else:
            print_colored("Invalid choice.", RED)
    except ValueError:
        print_colored("Please enter a number.", RED)

    wait_for_input()
    gacha_shop()

def create_character() -> None:
    if user_data["class"] is not None:
        print("You have already created a character!")
        return

    print_header("Character Creation")

    # Prompt for character name
    while True:
        name = input("Enter your character's name: ").strip()
        if name:
            user_data["name"] = name
            break
        else:
            print("Name cannot be empty. Please enter a valid name.")

    print("Choose your class:")
    for class_name in CHARACTER_CLASSES:
        print(f"[{class_name}]")
        for stat, value in CHARACTER_CLASSES[class_name].items():
            print(f"  {stat}: {value:+}")

    while True:
        choice = input("Enter class name: ").capitalize()
        if choice in CHARACTER_CLASSES:
            user_data["class"] = choice
            user_data["skills"] = SKILLS[choice]
            stats = CHARACTER_CLASSES[choice]
            user_data["max_health"] += stats["health_bonus"]
            user_data["health"] = user_data["max_health"]
            user_data["attack"] += stats["attack_bonus"]
            user_data["defense"] += stats["defense_bonus"]
            user_data["speed"] = stats.get("speed_bonus", 5)  # Default speed 5 if not set
            print(f"\nWelcome, {name} the {choice}! Your adventure begins...")
            break
        print("Invalid class. Try again.")

# Sample villages (added for completeness)
villages = [
    {"name": "Greenwood", "population": 150, "special_items": ["Herbal Potion", "Wooden Bow"]},
    {"name": "Stonehaven", "population": 200, "special_items": ["Iron Sword", "Shield"]},
    {"name": "Riverbend", "population": 120, "special_items": ["Fishing Rod", "Water Flask"]},
    {"name": "Snowpeak", "population": 80, "special_items": ["Warm Cloak", "Ice Pick"]},
    {"name": "Emberfall", "population": 100, "special_items": ["Firestarter", "Lava Stone"]},
    {"name": "Thundercliff", "population": 90, "special_items": ["Lightning Rod", "Storm Cloak"]},
    {"name": "Jade Lotus", "population": 110, "special_items": ["Lotus Blossom", "Jade Pendant"]},
    {"name": "Shogunate of Shirui", "population": 130, "special_items": ["Samurai Armor", "Katana"]},
    {"name": "Long Shui Zhen", "population": 140, "special_items": ["Dragon Scale", "Water Orb"]},
    {"name": "Dragon's Reach", "population": 95, "special_items": ["Dragon Claw", "Dragon Fang"]},
]

biomes = [
{
   "name":"Forest",
   "description":"A lush green area filled with trees and wildlife."
},
{
   "name":"Desert",
   "description":"A vast sandy area with scarce resources."
},
{
   "name":"Cave",
   "description":"A dark underground area with hidden treasures."
},
{
   "name":"Snowy Peaks",
   "description":"A cold mountainous region with snow-covered terrain."
},
{
    "name": "Lava River",
    "description": "A river of molten lava flowing through a rocky landscape."
},
{
    "name": "Plains",
    "description": "A flat, open area with grasslands and few trees."
},
{
   "name":"Swamp",
   "description":"A murky area filled with water and strange creatures."
},
{
   "name":"Ocean",
   "description":"A vast body of water with islands and sea monsters."
},
{
   "name":"Sky Islands",
   "description":"Floating islands high in the sky, accessible by air."
},
{
   "name":"Crystal Caverns",
   "description":"A cave filled with sparkling crystals and rare minerals."
},
{
    "name": "Mines",
    "description": "A network of tunnels and shafts, rich in minerals and ores."
},
{
    "name": "Temple",
    "description": "An ancient structure filled with traps and treasures."
},
{
    "name": "Desert Spring",
    "description": "A hidden refreshing big spring filled with water and strange creatures in depths of the hot desert."
},
{
    "name":"Ancient Ruins",
    "description":"Remnants of a long-lost civilization, filled with secrets and treasures."
},
{
   "name":"Jungle",
   "description":"A dense and tropical area filled with towering trees, exotic plants, and wild animals."
},
{
   "name":"Tundra",
   "description":"A cold, barren landscape with little vegetation, covered in permafrost and snow."
},
{
   "name":"Savannah",
   "description":"A vast grassy plain with scattered trees, home to many herds of animals."
},
{
   "name":"Fungal Forest",
   "description":"A damp, dark forest where giant fungi dominate the landscape instead of trees."
},
{
   "name":"Mountain Range",
   "description":"A towering series of mountains, often with dangerous cliffs and peaks, and home to hardy creatures."
},
{
   "name":"Rainforest",
   "description":"A hot, humid area with dense foliage, continuous rainfall, and diverse wildlife."
},
{
   "name":"Barren Wasteland",
   "description":"An empty, desolate region with little to no life, plagued by sandstorms and harsh winds."
},
{
   "name":"Underwater Ruins",
   "description":"Sunken cities and forgotten structures beneath the ocean, filled with ancient artifacts and dangers."
},
{
   "name":"Meadow",
   "description":"A peaceful, open field filled with colorful flowers, tall grasses, and peaceful wildlife."
},
{
   "name":"Mystic Forest",
   "description":"A magical forest filled with glowing plants, enchanted creatures, and hidden secrets."
},
{
   "name":"Twilight Grove",
   "description":"A mysterious forest where the sun never fully sets, creating a perpetual twilight with bioluminescent plants and glowing creatures."
},
{
   "name":"Corrupted Land",
   "description":"A dark and twisted environment where the very soil is tainted, giving rise to dangerous, mutated creatures and toxic flora."
},
{
   "name":"Icy Wastes",
   "description":"A barren, freezing expanse filled with endless ice fields, glaciers, and the occasional frozen lake hiding ancient secrets."
},
{
   "name":"Oasis",
   "description":"A rare, fertile area in the desert, featuring a small pool of water surrounded by palm trees and desert wildlife."
},
{
   "name":"Lush Highlands",
   "description":"A rolling green landscape with gentle hills, fertile soil, and peaceful wildlife, perfect for farming or settling."
},
{
   "name":"Boreal Forest",
   "description":"A cold and dense forest filled with evergreens and snow, inhabited by resilient wildlife adapted to the harsh conditions."
},
{
   "name":"Sunken Abyss",
   "description":"An underwater trench deep in the ocean, home to strange abyssal creatures and ancient, sunken ruins."
},
{
   "name":"Shroom Cavern",
   "description":"A vast underground network filled with towering mushrooms, glowing spores, and rare fungal lifeforms."
},
{
   "name":"Frostbitten Tundra",
   "description":"An arctic wasteland where the air is frozen, and snowstorms are a constant threat, with dangerous wildlife adapted to the extreme cold."
},
{
   "name":"Radiant Plains",
   "description":"A glowing meadow where flowers and grasses emit light, creating a serene and ethereal landscape filled with beauty and tranquility."
},
{
   "name":"Ashen Wastes",
   "description":"A scorched, desolate plain left behind by ancient fires, where the ground is cracked, and the air is thick with ash and smoke."
},
{
   "name":"Celestial Peaks",
   "description":"Towering mountain ranges that reach beyond the clouds, where the air is thin, and the environment is home to rare celestial beings."
},
{
   "name":"Mystic Marsh",
   "description":"A foggy and swampy area filled with enchanted waters, strange will-o'-the-wisps, and ancient trees with whispered secrets."
},
{
   "name":"Crystal Fields",
   "description":"Vast plains where the earth itself is covered with shimmering crystals, creating a dazzling landscape that’s both beautiful and treacherous."
},
{
   "name":"Vibrant Reef",
   "description":"A colorful underwater biome teeming with vibrant corals, exotic fish, and rare underwater plants, but also home to deadly sea predators."
},
{
   "name":"Sandstorm Flats",
   "description":"A vast desert landscape constantly ravaged by powerful sandstorms, leaving only remnants of ancient structures buried beneath the dunes."
},
{
   "name":"The Nether",
   "description":"A fiery, chaotic dimension filled with volcanic terrain, strange creatures, and hostile environments, with a constant threat of fire and lava."
},
{
   "name":"Skyward Cavern",
   "description":"A network of caves suspended in the sky, connected by floating platforms and filled with rare ores and aerial creatures."
},
{
    "name":"Volcano",
    "description":"A towering mountain with a fiery core, spewing lava and ash, home to fire elementals and rare minerals."
},
{
    "name":"Coast",
    "description":"A sandy beach area with gentle waves, palm trees, and hidden treasures along the shore."
},
{
    "name": "Cliffside",
    "description": "A steep rocky area overlooking the ocean, with hidden caves and dangerous cliffs."
},
{
    "name": "Deep Cave",
    "description": "A dark cave filled with hidden treasures and dangerous creatures."
},
{
    "name": "Dragon's Reach",
    "description": "A mountainous area rumored to once be home to the oldest original dragons,now left only with hidden caves and treasures."
},
{
    "name": "Dragon's peak",
    "description": "A high mountain peak where The great war of human rebellion occurred,where humans killed the last dragon king Frosthymir. Now said to be cursed from all the renmants of the diseased and hatred souls of the dragons who died in that war."
},
{
    "name": "Lotus Pond",
    "description": "A serene pond filled with beautiful lotus flowers, home to rare aquatic creatures and the Koi along with their empress."
},
{
    "name": "Abyssal Ravine",
    "description": "A deep underwater cavern filled with ancient ruins from people that used to inhabit here,with rare conditions met this place can create rare minerals"
},
{
    "name": "Ancient Forest Of Gradanvanka",
    "description": "A dense forest created by the Eternal Gradanvanka when the Eternals, a demigod that lives now in the sky, still walked among mortals in this world."
},
]

# Dismantle items function stub
def dismantle_items() -> None:
    print_header("Dismantling Items")
    print("Dismantling items feature is coming soon!")

# Inventory calculator function stub
def inventory_calculator() -> None:
    print_header("Inventory Calculator")
    print("Inventory calculator feature is coming soon!")

# Show drops function stub
def show_drops() -> None:
    print_header("Monster Drops")
    print("Monster drops feature is coming soon!")

# Show enchants function stub
def show_enchants() -> None:
    print_header("Enchantments")
    print("Enchantments feature is coming soon!")

# Time travel guide function
def time_travel_guide() -> None:
    print_header("Time Travel Guide")
    print("Select a location to travel back in time to:")

    locations = list(LOCATIONS.keys())
    for i, loc in enumerate(locations, 1):
        print(f"{i}. {loc} - {LOCATIONS[loc]['description']}")

    choice = input("\nEnter the number of the location to time travel to (or 0 to cancel): ")
    try:
        choice = int(choice)
        if choice == 0:
            print("Time travel cancelled.")
            return
        if 1 <= choice <= len(locations):
            destination = locations[choice - 1]
            user_data["current_area"] = destination
            print(f"You have traveled back in time to {destination}!")
        else:
            print("Invalid choice.")
    except ValueError:
        print("Invalid input.")

# Show inventory function stub
def show_inventory() -> None:
    print_header("INVENTORY")
    if not user_data["inventory"]:
        print("Your inventory is empty.")
        return

    # Group items by type
    weapons = []
    armors = []
    accessories = []
    artifacts = []
    potions = []
    misc = []

    for item_name in user_data["inventory"]:
        # Check if this is an item object with details
        if isinstance(item_name, dict):
            item = item_name
            item_name = item["name"]

            if item.get("type") == "weapon":
                weapons.append(item)
            elif item.get("type") == "armor":
                armors.append(item)
            elif item.get("type") == "accessory":
                accessories.append(item)
            elif item.get("type") == "artifact":
                artifacts.append(item)
            elif item.get("type") == "potion":
                potions.append(item)
            else:
                misc.append(item_name)
        else:
            # For simple string items, check against recipes
            if item_name in CRAFTING_RECIPES:
                recipe = CRAFTING_RECIPES[item_name]
                if recipe.get("type") == "weapon":
                    weapons.append(item_name)
                elif recipe.get("type") == "armor":
                    armors.append(item_name)
                elif recipe.get("type") == "accessory":
                    accessories.append(item_name)
                elif recipe.get("type") == "artifact":
                    artifacts.append(item_name)
                else:
                    misc.append(item_name)
            elif item_name in POTION_RECIPES:
                potions.append(item_name)
            else:
                misc.append(item_name)

    # Display sections
    if weapons:
        print(f"\n{BLUE}WEAPONS:{ENDC}")
        for idx, item in enumerate(weapons, 1):
            if isinstance(item, dict):
                level_str = f" (Level {item.get('level', 1)})" if item.get('level', 1) > 1 else ""
                element_str = f" [{item.get('element', 'Nullum')}]" if 'element' in item else ""
                enchant_str = ""
                if "enchantments" in item and item["enchantments"]:
                    enchants = []
                    for name, level in item["enchantments"].items():
                        enchants.append(f"{name} {level}")
                    enchant_str = f" | {', '.join(enchants)}"
                print(f"{idx}. {item['name']}{level_str}{element_str}{enchant_str}")
            else:
                print(f"{idx}. {item}")

    if armors:
        print(f"\n{GREEN}ARMORS:{ENDC}")
        for idx, item in enumerate(armors, 1):
            if isinstance(item, dict):
                level_str = f" (Level {item.get('level', 1)})" if item.get('level', 1) > 1 else ""
                enchant_str = ""
                if "enchantments" in item and item["enchantments"]:
                    enchants = []
                    for name, level in item["enchantments"].items():
                        enchants.append(f"{name} {level}")
                    enchant_str = f" | {', '.join(enchants)}"
                print(f"{idx}. {item['name']}{level_str}{enchant_str}")
            else:
                print(f"{idx}. {item}")

    if accessories:
        print(f"\n{MAGENTA}ACCESSORIES:{ENDC}")
        for idx, item in enumerate(accessories, 1):
            if isinstance(item, dict):
                print(f"{idx}. {item['name']}")
            else:
                print(f"{idx}. {item}")

    if artifacts:
        print(f"\n{YELLOW}ARTIFACTS:{ENDC}")
        for idx, item in enumerate(artifacts, 1):
            if isinstance(item, dict):
                rarity = item.get("rarity", "Common")
                slot = item.get("slot", "")
                rarity_color = ARTIFACT_RARITIES.get(rarity, {}).get("color", "")
                print(f"{idx}. {rarity_color}{item['name']}{ENDC} ({slot})")
            else:
                # Try to get artifact info from recipes
                artifact_info = CRAFTING_RECIPES.get(item, {})
                rarity = artifact_info.get("rarity", "Common")
                slot = artifact_info.get("slot", "")
                rarity_color = ARTIFACT_RARITIES.get(rarity, {}).get("color", "")
                if slot:
                    print(f"{idx}. {rarity_color}{item}{ENDC} ({slot})")
                else:
                    print(f"{idx}. {item}")

    if potions:
        print(f"\n{CYAN}POTIONS:{ENDC}")
        for idx, item in enumerate(potions, 1):
            if isinstance(item, dict):
                print(f"{idx}. {item['name']}")
            else:
                # Try to get potion description from recipes
                potion_info = POTION_RECIPES.get(item, {})
                desc = potion_info.get("description", "")
                if desc:
                    print(f"{idx}. {item} - {desc}")
                else:
                    print(f"{idx}. {item}")

    if misc:
        print(f"\n{ENDC}OTHER ITEMS:{ENDC}")
        for idx, item in enumerate(misc, 1):
            print(f"{idx}. {item}")

    print(f"\nGold: {user_data['gold']}")

    # Display equipped items
    print("\nEquipped:")

    # Weapon
    if user_data.get("equipped", {}).get("weapon"):
        weapon = user_data["equipped"]["weapon"]
        level_str = f" (Level {weapon.get('level', 1)})" if weapon.get('level', 1) > 1 else ""
        element_str = f" [{weapon.get('element', 'Nullum')}]" if 'element' in weapon else ""
        print(f"Weapon: {weapon['name']}{level_str}{element_str}")
    else:
        print("Weapon: None")

    # Armor
    if user_data.get("equipped", {}).get("armor"):
        armor = user_data["equipped"]["armor"]
        level_str = f" (Level {armor.get('level', 1)})" if armor.get('level', 1) > 1 else ""
        print(f"Armor: {armor['name']}{level_str}")
    else:
        print("Armor: None")

    # Accessory
    if user_data.get("equipped", {}).get("accessory"):
        print(f"Accessory: {user_data['equipped']['accessory']['name']}")
    else:
        print("Accessory: None")

    # Artifacts
    print("\nArtifacts:")
    for slot in ARTIFACT_SLOTS:
        slot_key = f"artifact_{slot.lower()}"
        if user_data.get("equipped", {}).get(slot_key):
            artifact = user_data["equipped"][slot_key]
            rarity = artifact.get("rarity", "Common")
            rarity_color = ARTIFACT_RARITIES.get(rarity, {}).get("color", "")
            print(f"{slot}: {rarity_color}{artifact.get('name', 'Unknown')}{ENDC}")
        else:
            print(f"{slot}: None")

# Daily monster function stub
def daily_monster() -> None:
    print_header("Daily Monster")
    monster = random.choice(monsters)
    print(f"Today's monster is: {monster['name']} (Level {monster['level']})")
    print(f"Health: {monster['health']}, Attack: {monster['attack']}")
    print(f"Loot: {', '.join(monster['drops'])}")

# Redeem codes function
def redeem_codes() -> None:
    print_header("Redeemable Codes")
    print("Enter redeemable codes to claim rewards!")
    code = input("Enter code: ").strip()
    if code == "WELCOME2023":
        print("Code accepted! You received 100 gold and 50 experience.")
        user_data["gold"] += 100
        user_data["exp"] += 50
        check_level_up()
    else:
        print("Invalid or expired code.")

# Gambling guide function stub
def gambling_guide() -> None:
    print_header("Gambling Guide")
    print("Gambling feature is coming soon! Play responsibly ;].")

# Duel info function stub
def duel_info() -> None:
    print_header("Duel Info")
    print("Duel feature is coming soon! Challenge your friends.")

# Farming guide function stub
# Farming data structures

# Seasons for crop growing
SEASONS = ["Spring", "Summer", "Fall", "Winter"]

# Current season tracking
if "current_season" not in game_state:
    game_state["current_season"] = "Spring"
    game_state["season_day"] = 1
    game_state["days_per_season"] = 30  # Each season lasts 30 in-game days

CROPS = {
    # Basic Crops
    "Wheat": {
        "growth_time": 2, 
        "yield": "Wheat", 
        "seed_cost": 10, 
        "sell_price": 25, 
        "biome": ["Plains", "Abundant Field"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["stormy", "windy"],
        "seasons": ["Spring", "Summer", "Fall"],
        "tier": "common",
        "description": "A staple grain crop that grows quickly."
    },
    "Corn": {
        "growth_time": 3, 
        "yield": "Corn", 
        "seed_cost": 15, 
        "sell_price": 35, 
        "biome": ["Plains", "Abundant Field"],
        "optimal_weather": ["sunny", "rainy"],
        "weak_weather": ["foggy"],
        "seasons": ["Summer", "Fall"],
        "tier": "common",
        "description": "Tall stalks with yellow kernels. Loves the heat."
    },
    "Tomato": {
        "growth_time": 4, 
        "yield": "Tomato", 
        "seed_cost": 20, 
        "sell_price": 45, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["foggy", "stormy"],
        "seasons": ["Summer"],
        "tier": "common",
        "description": "Red juicy fruits that thrive in warm weather."
    },
    "Potato": {
        "growth_time": 5, 
        "yield": "Potato", 
        "seed_cost": 25, 
        "sell_price": 55, 
        "biome": ["Plains", "Abundant Field"],
        "optimal_weather": ["rainy", "cloudy"],
        "weak_weather": ["sunny"],
        "seasons": ["Spring", "Fall"],
        "tier": "common",
        "description": "Starchy tubers that grow underground."
    },
    "Rice": {
        "growth_time": 6, 
        "yield": "Rice", 
        "seed_cost": 30, 
        "sell_price": 65, 
        "biome": ["Swamp", "Plains"],
        "optimal_weather": ["rainy"],
        "weak_weather": ["sunny", "windy"],
        "seasons": ["Spring", "Summer"],
        "tier": "common",
        "description": "Grows best in waterlogged soil."
    },
    "Carrot": {
        "growth_time": 3, 
        "yield": "Carrot", 
        "seed_cost": 15, 
        "sell_price": 35, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["rainy", "cloudy"],
        "weak_weather": ["stormy"],
        "seasons": ["Spring", "Fall"],
        "tier": "common",
        "description": "Orange root vegetables that grow underground."
    },
    "Lettuce": {
        "growth_time": 2, 
        "yield": "Lettuce", 
        "seed_cost": 10, 
        "sell_price": 25, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["cloudy", "rainy"],
        "weak_weather": ["sunny", "stormy"],
        "seasons": ["Spring", "Fall"],
        "tier": "common",
        "description": "Leafy green vegetable that prefers cool weather."
    },
    "Strawberry": {
        "growth_time": 4, 
        "yield": "Strawberry", 
        "seed_cost": 25, 
        "sell_price": 55, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["sunny", "rainy"],
        "weak_weather": ["stormy", "foggy"],
        "seasons": ["Spring", "Summer"],
        "tier": "common",
        "description": "Sweet red berries that grow on small plants."
    },

    # New Common Crops
    "Onion": {
        "growth_time": 3, 
        "yield": "Onion", 
        "seed_cost": 15, 
        "sell_price": 40, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["clear", "sunny"],
        "weak_weather": ["rainy", "foggy"],
        "seasons": ["Spring", "Summer"],
        "tier": "common",
        "description": "Layered bulbs with a strong aroma."
    },
    "Pumpkin": {
        "growth_time": 7, 
        "yield": "Pumpkin", 
        "seed_cost": 35, 
        "sell_price": 70, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["stormy", "foggy"],
        "seasons": ["Summer", "Fall"],
        "tier": "common",
        "description": "Large orange gourds that grow on sprawling vines."
    },
    "Cabbage": {
        "growth_time": 5, 
        "yield": "Cabbage", 
        "seed_cost": 20, 
        "sell_price": 50, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["cloudy", "rainy"],
        "weak_weather": ["sunny", "windy"],
        "seasons": ["Spring", "Fall"],
        "tier": "common",
        "description": "Dense leafy heads that prefer cooler weather."
    },
    "Eggplant": {
        "growth_time": 6, 
        "yield": "Eggplant", 
        "seed_cost": 30, 
        "sell_price": 60,
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["foggy", "windy"],
        "seasons": ["Summer"],
        "tier": "common",
        "description": "Purple fruits with a meaty texture."
    },

    # Uncommon Crops
    "Watermelon": {
        "growth_time": 8, 
        "yield": "Watermelon", 
        "seed_cost": 45, 
        "sell_price": 90, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["sunny", "rainy"],
        "weak_weather": ["windy", "foggy"],
        "seasons": ["Summer"],
        "tier": "uncommon",
        "description": "Large, juicy fruits with red flesh and black seeds."
    },
    "Pineapple": {
        "growth_time": 10, 
        "yield": "Pineapple", 
        "seed_cost": 60, 
        "sell_price": 120, 
        "biome": ["Plains", "Tropical Beach"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["cloudy", "foggy"],
        "seasons": ["Summer"],
        "tier": "uncommon",
        "description": "Spiky tropical fruits with sweet yellow flesh."
    },
    "Sunflower": {
        "growth_time": 6, 
        "yield": "Sunflower Seeds", 
        "seed_cost": 40, 
        "sell_price": 85, 
        "biome": ["Plains", "Abundant Field"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["stormy", "windy"],
        "seasons": ["Summer", "Fall"],
        "tier": "uncommon",
        "description": "Tall flowers with edible seeds that follow the sun."
    },
    "Grape": {
        "growth_time": 9, 
        "yield": "Grapes", 
        "seed_cost": 55, 
        "sell_price": 110, 
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["stormy", "foggy"],
        "seasons": ["Summer", "Fall"],
        "tier": "uncommon",
        "description": "Clusters of small fruits that grow on vines."
    },

    # Special Crops
    "Golden Wheat": {
        "growth_time": 8, 
        "yield": "Golden Wheat", 
        "seed_cost": 100, 
        "sell_price": 250, 
        "biome": ["Plains", "Mystic Forest"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["stormy", "foggy"],
        "seasons": ["Summer", "Fall"],
        "tier": "rare",
        "description": "Magical grain that glows with a golden light."
    },
    "Magic Beans": {
        "growth_time": 10, 
        "yield": "Magic Beans", 
        "seed_cost": 150, 
        "sell_price": 300, 
        "biome": ["Mystic Forest"],
        "optimal_weather": ["rainy", "foggy"],
        "weak_weather": ["sunny", "clear"],
        "seasons": ["Spring", "Fall"],
        "tier": "rare",
        "description": "Mystical beans that may grow into something extraordinary."
    },
    "Dragon Fruit": {
        "growth_time": 12, 
        "yield": "Dragon Fruit", 
        "seed_cost": 200, 
        "sell_price": 450, 
        "biome": ["Dragon's Peak"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["rainy", "foggy"],
        "seasons": ["Summer"],
        "tier": "epic",
        "description": "Exotic fruits with fiery properties."
    },
    "Moonflower": {
        "growth_time": 6, 
        "yield": "Moonflower", 
        "seed_cost": 80, 
        "sell_price": 200, 
        "biome": ["Moonveil Harbor"],
        "optimal_weather": ["foggy", "cloudy"],
        "weak_weather": ["sunny", "stormy"],
        "seasons": ["Spring", "Fall"],
        "tier": "rare",
        "description": "Silver flowers that bloom under moonlight."
    },
    "Frost Berries": {
        "growth_time": 5, 
        "yield": "Frost Berries", 
        "seed_cost": 90, 
        "sell_price": 220, 
        "biome": ["Frostvale"],
        "optimal_weather": ["cloudy", "foggy"],
        "weak_weather": ["sunny", "rainy"],
        "seasons": ["Winter"],
        "tier": "rare",
        "description": "Icy blue berries that remain frozen even in warm weather."
    },
    "Fire Peppers": {
        "growth_time": 7, 
        "yield": "Fire Peppers", 
        "seed_cost": 120, 
        "sell_price": 280, 
        "biome": ["Ember Hollow"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["rainy", "foggy"],
        "seasons": ["Summer"],
        "tier": "rare",
        "description": "Intensely hot peppers that occasionally emit sparks."
    },
    "Shadow Root": {
        "growth_time": 9, 
        "yield": "Shadow Root", 
        "seed_cost": 130, 
        "sell_price": 290, 
        "biome": ["Shadowmere"],
        "optimal_weather": ["foggy", "cloudy"],
        "weak_weather": ["sunny", "clear"],
        "seasons": ["Fall", "Winter"],
        "tier": "rare",
        "description": "Mysterious roots that seem to absorb light."
    },
    "Crystal Bloom": {
        "growth_time": 11, 
        "yield": "Crystal Bloom", 
        "seed_cost": 180, 
        "sell_price": 400, 
        "biome": ["Crystal Cave"],
        "optimal_weather": ["clear", "foggy"],
        "weak_weather": ["stormy", "rainy"],
        "seasons": ["Winter", "Spring"],
        "tier": "epic",
        "description": "Flowers with petals that resemble translucent crystals."
    },

    # Dimension-Specific Crops
    "Cosmic Lotus": {
        "growth_time": 15, 
        "yield": "Cosmic Lotus", 
        "seed_cost": 300, 
        "sell_price": 750, 
        "biome": ["Celestial Realm"],
        "optimal_weather": ["Cosmic Rain", "Celestial Harmony"],
        "weak_weather": ["clear", "foggy"],
        "seasons": ["All"],
        "tier": "legendary",
        "description": "A mystical flower that contains the essence of stars."
    },
    "Void Mushroom": {
        "growth_time": 12, 
        "yield": "Void Mushroom", 
        "seed_cost": 250, 
        "sell_price": 600, 
        "biome": ["Shadow Realm"],
        "optimal_weather": ["Darkness Storm", "Void Mist"],
        "weak_weather": ["sunny", "rainy"],
        "seasons": ["All"],
        "tier": "epic",
        "description": "Fungus that thrives in complete darkness."
    },
    "Elemental Orchid": {
        "growth_time": 14, 
        "yield": "Elemental Essence", 
        "seed_cost": 280, 
        "sell_price": 700, 
        "biome": ["Elemental Plane"],
        "optimal_weather": ["Elemental Surge", "Primal Storm"],
        "weak_weather": ["cloudy", "foggy"],
        "seasons": ["All"],
        "tier": "epic",
        "description": "A flower that changes color based on the dominant element."
    },
    "Timeless Herb": {
        "growth_time": 10, 
        "yield": "Timeless Herb", 
        "seed_cost": 230, 
        "sell_price": 550, 
        "biome": ["Ancient Ruins"],
        "optimal_weather": ["Time Flux", "Arcane Winds"],
        "weak_weather": ["stormy", "windy"],
        "seasons": ["All"],
        "tier": "rare",
        "description": "An herb that seems to exist in multiple time periods at once."
    },

    # Rare Crops
    "Phoenix Flower": {
        "growth_time": 15, 
        "yield": "Phoenix Flower", 
        "seed_cost": 500, 
        "sell_price": 1200, 
        "biome": ["Silent Ashes"],
        "optimal_weather": ["clear", "sunny"],
        "weak_weather": ["rainy", "foggy"],
        "seasons": ["Summer"],
        "tier": "legendary",
        "description": "A flower that burns with eternal flame."
    },
    "Dragon's Breath Plant": {
        "growth_time": 20, 
        "yield": "Dragon's Breath", 
        "seed_cost": 800, 
        "sell_price": 2000, 
        "biome": ["Dragon's Peak"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["rainy", "foggy"],
        "seasons": ["Summer"],
        "tier": "legendary",
        "description": "A plant that exhales wisps of dragonfire."
    },
    "Celestial Herb": {
        "growth_time": 18, 
        "yield": "Celestial Herb", 
        "seed_cost": 600, 
        "sell_price": 1500, 
        "biome": ["Celestial Peaks"],
        "optimal_weather": ["clear", "Celestial Harmony"],
        "weak_weather": ["stormy", "windy"],
        "seasons": ["Spring", "Summer"],
        "tier": "legendary",
        "description": "A mythical herb that radiates celestial energy."
    },
    "Void Lotus": {
        "growth_time": 25, 
        "yield": "Void Lotus", 
        "seed_cost": 1000, 
        "sell_price": 2500, 
        "biome": ["Crimson Abyss"],
        "optimal_weather": ["foggy", "Void Mist"],
        "weak_weather": ["sunny", "clear"],
        "seasons": ["Winter", "Fall"],
        "tier": "legendary",
        "description": "A lotus that blooms in the darkest void, absorbing all light around it."
    },

    # Seasonal Specialty Crops
    "Winter Mint": {
        "growth_time": 8,
        "yield": "Winter Mint",
        "seed_cost": 75,
        "sell_price": 180,
        "biome": ["Frost Plains", "Garden"],
        "optimal_weather": ["snowy", "cloudy"],
        "weak_weather": ["sunny", "clear"],
        "seasons": ["Winter"],
        "tier": "uncommon",
        "description": "Frosty blue leaves with a cooling effect. Thrives in winter."
    },
    "Autumn Squash": {
        "growth_time": 7,
        "yield": "Autumn Squash",
        "seed_cost": 40,
        "sell_price": 90,
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["cloudy", "clear"],
        "weak_weather": ["stormy", "foggy"],
        "seasons": ["Fall"],
        "tier": "uncommon",
        "description": "Rich, colorful gourds that store well through winter."
    },
    "Spring Tulips": {
        "growth_time": 4,
        "yield": "Spring Tulips",
        "seed_cost": 30,
        "sell_price": 75,
        "biome": ["Garden", "Meadow"],
        "optimal_weather": ["rainy", "cloudy"],
        "weak_weather": ["stormy", "windy"],
        "seasons": ["Spring"],
        "tier": "uncommon",
        "description": "Colorful spring flowers that symbolize renewal."
    },
    "Summer Melon": {
        "growth_time": 9,
        "yield": "Summer Melon",
        "seed_cost": 50,
        "sell_price": 120,
        "biome": ["Plains", "Garden"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["foggy", "cloudy"],
        "seasons": ["Summer"],
        "tier": "uncommon",
        "description": "Sweet, juicy melons that love hot weather."
    },

    # Weather-Dependent Rare Crops
    "Ghost Pepper": {
        "growth_time": 12,
        "yield": "Ghost Pepper",
        "seed_cost": 100,
        "sell_price": 250,
        "biome": ["Volcanic Plains", "Desert"],
        "optimal_weather": ["sunny", "clear"],
        "weak_weather": ["rainy", "cloudy"],
        "seasons": ["Summer", "Fall"],
        "tier": "rare",
        "description": "Extremely spicy peppers that seem to glow at night."
    },
    "Frost Lotus": {
        "growth_time": 14,
        "yield": "Frost Lotus",
        "seed_cost": 120,
        "sell_price": 280,
        "biome": ["Frost Plains", "Mountain"],
        "optimal_weather": ["snowy", "foggy"],
        "weak_weather": ["sunny", "clear"],
        "seasons": ["Winter"],
        "tier": "rare",
        "description": "Ice-blue flowers that only bloom in freezing conditions."
    },
    "Thunderroot": {
        "growth_time": 11,
        "yield": "Thunderroot",
        "seed_cost": 110,
        "sell_price": 260,
        "biome": ["Plains", "Storm Fields"],
        "optimal_weather": ["stormy", "rainy"],
        "weak_weather": ["sunny", "clear"],
        "seasons": ["Spring", "Fall"],
        "tier": "rare",
        "description": "Roots that absorb electrical energy during storms."
    }
}

def cook_food() -> None:
    """Function to cook food with a chance of failure"""
    print_header("Cooking Station")

    # Check if the player is at a suitable location or has the right equipment
    if "camp" not in user_data or "Kitchen" not in user_data.get("camp", {}).get("structures", {}):
        if user_data["current_area"] not in ["Greenwood Village", "Stormhaven", "Dragon's Peak"]:
            print_colored("You need to be in a village with a kitchen or have a Kitchen in your camp to cook!", FAIL)
            return

    # Display available recipes
    print_colored("Available Recipes:", HEADER)
    available_recipes = []

    for recipe_name, recipe_data in COOKING_RECIPES.items():
        # Check if player has the ingredients
        has_ingredients = True
        missing_ingredients = {}

        for ingredient, amount in recipe_data["ingredients"].items():
            if ingredient not in user_data.get("materials", {}) or user_data.get("materials", {}).get(ingredient, 0) < amount:
                has_ingredients = False
                current_amount = user_data.get("materials", {}).get(ingredient, 0)
                missing_ingredients[ingredient] = amount - current_amount

        # Display recipe with color based on availability
        color = GREEN if has_ingredients else RED
        print_colored(f"{recipe_name} - {recipe_data['description']}", color)

        if has_ingredients:
            available_recipes.append(recipe_name)
            print_colored("  Ingredients: ", YELLOW, end="")
            for ingredient, amount in recipe_data["ingredients"].items():
                print(f"{ingredient} x{amount}", end=", ")
            print()
            print_colored(f"  Difficulty: {recipe_data['difficulty']} | Fail Chance: {int(recipe_data['fail_chance'] * 100)}%", YELLOW)
            print_colored(f"  Restores: {recipe_data.get('health_restore', 0)} HP, {recipe_data.get('stamina_restore', 0)} Stamina", BLUE)
            if "buffs" in recipe_data:
                print_colored("  Buffs: ", BLUE, end="")
                for buff, value in recipe_data["buffs"].items():
                    print(f"{buff.replace('_', ' ').title()} +{value}", end=", ")
                print()
        else:
            print_colored("  Missing ingredients: ", RED, end="")
            for ingredient, amount in missing_ingredients.items():
                print(f"{ingredient} x{amount}", end=", ")
            print()

    if not available_recipes:
        print_colored("\nYou don't have ingredients for any recipes. Try gathering more materials!", WARNING)
        return

    # Recipe selection
    print()
    recipe_choice = input("What would you like to cook? (or press Enter to cancel): ")

    if not recipe_choice:
        return

    if recipe_choice not in COOKING_RECIPES:
        print_colored("That recipe doesn't exist!", FAIL)
        return

    if recipe_choice not in available_recipes:
        print_colored("You don't have the ingredients for that recipe!", FAIL)
        return

    selected_recipe = COOKING_RECIPES[recipe_choice]

    # Remove ingredients from inventory
    for ingredient, amount in selected_recipe["ingredients"].items():
        user_data["materials"][ingredient] -= amount
        if user_data["materials"][ingredient] <= 0:
            del user_data["materials"][ingredient]

    # Cooking animation
    print_colored("\nCooking in progress...", YELLOW)
    cook_time = selected_recipe.get("cook_time", 3)
    for i in range(cook_time):
        time.sleep(0.5)
        print_colored("🔥" * (i+1), YELLOW)

    # Determine success or failure based on difficulty
    difficulty = selected_recipe["difficulty"]
    fail_chance = selected_recipe["fail_chance"]

    # Profession bonus - reduce fail chance for Chefs
    if user_data.get("profession") == "Chef":
        fail_chance = max(0.01, fail_chance - 0.1)  # Minimum 1% chance to fail
        print_colored("Your Chef skills improve your chances of success!", GREEN)

    # Roll for success
    if random.random() < fail_chance:
        # Cooking failed
        failed_result = FAILED_COOKING[difficulty]
        print_colored(f"\nOh no! Your {recipe_choice} turned into a {failed_result['name']}!", FAIL)
        print_colored(f"{failed_result['description']}", WARNING)

        # Add failed result to inventory
        if failed_result["name"] not in user_data["inventory"]:
            user_data["inventory"][failed_result["name"]] = 0
        user_data["inventory"][failed_result["name"]] += 1

        # Small XP gain even for failure
        exp_gain = int(selected_recipe["experience"] * 0.3)
        user_data["exp"] += exp_gain
        print_colored(f"You gained {exp_gain} experience from the attempt.", BLUE)
    else:
        # Cooking succeeded
        print_colored(f"\nSuccess! You've cooked a delicious {recipe_choice}!", SUCCESS)

        # Add food to inventory
        if recipe_choice not in user_data["inventory"]:
            user_data["inventory"][recipe_choice] = 0
        user_data["inventory"][recipe_choice] += 1

        # XP gain
        exp_gain = selected_recipe["experience"]
        user_data["exp"] += exp_gain
        print_colored(f"You gained {exp_gain} experience!", BLUE)

        # Chance for bonus food with Chef profession
        if user_data.get("profession") == "Chef" and random.random() < 0.25:
            user_data["inventory"][recipe_choice] += 1
            print_colored("Your Chef skills allowed you to cook an extra portion!", SUCCESS)

    # Check for level up
    check_level_up()

    # Add cooking achievements
    if "cooking_stats" not in user_data:
        user_data["cooking_stats"] = {"dishes_cooked": 0, "failures": 0, "by_difficulty": {}}

    if random.random() < fail_chance:
        user_data["cooking_stats"]["failures"] += 1
    else:
        user_data["cooking_stats"]["dishes_cooked"] += 1

    if difficulty not in user_data["cooking_stats"]["by_difficulty"]:
        user_data["cooking_stats"]["by_difficulty"][difficulty] = 0
    user_data["cooking_stats"]["by_difficulty"][difficulty] += 1

    # Check cooking achievements
    if user_data["cooking_stats"]["dishes_cooked"] >= 10:
        achievement_name = "Amateur Chef"
        grant_achievement_rewards({"name": achievement_name, "rewards": {"exp": 100, "gold": 50}})

    if user_data["cooking_stats"]["dishes_cooked"] >= 50:
        achievement_name = "Experienced Cook"
        grant_achievement_rewards({"name": achievement_name, "rewards": {"exp": 300, "gold": 150}})

    if user_data["cooking_stats"]["by_difficulty"].get("hard", 0) >= 20:
        achievement_name = "Master Chef"
        grant_achievement_rewards({"name": achievement_name, "rewards": {"exp": 500, "gold": 300}})

def farming_guide() -> None:
    print_header("Farming")

    # Initialize farming data if not present
    if "farming" not in user_data:
        user_data["farming"] = {
            "plots": {},  # Store planted crops
            "growth": {},  # Store growth progress
            "unlocked_plots": 3  # Start with 3 plots
        }

    while True:
        # Show farm status
        print_colored("\n=== Your Farm ===", GREEN)
        print(f"Gold: {user_data['gold']}")
        print(f"Plots available: {user_data['farming']['unlocked_plots']} (Used: {len(user_data['farming']['plots'])})")

        print("\nActions:")
        print("1. View crop prices and info")
        print("2. Buy seeds")
        print("3. Plant crops")
        print("4. View farm")
        print("5. Harvest crops")
        print("6. Sell crops")
        print("7. Upgrade farm")
        print("8. Exit farming")

        choice = input("\nChoose action (1-8): ")

        if choice == "1":
            print_colored("\n=== Crop Information ===", CYAN)
            print_colored(f"Current Season: {game_state['current_season']}", YELLOW)
            print_colored(f"Current Weather: {get_weather_name()}", game_state.get("current_weather_color", CYAN))
            print()

            # Allow filtering by tier
            print("Filter by tier:")
            print("1. All Crops")
            print("2. Common Crops")
            print("3. Uncommon Crops")
            print("4. Rare Crops")
            print("5. Epic Crops")
            print("6. Legendary Crops")
            print("7. Seasonal Crops (current season)")

            tier_filter = input("\nChoose filter (1-7, default 1): ").strip()

            # Default to all crops
            if not tier_filter or tier_filter not in "1234567":
                tier_filter = "1"

            filtered_crops = {}
            current_season = game_state['current_season']

            for crop, info in CROPS.items():
                # Apply filters
                if tier_filter == "2" and info.get("tier") != "common":
                    continue
                elif tier_filter == "3" and info.get("tier") != "uncommon":
                    continue
                elif tier_filter == "4" and info.get("tier") != "rare":
                    continue
                elif tier_filter == "5" and info.get("tier") != "epic":
                    continue
                elif tier_filter == "6" and info.get("tier") != "legendary":
                    continue
                elif tier_filter == "7" and current_season not in info.get("seasons", []) and "All" not in info.get("seasons", []):
                    continue

                filtered_crops[crop] = info

            # Get tiers for color coding
            tier_colors = {
                "common": WHITE,
                "uncommon": GREEN,
                "rare": BLUE,
                "epic": PURPLE,
                "legendary": YELLOW
            }

            # Display filtered crops
            for crop, info in filtered_crops.items():
                tier = info.get("tier", "common")
                tier_color = tier_colors.get(tier, WHITE)

                print_colored(f"\n{crop} ({tier.capitalize()}):", tier_color)
                print(f"  Description: {info.get('description', 'No description available')}")
                print(f"  Growth Time: {info['growth_time']} cycles")
                print(f"  Seed Cost: {info['seed_cost']} gold")
                print(f"  Market Price: {info['sell_price']} gold")

                # Display seasonal information
                seasons = info.get("seasons", [])
                if "All" in seasons:
                    print_colored("  Seasons: All seasons", OKGREEN)
                else:
                    season_str = ", ".join(seasons)
                    season_color = OKGREEN if current_season in seasons else FAIL
                    print_colored(f"  Seasons: {season_str}", season_color)

                # Display weather preferences
                optimal_weather = info.get("optimal_weather", [])
                weak_weather = info.get("weak_weather", [])

                current_weather = game_state["current_weather"]

                optimal_str = ", ".join(optimal_weather)
                weak_str = ", ".join(weak_weather)

                optimal_color = OKGREEN if current_weather in optimal_weather else LIGHTGRAY
                weak_color = FAIL if current_weather in weak_weather else LIGHTGRAY

                print_colored(f"  Optimal Weather: {optimal_str}", optimal_color)
                print_colored(f"  Weak Weather: {weak_str}", weak_color)

                # Show where crop can be grown
                biomes = info.get("biome", [])
                print(f"  Biomes: {', '.join(biomes)}")
                print(f"  Profit per crop: {info['sell_price'] - info['seed_cost']} gold")

        elif choice == "2":
            print_colored("\n=== Seed Shop ===", YELLOW)
            print("Available seeds:")
            for crop, info in CROPS.items():
                print(f"{crop} seeds: {info['seed_cost']} gold")

            seed = input("\nWhich seeds would you like to buy? (or Enter to cancel): ").capitalize()
            if seed in CROPS:
                amount = input("How many? ")
                try:
                    amount = int(amount)
                    total_cost = CROPS[seed]["seed_cost"] * amount
                    if total_cost <= user_data["gold"]:
                        user_data["gold"] -= total_cost
                        seed_name = f"{seed} seeds"
                        if seed_name not in user_data["materials"]:
                            user_data["materials"][seed_name] = 0
                        user_data["materials"][seed_name] += amount
                        print_colored(f"Bought {amount} {seed} seeds for {total_cost} gold!", GREEN)
                    else:
                        print_colored("Not enough gold!", RED)
                except ValueError:
                    print_colored("Please enter a valid number.", RED)

        elif choice == "3":
            print_colored("\n=== Plant Crops ===", GREEN)
            print_colored(f"Current Season: {game_state['current_season']}", YELLOW)
            print_colored(f"Current Weather: {get_weather_name()}", game_state.get("current_weather_color", CYAN))

            seeds = [mat for mat in user_data["materials"] if mat.endswith(" seeds")]

            if not seeds:
                print_colored("You don't have any seeds!", RED)
                continue

            # Get current season for showing compatibility
            current_season = game_state["current_season"]

            print("\nYour seeds:")
            for seed in seeds:
                # Get the actual crop name
                crop_name = seed.replace(" seeds", "")
                if crop_name in CROPS:
                    crop_data = CROPS[crop_name]
                    # Check if it's compatible with the current season
                    crop_seasons = crop_data.get("seasons", [])
                    if "All" in crop_seasons or current_season in crop_seasons:
                        seasons_color = OKGREEN
                        season_note = "(In season)"
                    else:
                        seasons_color = FAIL
                        season_note = "(Out of season - grows slower)"

                    # Show the seed with color-coded seasonal information
                    print(f"{seed}: {user_data['materials'][seed]} ", end="")
                    print_colored(season_note, seasons_color)
                else:
                    # Legacy seed without seasonal data
                    print(f"{seed}: {user_data['materials'][seed]}")

            if len(user_data["farming"]["plots"]) >= user_data["farming"]["unlocked_plots"]:
                print_colored("All plots are occupied! Harvest some crops or upgrade your farm.", RED)
                continue

            seed = input("\nWhich seeds would you like to plant? (or Enter to cancel): ")
            if seed in seeds:
                crop_name = seed.replace(" seeds", "")
                crop_data = CROPS.get(crop_name, {})

                # Check season compatibility and warn player if needed
                if crop_name in CROPS:
                    crop_seasons = crop_data.get("seasons", [])
                    if "All" not in crop_seasons and current_season not in crop_seasons:
                        print_colored("WARNING: This crop is out of season and will grow much slower!", YELLOW)
                        confirm = input("Do you still want to plant it? (y/n): ").lower()
                        if confirm != 'y':
                            continue

                available_plots = user_data["farming"]["unlocked_plots"] - len(user_data["farming"]["plots"])
                amount = input(f"How many? (max {min(user_data['materials'][seed], available_plots)}): ")

                try:
                    amount = int(amount)
                    if amount > 0 and amount <= user_data["materials"][seed] and amount <= available_plots:
                        # Display growth estimate based on weather and season
                        if crop_name in CROPS:
                            # Calculate modifiers
                            current_weather = game_state["current_weather"]
                            general_weather_modifier = game_state.get("current_weather_crop_modifier", 1.0)

                            # Get seasons for this crop
                            crop_seasons = crop_data.get("seasons", [])

                            season_modifier = 1.0
                            if "All" in crop_seasons:
                                season_modifier = 1.2
                            elif current_season in crop_seasons:
                                season_modifier = 1.2  
                            else:
                                season_modifier = 0.5

                            weather_bonus = 1.0
                            if current_weather in crop_data.get("optimal_weather", []):
                                weather_bonus = 1.3
                            elif current_weather in crop_data.get("weak_weather", []):
                                weather_bonus = 0.7

                            total_modifier = general_weather_modifier * season_modifier * weather_bonus
                            days_estimate = int(crop_data["growth_time"] / total_modifier)

                            print_colored(f"Estimated growth time: {days_estimate} days", CYAN)

                            if total_modifier > 1.0:
                                print_colored("Current conditions are favorable for this crop!", OKGREEN)
                            elif total_modifier < 0.8:
                                print_colored("Current conditions are poor for this crop. Consider planting something else.", YELLOW)

                        # Plant the crops
                        for _ in range(amount):
                            plot_id = str(len(user_data["farming"]["plots"]))
                            user_data["farming"]["plots"][plot_id] = crop_name
                            user_data["farming"]["growth"][plot_id] = 0
                        user_data["materials"][seed] -= amount
                        if user_data["materials"][seed] <= 0:
                            del user_data["materials"][seed]
                        print_colored(f"Planted {amount} {crop_name}!", GREEN)
                    else:
                        print_colored("Invalid amount!", RED)
                except ValueError:
                    print_colored("Please enter a valid number.", RED)

        elif choice == "4":
            print_colored("\n=== Farm Status ===", CYAN)
            print_colored(f"Current Season: {game_state['current_season']}", YELLOW)
            print_colored(f"Current Weather: {get_weather_name()}", game_state.get("current_weather_color", CYAN))
            print_colored(f"Weather Description: {get_weather_description()}", LIGHTGRAY)
            print()

            if not user_data["farming"]["plots"]:
                print("No crops planted!")
                continue

            # Calculate total growth modifiers for display
            current_weather = game_state["current_weather"]
            current_season = game_state["current_season"]
            general_weather_modifier = game_state.get("current_weather_crop_modifier", 1.0)

            for plot, crop in user_data["farming"]["plots"].items():
                crop_data = CROPS.get(crop, {})

                # Get growth progress
                growth = user_data["farming"]["growth"][plot]
                max_growth = crop_data["growth_time"] * TICKS_PER_DAY // 10  # Scale growth time to ticks

                # Calculate modifiers
                season_modifier = 1.0
                crop_seasons = crop_data.get("seasons", [])

                if "All" in crop_seasons:
                    season_modifier = 1.2
                elif current_season in crop_seasons:
                    season_modifier = 1.2
                else:
                    season_modifier = 0.5

                weather_bonus = 1.0
                if current_weather in crop_data.get("optimal_weather", []):
                    weather_bonus = 1.3
                elif current_weather in crop_data.get("weak_weather", []):
                    weather_bonus = 0.7

                total_modifier = general_weather_modifier * season_modifier * weather_bonus
                modifier_percent = int((total_modifier - 1.0) * 100)

                # Determine status and color
                if growth >= max_growth:
                    status = "✨ Ready to harvest!"
                    status_color = OKGREEN
                else:
                    percent_complete = min(int((growth / max_growth) * 100), 99)
                    growth_icon = "🌱" if percent_complete < 33 else "🌿" if percent_complete < 66 else "🌾"
                    status = f"{growth_icon} Growing... {percent_complete}% complete"
                    status_color = YELLOW

                # Show crop tier with appropriate color
                tier = crop_data.get("tier", "common").capitalize()
                tier_colors = {
                    "Common": WHITE,
                    "Uncommon": GREEN,
                    "Rare": BLUE,
                    "Epic": PURPLE,
                    "Legendary": YELLOW
                }
                tier_color = tier_colors.get(tier, WHITE)

                # Display the crop info
                print_colored(f"Plot {plot}: ", CYAN, end="")
                print_colored(f"{status} ", status_color, end="")
                print_colored(f"{crop} ", tier_color, end="")
                print(f"({growth}/{max_growth} ticks)")

                # Show growth modifiers
                modifier_color = OKGREEN if modifier_percent > 0 else (FAIL if modifier_percent < 0 else WHITE)
                modifier_sign = "+" if modifier_percent > 0 else ""
                print_colored(f"  Growth Rate: {modifier_sign}{modifier_percent}% ", modifier_color, end="")

                # Show weather and season effects
                if current_weather in crop_data.get("optimal_weather", []):
                    print_colored("(Optimal weather) ", OKGREEN, end="")
                elif current_weather in crop_data.get("weak_weather", []):
                    print_colored("(Unfavorable weather) ", FAIL, end="")

                if current_season in crop_seasons:
                    print_colored("(Good season) ", OKGREEN)
                elif "All" in crop_seasons:
                    print_colored("(Grows in all seasons) ", OKGREEN)
                else:
                    print_colored("(Wrong season) ", FAIL)

        elif choice == "5":
            print_colored("\n=== Harvest Crops ===", YELLOW)
            harvested = False
            for plot, crop in list(user_data["farming"]["plots"].items()):
                if user_data["farming"]["growth"][plot] >= CROPS[crop]["growth_time"]:
                    harvested = True
                    yield_amount = random.randint(1, 3)
                    if crop not in user_data["materials"]:
                        user_data["materials"][crop] = 0
                    user_data["materials"][crop] += yield_amount

                    # Remove harvested crop
                    del user_data["farming"]["plots"][plot]
                    del user_data["farming"]["growth"][plot]

                    print_colored(f"Harvested {yield_amount}x {crop} from plot {plot}!", GREEN)

            if not harvested:
                print_colored("No crops ready to harvest!", RED)

        elif choice == "6":
            print_colored("\n=== Sell Crops ===", YELLOW)
            crops_to_sell = [crop for crop in user_data["materials"] if crop in CROPS]

            if not crops_to_sell:
                print_colored("You have no crops to sell!", RED)
                continue

            print("\nYour crops:")
            for crop in crops_to_sell:
                print(f"{crop}: {user_data['materials'][crop]} (Worth: {CROPS[crop]['sell_price']} gold each)")

            crop = input("\nWhat would you like to sell? (or Enter to cancel): ")
            if crop in crops_to_sell:
                amount = input(f"How many? (max {user_data['materials'][crop]}): ")
                try:
                    amount = int(amount)
                    if 0 < amount <= user_data["materials"][crop]:
                        total_price = CROPS[crop]["sell_price"] * amount
                        user_data["materials"][crop] -= amount
                        if user_data["materials"][crop] <= 0:
                            del user_data["materials"][crop]
                        user_data["gold"] += total_price
                        print_colored(f"Sold {amount}x {crop} for {total_price} gold!", GREEN)
                    else:
                        print_colored("Invalid amount!", RED)
                except ValueError:
                    print_colored("Please enter a valid number.", RED)

        elif choice == "7":
            print_colored("\n=== Farm Upgrades ===", MAGENTA)
            upgrade_cost = 1000 * (user_data["farming"]["unlocked_plots"] - 2)
            print(f"Upgrade cost for new plot: {upgrade_cost} gold")

            if input("Would you like to upgrade? (y/n): ").lower() == 'y':
                if user_data["gold"] >= upgrade_cost:
                    user_data["gold"] -= upgrade_cost
                    user_data["farming"]["unlocked_plots"] += 1
                    print_colored(f"Farm upgraded! You now have {user_data['farming']['unlocked_plots']} plots!", GREEN)
                else:
                    print_colored("Not enough gold!", RED)

        elif choice == "8":
            break

        # Progress growth for all planted crops
        for plot in user_data["farming"]["growth"]:
            user_data["farming"]["growth"][plot] += 1

# Horse festival function (added for completeness)
# Horse festival function removed as it was not useful

# New function for gathering materials
def gather_materials(area: str) -> None:
    # Fix check to see if area is in any MATERIALS areas list
    if not any(area in mat["areas"] for mat in MATERIALS.values()):
        print(f"No materials can be gathered in {area}")
        return

    available_materials = [name for name, info in MATERIALS.items() if area in info["areas"]]
    print(f"\nAvailable materials in {area}:")
    for i, mat in enumerate(available_materials, 1):
        tool_req = MATERIALS[mat]["tool_required"]
        print(f"{i}. {mat} {'(Requires: ' + tool_req + ')' if tool_req else ''}")

    choice = input("\nChoose material to gather (number) or 0 to cancel: ")
    try:
        choice = int(choice)
        if choice == 0:
            return
        if 1 <= choice <= len(available_materials):
            material = available_materials[choice - 1]
            tool_required = MATERIALS[material]["tool_required"]

            if tool_required and tool_required not in user_data["tools"]:
                print(f"You need a {tool_required} to gather {material}")
                return

            amount = random.randint(1, 3)
            user_data["materials"][material] = user_data["materials"].get(material, 0) + amount
            print(f"Gathered {amount} {material}")
        else:
            print("Invalid choice")
    except ValueError:
        print("Invalid input")

def craft_item() -> None:
    print_header("Crafting")

    # Get player's profession for crafting bonuses
    player_profession = user_data.get("profession", None)
    crafting_bonus = 0
    profession_specializations = user_data.get("profession_specializations", {})

    # Apply profession bonuses if applicable
    if player_profession in ["Blacksmith", "Alchemist", "Tailor", "Artificer"]:
        crafting_bonus = 10  # Base 10% bonus for crafting professions

        # Apply specialization bonuses
        if player_profession == "Blacksmith" and profession_specializations.get("Master Weaponsmith", False):
            crafting_bonus += 15  # Additional 15% for weapon crafting
        elif player_profession == "Alchemist" and profession_specializations.get("Potion Master", False):
            crafting_bonus += 15  # Additional 15% for potion crafting
        elif player_profession == "Tailor" and profession_specializations.get("Master Outfitter", False):
            crafting_bonus += 15  # Additional 15% for armor crafting
        elif player_profession == "Artificer" and profession_specializations.get("Arcane Engineer", False):
            crafting_bonus += 15  # Additional 15% for magical item crafting

    # Filter recipes by type option
    crafting_categories = {
        "1": ("Weapons", "weapon"),
        "2": ("Armor", "armor"),
        "3": ("Tools", "tool"),
        "4": ("Accessories", "accessory"),
        "5": ("Materials", "material"),
        "6": ("All Items", None)
    }

    print("\nCrafting Categories:")
    for key, (name, _) in crafting_categories.items():
        print(f"{key}. {name}")

    category_choice = input("\nChoose a category (number) or press Enter for all: ").strip()
    if not category_choice:
        category_choice = "6"  # Default to All Items

    # Get the category filter
    selected_category = None
    if category_choice in crafting_categories:
        _, selected_category = crafting_categories[category_choice]

    # Filter recipes by player level and category if selected
    available_recipes = []
    for name, recipe in CRAFTING_RECIPES.items():
        if user_data["level"] >= recipe["level_required"]:
            if selected_category is None or recipe.get("type") == selected_category:
                available_recipes.append(name)

    # Sort recipes by level required
    available_recipes.sort(key=lambda x: CRAFTING_RECIPES[x]["level_required"])

    if not available_recipes:
        print("No recipes available at your level or in this category")
        return

    # Check which recipes can be crafted with current materials
    craftable_recipes = []
    for recipe_name in available_recipes:
        recipe = CRAFTING_RECIPES[recipe_name]
        can_craft = True
        for material, amount in recipe["materials"].items():
            if user_data["materials"].get(material, 0) < amount:
                can_craft = False
                break
        craftable_recipes.append((recipe_name, can_craft))

    print(f"\nAvailable recipes ({len(available_recipes)}):")
    for i, (recipe_name, can_craft) in enumerate(craftable_recipes, 1):
        recipe = CRAFTING_RECIPES[recipe_name]

        # Format based on craftability
        if can_craft:
            status = f"{GREEN}[CRAFTABLE]{ENDC}"
        else:
            status = f"{RED}[MISSING MATERIALS]{ENDC}"

        # Format recipe name based on its type
        item_type = recipe.get("type", "")
        if item_type == "weapon":
            type_color = RED
        elif item_type == "armor":
            type_color = BLUE
        elif item_type == "tool":
            type_color = YELLOW
        elif item_type == "accessory":
            type_color = MAGENTA
        else:
            type_color = WHITE

        # Show item level and effects
        effect_str = ""
        if "effect" in recipe:
            effect_str = f" - Power: {recipe['effect']}"
        if "element" in recipe:
            element_color = get_element_color(recipe["element"])
            effect_str += f" - Element: {element_color}{recipe['element']}{ENDC}"
        if "special" in recipe:
            effect_str += f" - Special: {recipe['special']}"

        print(f"\n{i}. {type_color}{recipe_name}{ENDC} {status}{effect_str}")
        print(f"   Type: {item_type.capitalize()}, Level Required: {recipe['level_required']}")

        # Show materials with color indicating if you have enough
        print("   Required materials:")
        for material, amount in recipe["materials"].items():
            have_amount = user_data["materials"].get(material, 0)
            if have_amount >= amount:
                material_status = f"{GREEN}{have_amount}/{amount}{ENDC}"
            else:
                material_status = f"{RED}{have_amount}/{amount}{ENDC}"
            print(f"    - {material}: {material_status}")

    # Highlight the crafting bonus if applicable
    if crafting_bonus > 0:
        print(f"\n{YELLOW}Crafting Bonus: +{crafting_bonus}% quality from {player_profession} profession{ENDC}")

    choice = input("\nChoose item to craft (number) or 0 to cancel: ")
    try:
        choice = int(choice)
        if choice == 0:
            return
        if 1 <= choice <= len(craftable_recipes):
            recipe_name, can_craft = craftable_recipes[choice - 1]
            recipe = CRAFTING_RECIPES[recipe_name]

            # Check materials again to be safe
            missing_materials = []
            for material, amount in recipe["materials"].items():
                if user_data["materials"].get(material, 0) < amount:
                    missing_materials.append(f"{material} ({user_data['materials'].get(material, 0)}/{amount})")

            if missing_materials:
                print(f"{RED}Cannot craft - missing materials:{ENDC}")
                for mat in missing_materials:
                    print(f"  - {mat}")
                return

            # Confirm crafting
            confirm = input(f"Craft {recipe_name}? (y/n): ").strip().lower()
            if confirm != 'y':
                return

            # Determine if crafting results in a higher quality item based on profession
            quality_bonus = random.randint(0, 100)
            quality_result = "normal"

            if quality_bonus < crafting_bonus:
                # Crafting bonus triggered for better quality
                if quality_bonus < crafting_bonus * 0.3:  # 30% of bonus chance for exceptional quality
                    quality_result = "exceptional"
                else:
                    quality_result = "superior"

            # Consume materials
            for material, amount in recipe["materials"].items():
                user_data["materials"][material] -= amount

            # Add item to inventory with quality tag if applicable
            crafted_item = recipe_name
            if quality_result == "superior":
                crafted_item = f"Superior {recipe_name}"
                print(f"{GREEN}Your expertise as a {player_profession} helped create a superior quality item!{ENDC}")
            elif quality_result == "exceptional":
                crafted_item = f"Exceptional {recipe_name}"
                print(f"{CYAN}Your mastery as a {player_profession} resulted in an exceptional crafting result!{ENDC}")

            user_data["inventory"].append(crafted_item)

            # Update any related achievements or stats
            user_data["stats"]["items_crafted"] = user_data["stats"].get("items_crafted", 0) + 1

            if recipe.get("type") == "weapon":
                user_data["stats"]["weapons_crafted"] = user_data["stats"].get("weapons_crafted", 0) + 1
            elif recipe.get("type") == "armor":
                user_data["stats"]["armor_crafted"] = user_data["stats"].get("armor_crafted", 0) + 1

            # Special message based on item type
            item_type = recipe.get("type", "")
            if item_type == "weapon":
                print(f"{RED}Successfully crafted {crafted_item}!{ENDC} This new weapon will help you in battles.")
            elif item_type == "armor":
                print(f"{BLUE}Successfully crafted {crafted_item}!{ENDC} This armor will offer better protection.")
            elif item_type == "tool":
                print(f"{YELLOW}Successfully crafted {crafted_item}!{ENDC} This tool will help you gather resources more efficiently.")
            else:
                print(f"Successfully crafted {crafted_item}!")

            # Show item details
            print("\nItem details:")
            if "effect" in recipe:
                print(f"Power: {recipe['effect']}")
            if "element" in recipe:
                element_color = get_element_color(recipe["element"])
                print(f"Element: {element_color}{recipe['element']}{ENDC}")
            if "special" in recipe:
                print(f"Special ability: {recipe['special']}")

            # Offer to equip if it's equippable
            if item_type in ["weapon", "armor", "accessory"]:
                equip_choice = input("\nEquip this item now? (y/n): ").strip().lower()
                if equip_choice == 'y':
                    equip_item(crafted_item)

        else:
            print("Invalid choice")
    except ValueError:
        print("Invalid input")

def print_materials() -> None:
    print_header("Materials")
    if not user_data["materials"]:
        print("You don't have any materials")
        return

    for material, amount in user_data["materials"].items():
        print(f"{material}: {amount}")

def travel_to_area() -> None:
    print_header("Travel")
    print("\nAvailable locations:")
    locations = list(LOCATIONS.keys())
    for i, loc in enumerate(locations, 1):
        info = LOCATIONS[loc]
        print(f"{i}. {loc} - {info['description']}")
        if info['type'] == 'town':
            print(f"   Shops: {', '.join(info['shops'])}")

    choice = input("\nChoose area to travel to (number) or 0 to cancel: ")
    try:
        choice = int(choice)
        if choice == 0:
            return
        if 1 <= choice <= len(locations):
            user_data["current_area"] = locations[choice - 1]
            print(f"Traveled to {user_data['current_area']}")
        else:
            print("Invalid choice")
    except ValueError:
        print("Invalid input")

def fight_monster(monster_name: str) -> None:
    try:
        monster = next((m for m in monsters if m["name"].lower() == monster_name.lower()), None)
        if not monster:
            print(f"Monster '{monster_name}' not found!")
            return

        # Check player level against monster level
        if user_data["level"] < monster["level"]:
            print(f"{FAIL}Warning: This monster is too strong for your level! (Required: Level {monster['level']}){ENDC}")
            if input("Do you still want to fight? (y/n): ").lower() != 'y':
                return

        if user_data["health"] <= 0:
            print("You can't fight while defeated! Use a healing potion or rest.")
            return

        # Check if monster is in current area (case-insensitive)
        area_monsters = LOCATIONS.get(user_data["current_area"], {}).get("monsters", [])
        if not any(monster["name"].lower() == m.lower() for m in area_monsters):
            print(f"{monster['name']} is not in this area! Travel to find it.")
            return

        print_header(f"Fighting {monster['name']}")
        monster_health = monster["health"]

        while user_data["health"] > 0 and monster_health > 0:
            try:
                print(f"\nYour Health: {user_data['health']}/{user_data['max_health']}")
                print(f"Monster Health: {monster_health}/{monster['health']}")
                print("\nActions:")
                print("1. Attack")
                print("2. Use Skill")
                print("3. Use Healing Potion")
                print("4. Flee")

                choice = input("Choose action (1-4): ").strip()

                if choice == "1":
                    # Calculate damage with equipped weapon
                    base_damage = user_data.get("attack", 10)  # Default attack value if not found
                    weapon_bonus = user_data.get("equipped", {}).get("weapon", {}).get("effect", 0)
                    damage = base_damage + weapon_bonus

                    if random.random() < CRITICAL_CHANCE:
                        damage *= 2
                        print("Critical hit!")

                    monster_health -= damage
                    print(f"You deal {damage} damage!")

                elif choice == "2":
                    if user_data["skills"]:
                        print("\nAvailable skills:")
                        for i, skill in enumerate(user_data["skills"], 1):
                            print(f"[{i}] {skill}")
                        try:
                            skill_choice = int(input("Choose skill (0 to cancel): "))
                            if skill_choice == 0:
                                continue
                            if 1 <= skill_choice <= len(user_data["skills"]):
                                skill = user_data["skills"][skill_choice - 1]
                                damage = random.randint(15, 25)  # Skills do more damage
                                monster_health -= damage
                                print(f"You used {skill} and dealt {damage} damage!")
                            else:
                                print("Invalid skill choice.")
                        except ValueError:
                            print("Invalid input.")
                    else:
                        print("You have no skills available!")
                        continue

                elif choice == "3":
                    if "Healing Potion" in user_data["inventory"]:
                        user_data["health"] = min(user_data["health"] + 30, user_data["max_health"])
                        user_data["inventory"].remove("Healing Potion")
                        print("You used a Healing Potion! Health restored.")
                        continue
                    else:
                        print("You have no Healing Potions!")
                        continue

                elif choice == "4":
                    # Calculate flee chance based on speed
                    player_speed = user_data.get("speed", 5)
                    monster_speed = monster.get("speed", 5)  # Default monster speed 5 if not set
                    base_chance = 0.4  # Base flee chance
                    speed_diff = player_speed - monster_speed
                    flee_chance = base_chance + (speed_diff * 0.05)
                    flee_chance = max(0.1, min(flee_chance, 0.9))  # Clamp between 10% and 90%

                    if random.random() < flee_chance:
                        print("You successfully fled!")
                        return
                    print("Failed to flee!")

                else:
                    print("Invalid choice!")
                    continue

                # Monster attacks if still alive
                if monster_health > 0:
                    defense_bonus = user_data.get("equipped", {}).get("armor", {}).get("effect", 0)
                    damage_taken = max(1, monster["attack"] - defense_bonus)
                    if random.random() > DODGE_CHANCE:
                        user_data["health"] -= damage_taken
                        print(f"Monster deals {damage_taken} damage!")
                    else:
                        print("You dodged the attack!")

            except Exception as e:
                print(f"Error during combat: {e}")
                continue

        if monster_health <= 0:
            if monster['name'] == "Dark Legionary Supreme Lord:Noctis, the Obsidian Fallen Eternal":
                print(f"\n{FAIL}If the sky betrays me...I will make sure it will fall...even if you defeat me...{ENDC}")
                user_data["progress"] = "endgame"
            print(f"\nYou defeated the {monster['name']}!")
            exp_gain = monster["level"] * 20
            user_data["exp"] += exp_gain
            print(f"Gained {exp_gain} experience!")
            check_achievements()

            # Increment monsters killed count
            user_data["monsters_killed"] += 1

            # Check if monster is a boss
            if monster.get("boss", False):
                print(f"Congratulations! You defeated the boss {monster['name']}!")
                # Mark dungeon as completed if in a dungeon
                for dungeon in dungeons:
                    if monster['name'] in dungeon['monsters']:
                        if dungeon['name'] not in user_data["dungeons_completed"]:
                            user_data["dungeons_completed"].append(dungeon['name'])
                            print(f"You have completed the dungeon: {dungeon['name']}!")
                            # Reward player (example: gold and exp bonus)
                            reward_gold = 500
                            reward_exp = 1000
                            user_data["gold"] += reward_gold
                            user_data["exp"] += reward_exp
                            print(f"You received {reward_gold} gold and {reward_exp} experience as a reward!")
                        break
            else:
                # Check for level up
                check_level_up()
                # Trigger boss encounter if monsters killed between 12 and 26
                if 12 <= user_data["monsters_killed"] <= 26:
                    # Find a boss in dungeons of the current area
                    bosses_in_area = []
                    for dungeon in dungeons:
                        if dungeon.get("name", "").lower() == user_data["current_area"].lower():
                            for m_name in dungeon["monsters"]:
                                m = next((mon for mon in monsters if mon["name"] == m_name and mon.get("boss", False)), None)
                                if m:
                                    bosses_in_area.append(m)
                    if bosses_in_area:
                        boss = random.choice(bosses_in_area)
                        print(f"\nA boss {boss['name']} appears!")
                        fight_monster(boss["name"])
            loot(monster)
        else:
            print("You were defeated!")

    except Exception as e:
        print(f"Error initiating combat: {e}")

def check_level_up() -> None:
    while user_data["exp"] >= EXP_TO_LEVEL * user_data["level"]:
        user_data["level"] += 1
        user_data["max_health"] += 20
        user_data["health"] = user_data["max_health"]
        user_data["attack"] += 5
        user_data["defense"] += 3
        print(f"\nLevel Up! You are now level {user_data['level']}!")
        print("Your stats have increased!")
        print(f"Health: {user_data['health']}/{user_data['max_health']}")
        print(f"Attack: {user_data['attack']}")
        print(f"Defense: {user_data['defense']}")

def show_weapon_info() -> None:
    print_header("Weapon Information")
    for weapon, stats in WEAPONS.items():
        print(f"\n{weapon}:")
        print(f"  Damage: {stats['damage']}")
        print(f"  Speed: {stats['speed']}")
        print(f"  Price: {stats['price']} gold")
        if 'effect' in stats:
            print(f"  Special Effect: {stats['effect']}")




# Enhanced pet system
# Pet evolution paths and requirements
PET_EVOLUTIONS = {
    "Cat": {
        "evolves_to": "Shadow Cat",
        "level_required": 10,
        "loyalty_required": 75,
        "materials_required": ["Shadow Essence", "Feline Spirit"]
    },
    "Dog": {
        "evolves_to": "War Hound",
        "level_required": 10,
        "loyalty_required": 80,
        "materials_required": ["Beast Fang", "Loyal Heart"]
    },
    "Dragon Hatchling": {
        "evolves_to": "Young Drake",
        "level_required": 15,
        "loyalty_required": 70,
        "materials_required": ["Dragon Scale", "Fire Essence"]
    },
    "Young Drake": {
        "evolves_to": "Adult Dragon",
        "level_required": 30,
        "loyalty_required": 90,
        "materials_required": ["Dragon Heart", "Ancient Flame", "Royal Crown"]
    },
    "Wolf Pup": {
        "evolves_to": "Dire Wolf",
        "level_required": 12,
        "loyalty_required": 75,
        "materials_required": ["Wolf Fang", "Forest Spirit"]
    },
    "Hawk": {
        "evolves_to": "Royal Eagle",
        "level_required": 10,
        "loyalty_required": 70,
        "materials_required": ["Wind Essence", "Sharp Talon"]
    },
    "Fish": {
        "evolves_to": "Koi Guardian",
        "level_required": 8,
        "loyalty_required": 65,
        "materials_required": ["Water Essence", "River Pearl"]
    },
    "Snake": {
        "evolves_to": "Venom Serpent",
        "level_required": 10,
        "loyalty_required": 60,
        "materials_required": ["Venom Sac", "Ancient Scale"]
    },
    "Phoenix Chick": {
        "evolves_to": "Adolescent Phoenix",
        "level_required": 15,
        "loyalty_required": 75,
        "materials_required": ["Eternal Flame", "Phoenix Feather"]
    },
    "Adolescent Phoenix": {
        "evolves_to": "Adult Phoenix",
        "level_required": 30,
        "loyalty_required": 85,
        "materials_required": ["Phoenix Ash", "Solar Crystal", "Rebirth Ember"]
    },
    "Battle Wolf": {
        "evolves_to": "Alpha Wolf",
        "level_required": 14,
        "loyalty_required": 80,
        "materials_required": ["Alpha Fang", "Moon Crystal"]
    },
    "Guardian Bear": {
        "evolves_to": "Ancient Bear",
        "level_required": 15,
        "loyalty_required": 75,
        "materials_required": ["Bear Essence", "Mountain Crystal"]
    },
    "Spirit Fox": {
        "evolves_to": "Nine-Tailed Fox",
        "level_required": 18,
        "loyalty_required": 85,
        "materials_required": ["Spirit Essence", "Ancient Scroll", "Fox Fire"]
    },
    "Lucky Rabbit": {
        "evolves_to": "Fortune Hare",
        "level_required": 12,
        "loyalty_required": 70,
        "materials_required": ["Fortune Clover", "Golden Carrot"]
    },
    "Mystic Owl": {
        "evolves_to": "Wisdom Owl",
        "level_required": 16,
        "loyalty_required": 75,
        "materials_required": ["Ancient Knowledge", "Moonlit Feather"]
    },
    "Shadow Panther": {
        "evolves_to": "Void Stalker",
        "level_required": 17,
        "loyalty_required": 80,
        "materials_required": ["Void Fragment", "Shadow Crystal", "Midnight Essence"]
    },
    "Thunder Eagle": {
        "evolves_to": "Storm Harbinger",
        "level_required": 20,
        "loyalty_required": 75,
        "materials_required": ["Storm Essence", "Lightning Crystal", "Royal Feather"]
    },
    "Abyssal Kraken Hatchling": {
        "evolves_to": "Kraken Juvenile",
        "level_required": 25,
        "loyalty_required": 70,
        "materials_required": ["Abyssal Ink", "Deep Sea Pearl", "Ocean Crystal"]
    },
    "Kraken Juvenile": {
        "evolves_to": "Elder Kraken",
        "level_required": 40,
        "loyalty_required": 85,
        "materials_required": ["Kraken Heart", "Abyssal Crown", "Oceanic Essence", "Legendary Sea Chart"]
    }
}

PETS = {
    "Hylit": {
        "price": 0, 
        "boost": {"intelligence": 2, "exp_gain": 5}, 
        "description": "Your fairy companion and guide",
        "element": "Nullum",
        "abilities": {"1": "Find Treasure", "3": "Weather Sense"},
        "rarity": "Unique",
        "combat_style": "Support",
        "evolution": None  # Unique companion cannot evolve
    },
    "Cat": {
        "price": 50, 
        "boost": {"attack": 2, "speed": 3}, 
        "description": "A stealthy companion that boosts attack",
        "element": "Nullum",
        "abilities": {"2": "Quick Attack", "4": "Scouting"},
        "rarity": "Common",
        "combat_style": "Agile",
        "evolution": "Shadow Cat"
    },

    # Evolved Pets
    "Shadow Cat": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"attack": 5, "speed": 7, "critical_chance": 5}, 
        "description": "A mystical feline born from shadows, swift and deadly",
        "element": "Tenebrae",
        "abilities": {"1": "Shadow Pounce", "3": "Night Vision", "5": "Stealth Strike", "7": "Soul Bond"},
        "rarity": "Rare",
        "combat_style": "Assassin",
        "evolution": None
    },
    "Dog": {
        "price": 50, 
        "boost": {"defense": 2, "loyalty": 5}, 
        "description": "A loyal friend that boosts defense",
        "element": "Nullum",
        "abilities": {"2": "Protective Stance", "5": "Intimidate"},
        "rarity": "Common",
        "combat_style": "Defensive",
        "evolution": "War Hound"
    },

    "War Hound": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"defense": 6, "loyalty": 10, "health": 15}, 
        "description": "A battle-hardened canine warrior, loyal to the death",
        "element": "Ferrum",
        "abilities": {"1": "Battle Howl", "3": "Iron Hide", "5": "Pack Tactics", "8": "Guardian's Aura"},
        "rarity": "Rare",
        "combat_style": "Tank",
        "evolution": None
    },
    "Dragon Hatchling": {
        "price": 200, 
        "boost": {"attack": 5, "health": 10}, 
        "description": "A baby dragon that boosts attack and health",
        "element": "Ignis",
        "abilities": {"1": "Flame Burst", "3": "Intimidate", "5": "Fierce Loyalty"},
        "rarity": "Epic",
        "combat_style": "Offensive",
        "evolution": "Young Drake"
    },

    "Young Drake": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"attack": 12, "health": 25, "fire_resistance": 50}, 
        "description": "A growing dragon with formidable power",
        "element": "Ignis",
        "abilities": {"1": "Fire Breath", "3": "Wing Slash", "5": "Dragon Roar", "7": "Heat Aura"},
        "rarity": "Epic",
        "combat_style": "Berserker",
        "evolution": "Adult Dragon"
    },

    "Adult Dragon": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"attack": 25, "health": 50, "fire_resistance": 100, "intimidation": 20}, 
        "description": "A mighty dragon in its prime, commanding respect and fear",
        "element": "Ignis",
        "abilities": {"1": "Inferno", "3": "Dragon Claw", "5": "Tail Sweep", "7": "Fire Storm", "10": "Dragon Soul Bond"},
        "rarity": "Legendary",
        "combat_style": "Dominator",
        "evolution": None
    },
    "Phoenix Chick": {
        "price": 200, 
        "boost": {"health": 15, "magic": 5}, 
        "description": "A magical bird that boosts health and magic",
        "element": "Fire",
        "abilities": {"1": "Healing Mist", "3": "Flame Burst", "6": "Weather Sense"},
        "rarity": "Epic",
        "combat_style": "Support",
        "evolution": "Adolescent Phoenix"
    },
    "Adolescent Phoenix": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"health": 25, "magic": 15, "fire_damage": 15}, 
        "description": "A maturing phoenix with growing flames and regenerative powers",
        "element": "Ignis",
        "abilities": {"1": "Healing Flames", "3": "Fire Shield", "5": "Phoenix Dive", "7": "Warmth Aura"},
        "rarity": "Epic",
        "combat_style": "Healer",
        "evolution": "Adult Phoenix"
    },
    "Adult Phoenix": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"health": 40, "magic": 30, "fire_damage": 25, "revival": 1}, 
        "description": "A magnificent phoenix with the power of rebirth and eternal flame",
        "element": "Ignis",
        "abilities": {"1": "Resurrection", "3": "Inferno", "5": "Cleansing Fire", "7": "Life Bond", "10": "Eternal Flame"},
        "rarity": "Legendary",
        "combat_style": "Immortal",
        "evolution": None
    },
    "Battle Wolf": {
        "price": 150, 
        "boost": {"attack": 4, "speed": 3}, 
        "description": "A fierce wolf that boosts attack and speed",
        "element": "Nullum",
        "abilities": {"1": "Quick Attack", "4": "Intimidate"},
        "rarity": "Rare",
        "combat_style": "Offensive",
        "evolution": "Alpha Wolf"
    },
    "Alpha Wolf": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"attack": 12, "speed": 8, "critical_chance": 8}, 
        "description": "A powerful pack leader with commanding presence and deadly attacks",
        "element": "Tenebrae",
        "abilities": {"1": "Savage Strike", "3": "Pack Leader", "5": "Moonlight Howl", "7": "Feral Instinct"},
        "rarity": "Epic",
        "combat_style": "Predator",
        "evolution": None
    },
    "Guardian Bear": {
        "price": 150, 
        "boost": {"defense": 4, "health": 5}, 
        "description": "A strong bear that boosts defense and health",
        "element": "Earth",
        "abilities": {"1": "Protective Stance", "3": "Stone Shield"},
        "rarity": "Rare",
        "combat_style": "Defensive",
        "evolution": "Ancient Bear"
    },
    "Ancient Bear": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"defense": 15, "health": 20, "damage_reduction": 10}, 
        "description": "A primordial bear spirit with tremendous resilience and earth power",
        "element": "Gē",
        "abilities": {"1": "Mountain's Strength", "3": "Earth Armor", "5": "Primal Roar", "7": "Nature's Guardian"},
        "rarity": "Epic",
        "combat_style": "Warden",
        "evolution": None
    },
    "Spirit Fox": {
        "price": 175, 
        "boost": {"exp_gain": 10, "magic": 3}, 
        "description": "A mystical fox that boosts experience gain and magic",
        "element": "Nullum",
        "abilities": {"2": "Find Treasure", "4": "Energy Pulse"},
        "rarity": "Rare",
        "combat_style": "Magical",
        "evolution": "Nine-Tailed Fox"
    },
    "Nine-Tailed Fox": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"exp_gain": 20, "magic": 15, "intelligence": 10}, 
        "description": "A legendary spirit fox with nine tails and immense magical power",
        "element": "Pneuma",
        "abilities": {"1": "Fox Fire", "3": "Spirit Whisper", "5": "Illusion", "7": "Soul Binding", "9": "Ancestral Wisdom"},
        "rarity": "Legendary",
        "combat_style": "Mystic",
        "evolution": None
    },
    "Lucky Rabbit": {
        "price": 100, 
        "boost": {"gold_find": 10, "luck": 5}, 
        "description": "A lucky companion that helps find more gold",
        "element": "Nullum",
        "abilities": {"1": "Find Treasure", "3": "Scavenge"},
        "rarity": "Uncommon",
        "combat_style": "Support",
        "evolution": "Fortune Hare"
    },
    "Fortune Hare": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"gold_find": 25, "luck": 15, "loot_quality": 10}, 
        "description": "A mythical hare that brings incredible fortune to its companion",
        "element": "Lux",
        "abilities": {"1": "Golden Touch", "3": "Lucky Strike", "5": "Fortune Aura", "7": "Prosperity Bond"},
        "rarity": "Epic",
        "combat_style": "Fortune",
        "evolution": None
    },
    "Mystic Owl": {
        "price": 125, 
        "boost": {"intelligence": 3, "magic": 4}, 
        "description": "An intelligent owl that boosts intelligence and magic",
        "element": "Air",
        "abilities": {"2": "Swift Movement", "5": "Energy Pulse"},
        "rarity": "Uncommon",
        "combat_style": "Magical",
        "evolution": "Wisdom Owl"
    },
    "Wisdom Owl": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"intelligence": 12, "magic": 15, "mana_regen": 10}, 
        "description": "An ancient owl with vast knowledge and powerful arcane abilities",
        "element": "Aer",
        "abilities": {"1": "Arcane Sight", "3": "Knowledge Transfer", "5": "Spell Echo", "7": "Time Dilation"},
        "rarity": "Epic",
        "combat_style": "Sage",
        "evolution": None
    },
    "Shadow Panther": {
        "price": 175, 
        "boost": {"stealth": 5, "attack": 3}, 
        "description": "A stealthy panther that boosts stealth and attack",
        "element": "Nullum",
        "abilities": {"1": "Quick Attack", "3": "Scouting"},
        "rarity": "Rare",
        "combat_style": "Agile",
        "evolution": "Void Stalker"
    },
    "Void Stalker": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"stealth": 12, "attack": 8, "critical_chance": 10}, 
        "description": "A fearsome predator that has merged with the darkness of the void",
        "element": "Tenebrae",
        "abilities": {"1": "Shadow Step", "3": "Void Strike", "5": "Dark Ambush", "7": "Dimensional Shift"},
        "rarity": "Epic",
        "combat_style": "Assassin",
        "evolution": None
    },
    "Thunder Eagle": {
        "price": 200, 
        "boost": {"speed": 5, "attack": 3}, 
        "description": "A fast eagle that boosts speed and attack",
        "element": "Lightning",
        "abilities": {"1": "Swift Movement", "3": "Shock Strike"},
        "rarity": "Rare",
        "combat_style": "Agile",
        "evolution": "Storm Harbinger"
    },
    "Storm Harbinger": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"speed": 10, "attack": 7, "lightning_damage": 15}, 
        "description": "A majestic bird of storms that controls the weather",
        "element": "Fulmen",
        "abilities": {"1": "Lightning Strike", "3": "Storm Caller", "5": "Thunder Dash", "8": "Eye of the Storm"},
        "rarity": "Epic",
        "combat_style": "Elemental",
        "evolution": None
    },
    "Abyssal Kraken Hatchling": {
        "price": 300, 
        "boost": {"attack": 10, "defense": 5}, 
        "description": "A baby kraken that boosts attack and defense",
        "element": "Water",
        "abilities": {"1": "Healing Mist", "3": "Intimidate", "5": "Energy Pulse"},
        "rarity": "Epic",
        "combat_style": "Balanced",
        "evolution": "Kraken Juvenile"
    },
    "Kraken Juvenile": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"attack": 18, "defense": 12, "water_damage": 15}, 
        "description": "A growing sea monster with mastery over ocean currents",
        "element": "Aqua",
        "abilities": {"1": "Tentacle Slam", "3": "Whirlpool", "5": "Deep Pressure", "7": "Water Manipulation"},
        "rarity": "Epic",
        "combat_style": "Controller",
        "evolution": "Elder Kraken"
    },
    "Elder Kraken": {
        "price": 0,  # Can only be obtained by evolution
        "boost": {"attack": 35, "defense": 25, "water_damage": 30, "intimidation": 20}, 
        "description": "An ancient sea titan that commands the depths of the ocean",
        "element": "Aqua",
        "abilities": {"1": "Crushing Grasp", "3": "Tsunami", "5": "Abyssal Darkness", "7": "Oceanic Fury", "10": "Leviathan's Call"},
        "rarity": "Legendary",
        "combat_style": "Destroyer",
        "evolution": None
    },
    "Small Copper Golem": {
        "price": 250, 
        "boost": {"defense": 10, "health": 5}, 
        "description": "A small golem made from copper that boosts defense",
        "element": "Earth",
        "abilities": {"1": "Protective Stance", "3": "Stone Shield"},
        "rarity": "Rare",
        "combat_style": "Defensive"
    },
    "Small Silver Golem": {
        "price": 300, 
        "boost": {"defense": 15, "health": 7}, 
        "description": "A small golem made from silver that boosts defense",
        "element": "Earth",
        "abilities": {"1": "Protective Stance", "3": "Stone Shield", "5": "Energy Pulse"},
        "rarity": "Epic",
        "combat_style": "Defensive"
    },
    "Small Titanium Golem": {
        "price": 350, 
        "boost": {"defense": 25, "health": 10}, 
        "description": "A small golem made from titanium that boosts defense",
        "element": "Earth",
        "abilities": {"1": "Protective Stance", "2": "Stone Shield", "4": "Energy Pulse", "6": "Fierce Loyalty"},
        "rarity": "Legendary",
        "combat_style": "Defensive"
    },
    # New elemental pets
    "Flame Salamander": {
        "price": 180,
        "boost": {"attack": 6, "magic": 4},
        "description": "A fiery salamander that empowers fire magic",
        "element": "Fire",
        "abilities": {"1": "Flame Burst", "3": "Energy Pulse", "5": "Fierce Loyalty"},
        "rarity": "Rare",
        "combat_style": "Magical"
    },
    "Frost Fox": {
        "price": 180,
        "boost": {"defense": 4, "magic": 6},
        "description": "A fox with fur of crystalline ice",
        "element": "Ice",
        "abilities": {"1": "Healing Mist", "3": "Swift Movement", "5": "Energy Pulse"},
        "rarity": "Rare",
        "combat_style": "Magical"
    },
    "Static Weasel": {
        "price": 180,
        "boost": {"speed": 6, "attack": 4},
        "description": "A weasel crackling with electricity",
        "element": "Lightning",
        "abilities": {"1": "Quick Attack", "3": "Shock Strike", "5": "Swift Movement"},
        "rarity": "Rare",
        "combat_style": "Agile"
    },
    "Stone Tortoise": {
        "price": 180,
        "boost": {"defense": 8, "health": 6},
        "description": "A tortoise with a shell of living stone",
        "element": "Earth",
        "abilities": {"1": "Stone Shield", "3": "Protective Stance", "5": "Energy Pulse"},
        "rarity": "Rare",
        "combat_style": "Defensive"
    },
    "Zephyr Hawk": {
        "price": 180,
        "boost": {"speed": 8, "intelligence": 4},
        "description": "A hawk that rides the wind currents",
        "element": "Air",
        "abilities": {"1": "Swift Movement", "3": "Scouting", "5": "Weather Sense"},
        "rarity": "Rare",
        "combat_style": "Agile"
    },
    "Hellstone Golem": {
        "price": 600, 
        "boost": {"defense": 90, "attack": 20}, 
        "description": "A powerful golem made from hellstone that boosts defense",
        "element": "Fire",
        "abilities": {"1": "Stone Shield", "2": "Flame Burst", "4": "Fierce Loyalty", "6": "Energy Pulse"},
        "rarity": "Legendary",
        "combat_style": "Defensive"
    },
    "Abyssal Obsidian Golem": {
        "price": 1000, 
        "boost": {"defense": 150, "health": 50}, 
        "description": "A powerful golem made from obsidian extracted from the abyss",
        "element": "Earth",
        "abilities": {"1": "Stone Shield", "2": "Protective Stance", "3": "Energy Pulse", "5": "Intimidate"},
        "rarity": "Mythic",
        "combat_style": "Defensive"
    },
    "Abyssal Diamond Golem": {
        "price": 1500, 
        "boost": {"defense": 200, "attack": 40, "health": 100}, 
        "description": "A powerful golem made from diamond extracted from the abyssal caves",
        "element": "Earth",
        "abilities": {"1": "Stone Shield", "2": "Protective Stance", "3": "Energy Pulse", "4": "Intimidate", "5": "Fierce Loyalty"},
        "rarity": "Mythic",
        "combat_style": "Balanced"
    }
}


def show_professions() -> None:
    print_header("Professions")

    if user_data["has_chosen_profession"]:
        prof = user_data["profession"]
        print(f"{CYAN}Your current profession: {BOLD}{prof}{ENDC}")

        if prof in PROFESSIONS:
            profession_info = PROFESSIONS[prof]

            # Basic information
            print(f"\n{YELLOW}Special Ability: {ENDC}{profession_info['special_ability']}")
            print(f"{LIGHTGRAY}{profession_info['ability_description']}{ENDC}")

            # Bonuses
            print(f"\n{YELLOW}Profession bonuses:{ENDC}")
            print(f"Gathering bonus for: {', '.join(profession_info['gather_bonus'])}")
            print(f"Crafting bonus for: {', '.join(profession_info['craft_bonus'])}")

            # Passive bonuses
            print(f"\n{YELLOW}Passive Bonuses:{ENDC}")
            for stat, value in profession_info['passive_bonus'].items():
                print(f"  {stat.replace('_', ' ').title()}: +{value}")

            # Level bonuses
            print(f"\n{YELLOW}Level Milestone Bonuses:{ENDC}")
            for level, bonus in profession_info['level_bonuses'].items():
                if user_data["level"] >= level:
                    print(f"  Level {level}: {OKGREEN}✓{ENDC} {bonus}")
                else:
                    print(f"  Level {level}: {YELLOW}⊗{ENDC} {bonus} (Locked)")

            # Weather bonuses if applicable
            if 'weather_bonuses' in profession_info:
                print(f"\n{YELLOW}Weather Bonuses:{ENDC}")
                current_weather = user_data.get("current_weather", "Sunny")
                for weather, bonus in profession_info['weather_bonuses'].items():
                    if weather == current_weather:
                        print(f"  {weather}: {OKGREEN}✓{ENDC} {bonus} (Active)")
                    else:
                        print(f"  {weather}: {bonus}")

            # Season bonuses if applicable
            if 'season_bonuses' in profession_info:
                print(f"\n{YELLOW}Seasonal Bonuses:{ENDC}")
                current_season = user_data.get("current_season", "Summer")
                for season, bonus in profession_info['season_bonuses'].items():
                    if season == current_season:
                        print(f"  {season}: {OKGREEN}✓{ENDC} {bonus} (Active)")
                    else:
                        print(f"  {season}: {bonus}")

            # Profession change option
            change = input("\nDo you want to change your profession? (y/n): ").lower()
            if change == 'y':
                user_data["has_chosen_profession"] = False
                print(f"You have abandoned your profession as a {prof}.")
                show_professions()  # Recursive call to show profession selection
            return

    # Display available professions if user hasn't chosen one or wants to change
    print(f"{YELLOW}Available Professions:{ENDC}")

    # Group professions by type
    traditional = []
    specialized = []

    for prof, info in PROFESSIONS.items():
        if prof in ["Miner", "Herbalist", "Blacksmith", "Alchemist", "Hunter", "Woodcutter", "Fisher", "Archaeologist", "Enchanter"]:
            traditional.append(prof)
        else:
            specialized.append(prof)

    # Display traditional professions
    print(f"\n{HEADER}Traditional Professions:{ENDC}")
    for prof in traditional:
        info = PROFESSIONS[prof]
        print(f"{CYAN}{prof}:{ENDC} {info['ability_description']}")
        print(f"  Special Ability: {info['special_ability']}")
        print(f"  Gathering: {', '.join(info['gather_bonus'][:3])}{'...' if len(info['gather_bonus']) > 3 else ''}")

    # Display specialized professions
    print(f"\n{HEADER}Specialized Professions:{ENDC}")
    for prof in specialized:
        info = PROFESSIONS[prof]
        print(f"{MAGENTA}{prof}:{ENDC} {info['ability_description']}")
        print(f"  Special Ability: {info['special_ability']}")
        print(f"  Gathering: {', '.join(info['gather_bonus'][:3])}{'...' if len(info['gather_bonus']) > 3 else ''}")

    # Let player choose a profession
    print(f"\n{YELLOW}To see detailed information about a profession, type its name.{ENDC}")
    print(f"{YELLOW}To select a profession, type 'choose <profession name>'.{ENDC}")
    print(f"{YELLOW}To exit, press Enter.{ENDC}")

    choice = input("\nCommand: ").strip()

    if not choice:
        return

    if choice.lower().startswith("choose "):
        prof_choice = choice[7:].strip().capitalize()
        if prof_choice in PROFESSIONS:
            user_data["profession"] = prof_choice
            user_data["has_chosen_profession"] = True
            print(f"{SUCCESS}You are now a {prof_choice}.{ENDC}")

            # Show special message for new profession types
            if prof_choice == "Farmer":
                print(f"{CYAN}As a Farmer, you gain special bonuses during different seasons and weather conditions.{ENDC}")
                print(f"{CYAN}You'll excel at growing crops and crafting food items.{ENDC}")
            elif prof_choice == "Weather Mage":
                print(f"{CYAN}As a Weather Mage, you can harness the power of weather for combat and resource gathering.{ENDC}")
                print(f"{CYAN}Your abilities will vary based on current weather conditions.{ENDC}")
            elif prof_choice == "Artifact Hunter":
                print(f"{CYAN}As an Artifact Hunter, you specialize in finding, restoring, and using powerful artifacts.{ENDC}")
                print(f"{CYAN}You'll gain extra power when using complete artifact sets.{ENDC}")
            elif prof_choice == "Monster Tamer":
                print(f"{CYAN}As a Monster Tamer, you can interact with monsters in unique ways.{ENDC}")
                print(f"{CYAN}At higher levels, you may even be able to tame certain monsters as companions.{ENDC}")
        else:
            print(f"{FAIL}Invalid profession choice.{ENDC}")
    else:
        # Show detailed info about a profession
        prof_choice = choice.capitalize()
        if prof_choice in PROFESSIONS:
            info = PROFESSIONS[prof_choice]
            print(f"\n{HEADER}Detailed Information: {prof_choice}{ENDC}")
            print(f"{YELLOW}Special Ability:{ENDC} {info['special_ability']}")
            print(f"{LIGHTGRAY}{info['ability_description']}{ENDC}")

            print(f"\n{YELLOW}Gathering Bonuses:{ENDC}")
            for resource in info['gather_bonus']:
                print(f"  • {resource}")

            print(f"\n{YELLOW}Crafting Bonuses:{ENDC}")
            for category in info['craft_bonus']:
                print(f"  • {category}")

            print(f"\n{YELLOW}Passive Bonuses:{ENDC}")
            for stat, value in info['passive_bonus'].items():
                print(f"  • {stat.replace('_', ' ').title()}: +{value}")

            print(f"\n{YELLOW}Level Milestone Bonuses:{ENDC}")
            for level, bonus in info['level_bonuses'].items():
                print(f"  • Level {level}: {bonus}")

            if 'weather_bonuses' in info:
                print(f"\n{YELLOW}Weather Bonuses:{ENDC}")
                for weather, bonus in info['weather_bonuses'].items():
                    print(f"  • {weather}: {bonus}")

            if 'season_bonuses' in info:
                print(f"\n{YELLOW}Seasonal Bonuses:{ENDC}")
                for season, bonus in info['season_bonuses'].items():
                    print(f"  • {season}: {bonus}")

            # Option to choose this profession
            select = input(f"\nDo you want to become a {prof_choice}? (y/n): ").lower()
            if select == 'y':
                user_data["profession"] = prof_choice
                user_data["has_chosen_profession"] = True
                print(f"{SUCCESS}You are now a {prof_choice}.{ENDC}")
            else:
                show_professions()  # Go back to profession selection
        else:
            print(f"{FAIL}Invalid profession name.{ENDC}")

def check_location() -> None:
    print_header("Location Information")
    current = user_data["current_area"]

    print("Current Location:", current)
    if current in LOCATIONS:
        loc_info = LOCATIONS[current]
        print(f"\nType: {loc_info['type']}")
        print(f"Description: {loc_info['description']}")
        if 'shops' in loc_info:
            print(f"Available Shops: {', '.join(loc_info['shops'])}")
        if 'monsters' in loc_info:
            print(f"Local Monsters: {', '.join(loc_info['monsters'])}")

    print("\nAll Available Locations:")
    for name, info in LOCATIONS.items():
        print(f"\n{name}:")
        print(f"  Type: {info['type']}")
        print(f"  Description: {info['description']}")

    print("\nAvailable Dungeons:")
    for dungeon in dungeons:
        print(f"\n{dungeon['name']}:")
        print(f"  Monsters: {', '.join(dungeon['monsters'])}")
        print(f"  Possible Loot: {', '.join(dungeon['loot'])}")

def search_resources() -> None:
    print_header("Resource Search")
    search_type = random.choice(["monster", "material"])

    if search_type == "monster":
        # Get basic area monsters
        area_monsters = [m for m in monsters if m["name"] in LOCATIONS.get(user_data["current_area"], {}).get("monsters", [])]

        # Add weather-dependent monsters based on current weather
        current_weather = user_data.get("current_weather", "Sunny")
        weather_monsters = [m for m in monsters if m.get("weather") == current_weather]

        # Add seasonal monsters based on current season
        current_season = user_data.get("current_season", "Summer")
        season_monsters = [m for m in monsters if m.get("season") == current_season]

        # Combine all possible monster types
        all_possible_monsters = area_monsters.copy()

        # 30% chance for weather-specific monster if available
        if weather_monsters and random.random() < 0.3:
            all_possible_monsters.extend(weather_monsters)

        # 20% chance for season-specific monster if available
        if season_monsters and random.random() < 0.2:
            all_possible_monsters.extend(season_monsters)

        if all_possible_monsters:
            monster = random.choice(all_possible_monsters)
            print(f"You found a {monster['name']}!")
            print(f"Level: {monster['level']}")
            print(f"Health: {monster['health']}")
            print(f"Attack: {monster['attack']}")
            print(f"Possible drops: {', '.join(monster['drops'])}")

            # Show special information about weather or seasonal monsters
            if "weather" in monster:
                print(f"{CYAN}This is a {monster['weather']} weather monster! It appears during {monster['weather']} conditions.{ENDC}")
            if "season" in monster:
                print(f"{MAGENTA}This is a {monster['season']} seasonal monster! It thrives during the {monster['season']} season.{ENDC}")

        else:
            print("No monsters found in this area.")
    else:
        available_materials = [name for name, info in MATERIALS.items() 
                             if user_data["current_area"] in info["areas"]]
        if available_materials:
            material = random.choice(available_materials)
            tool_required = MATERIALS[material]["tool_required"]
            print(f"You found {material}!")
            if tool_required:
                print(f"Tool required: {tool_required}")
            if tool_required in user_data["tools"]:
                print("You have the right tool to gather this!")
            elif tool_required:
                print("You need the right tool to gather this.")
        else:
            print("No materials found in this area.")

def save_prompt() -> None:
    print_header("Save Game")
    show_save_slots()
    try:
        slot = int(input("\nEnter save slot number (1-5): "))
        if 1 <= slot <= 5:
            save_game(slot)
        else:
            print("Invalid slot number. Choose between 1 and 5.")
    except ValueError:
        print("Invalid input. Please enter a number.")

def load_prompt() -> None:
    print_header("Load Game")
    show_save_slots()
    try:
        slot = int(input("\nEnter save slot number to load: "))
        load_game(slot)
    except ValueError:
        print("Invalid input. Please enter a number.")

def delete_save_prompt() -> None:
    print_header("Delete Save")
    show_save_slots()
    try:
        slot = int(input("\nEnter save slot number to delete: "))
        if input(f"Are you sure you want to delete save slot {slot}? (y/n): ").lower() == 'y':
            delete_save(slot)
    except ValueError:
        print("Invalid input. Please enter a number.")

def talk_to_npc(npc_name: Optional[str] = None) -> None:
    if not npc_name:
        print_header("Available NPCs")
        npcs_here = [name for name, npc in NPCS.items() if npc["location"] == user_data["current_area"]]
        if npcs_here:
            print(f"NPCs in {user_data['current_area']}:")
            for name in npcs_here:
                print(f"- {name}")
        else:
            print(f"No NPCs found in {user_data['current_area']}")
        return

    try:
        npc = next((npc for name, npc in NPCS.items() if name.lower() == npc_name.lower()), None)
        if not npc:
            print(f"{FAIL}No NPC named '{npc_name}' found.{ENDC}")
            return

        if npc["location"] != user_data["current_area"]:
            print(f"{WARNING}This NPC is in {npc['location']}. You need to travel there first!{ENDC}")
            return

        print_header(f"Talking to {npc_name}")
        print_animated(npc["dialogues"]["greeting"], CYAN)

        while True:
            print(f"\n{BOLD}Options:{ENDC}")
            options = []

            if "quests" in npc:
                options.append("1. Ask about quests")
            if "story" in npc["dialogues"]:
                options.append("2. Listen to story")
            if "shop" in npc:
                options.append("3. Trade/Shop")
            if "additional" in npc["dialogues"]:
                options.append("4. Ask for advice")
            options.append("5. End conversation")

            for option in options:
                print(option)

            choice = input(f"\n{YELLOW}What would you like to do? {ENDC}")

            if choice == "1" and "quests" in npc:
                print_animated(npc["dialogues"].get("quest", "No quests available."), YELLOW)
                available_quests = [q for q in QUESTS if q["name"] in npc["quests"] 
                                  and q["id"] not in user_data["completed_quests"]
                                  and q not in user_data["active_quests"]]

                if available_quests:
                    for quest in available_quests:
                        print(f"\n{CYAN}Quest: {quest['name']}{ENDC}")
                        print(f"Description: {quest['description']}")
                        print(f"Reward: {quest['reward']['gold']} gold, {quest['reward']['exp']} exp")
                        if quest.get('story', False):
                            print(f"{MAGENTA}[Story Quest]{ENDC}")
                        if input(f"{YELLOW}Accept quest? (y/n): {ENDC}").lower() == 'y':
                            user_data["active_quests"].append(quest)
                            print(f"{OKGREEN}Quest accepted!{ENDC}")
                else:
                    print(f"{YELLOW}No available quests at the moment.{ENDC}")

            elif choice == "2" and "story" in npc["dialogues"]:
                if isinstance(npc["dialogues"]["story"], dict):
                    for part, text in npc["dialogues"]["story"].items():
                        print_animated(f"\n{MAGENTA}{part.capitalize()}:{ENDC}", delay=0.02)
                        print_animated(text, CYAN, delay=0.03)
                        input(f"\n{YELLOW}Press Enter to continue...{ENDC}")
                else:
                    print_animated(npc["dialogues"]["story"], CYAN)

            elif choice == "3" and "shop" in npc:
                print(f"\n{BOLD}Available items:{ENDC}")
                for item in npc["shop"]:
                    price = WEAPONS[item]["price"] if item in WEAPONS else MARKET_PRICES.get(item, 0)
                    print(f"{item}: {price} gold")

                while True:
                    item = input(f"\n{YELLOW}What would you like to buy? (or press Enter to cancel): {ENDC}").strip()
                    if not item:
                        break

                    if item in npc["shop"]:
                        price = WEAPONS[item]["price"] if item in WEAPONS else MARKET_PRICES.get(item, 0)
                        if user_data["gold"] >= price:
                            user_data["gold"] -= price
                            user_data["inventory"].append(item)
                            print(f"{OKGREEN}Bought {item}!{ENDC}")
                        else:
                            print(f"{FAIL}Not enough gold!{ENDC}")
                    else:
                        print(f"{FAIL}Item not available.{ENDC}")

            elif choice == "4" and "additional" in npc["dialogues"]:
                advice = random.choice(npc["dialogues"]["additional"])
                print_animated(advice, CYAN)

            elif choice == "5" or choice.lower() == "exit":
                print_animated("Farewell!", CYAN)
                break

            else:
                print(f"{FAIL}Invalid choice.{ENDC}")

    except Exception as e:
        print(f"{FAIL}Error in conversation: {e}{ENDC}")

def list_npcs() -> None:
    print_header("NPCs in Current Area")
    current_area = user_data["current_area"]
    found = False

    for npc_name, npc in NPCS.items():
        if npc["location"] == current_area:
            found = True
            print(f"\n{npc_name}")
            print(f"Location: {npc['location']}")
            if "quests" in npc:
                print(f"Available Quests: {len(npc['quests'])}")
            if "shop" in npc:
                print("Has shop: Yes")

    if not found:
        print(f"No NPCs found in {current_area}")

def show_storyline() -> None:
    print_header("Main Storyline")
    current_chapter = None

    # Count completed main chapters and check for post-game access
    completed_main_chapters = 0
    for chapter_name, chapter in STORYLINE.items():
        # Skip post-game chapters in the count
        if chapter.get("post_game", False):
            continue

        completed_quests = all(
            any(q["name"] == quest_name and q["id"] in user_data["completed_quests"] 
                for q in QUESTS)
            for quest_name in chapter["quest_line"]
        )

        if completed_quests:
            completed_main_chapters += 1

    # Check if player has unlocked post-game content
    post_game_unlocked = completed_main_chapters >= 6  # After completing 6 main chapters
    if post_game_unlocked and not user_data.get("post_game_unlocked", False):
        user_data["post_game_unlocked"] = True
        print_colored("✧・゚: *✧・゚:* CONGRATULATIONS *:・゚✧*:・゚✧", CYAN)
        print_colored("You have completed the main storyline and unlocked post-game content!", OKGREEN)
        print_colored("New adventures and challenges await in the post-game chapters!", OKGREEN)
        print_colored("Type '/postgame' to access special post-game content.", MAGENTA)

    # Display chapters based on story progression
    for chapter_name, chapter in STORYLINE.items():
        # Skip post-game chapters if not unlocked
        if chapter.get("post_game", False) and not user_data.get("post_game_unlocked", False):
            continue

        if user_data["level"] >= chapter["required_level"]:
            completed_quests = all(
                any(q["name"] == quest_name and q["id"] in user_data["completed_quests"] 
                    for q in QUESTS)
                for quest_name in chapter["quest_line"]
            )

            if completed_quests:
                status = f"{OKGREEN}✓ Completed{ENDC}"
            elif current_chapter is None:
                status = f"{YELLOW}► In Progress{ENDC}"
            else:
                status = f"{FAIL}- Locked{ENDC}"

            # Add special formatting for post-game chapters
            if chapter.get("post_game", False):
                print(f"\n{BOLD}{MAGENTA}⚝ {chapter['title']} [{status}] ⚝{ENDC}")
            else:
                print(f"\n{BOLD}{chapter['title']} [{status}]{ENDC}")

            print(f"Required Level: {chapter['required_level']}")
            print(f"Description: {chapter['description']}")

            if not completed_quests and current_chapter is None:
                current_chapter = chapter_name
                print(f"\n{UNDERLINE}Current quest line:{ENDC}")
                for quest_name in chapter["quest_line"]:
                    quest = next((q for q in QUESTS if q["name"] == quest_name), None)
                    if quest:
                        quest_status = f"{OKGREEN}✓{ENDC}" if quest["id"] in user_data["completed_quests"] else f"{YELLOW}►{ENDC}"
                        print(f"  {quest_status} {quest_name}")

def show_postgame_content() -> None:
    """Display post-game exclusive content and challenges"""
    if not user_data.get("post_game_unlocked", False):
        print_colored("You have not yet unlocked post-game content.", FAIL)
        print_colored("Complete the main storyline first!", YELLOW)
        return

    print_header("POST-GAME CONTENT")
    print_colored("Welcome to the post-game adventures!", MAGENTA)

    # Show available post-game activities
    print("\n" + BOLD + "Available Activities:" + ENDC)

    # Dimensional Rifts
    print(f"\n{CYAN}1. Dimensional Rifts{ENDC}")
    print("  Explore alternate realities with unique challenges and rewards.")
    print("  Requirements: Level 35+")

    # Divine Trials
    print(f"\n{CYAN}2. Divine Trials{ENDC}")
    print("  Face the challenges of the gods to earn divine artifacts.")
    print("  Requirements: Level 40+")

    # Legendary Hunts
    print(f"\n{CYAN}3. Legendary Hunts{ENDC}")
    print("  Track down and defeat legendary monsters for rare loot.")
    print("  Requirements: Level 30+")

    # Time Trials
    print(f"\n{CYAN}4. Time Trials{ENDC}")
    print("  Complete dungeons against the clock for special rewards.")
    print("  Requirements: Complete any 3 dungeons")

    # New Game+
    print(f"\n{CYAN}5. New Game+{ENDC}")
    print("  Start a new journey with your current level and equipment.")
    print("  Requirements: Level 50+")

    # Endless Tower
    print(f"\n{CYAN}6. Endless Tower{ENDC}")
    print("  Climb the infinite tower with increasingly difficult challenges.")
    print("  Requirements: Level 35+")

    choice = input("\nEnter a number to learn more, or type 'back' to return: ")

    if choice == "1" and user_data["level"] >= 35:
        dimensional_rifts()
    elif choice == "2" and user_data["level"] >= 40:
        divine_trials()
    elif choice == "3" and user_data["level"] >= 30:
        legendary_hunts()
    elif choice == "4" and len(user_data.get("dungeons_completed", [])) >= 3:
        time_trials()
    elif choice == "5" and user_data["level"] >= 50:
        new_game_plus()
    elif choice == "6" and user_data["level"] >= 35:
        endless_tower()
    elif choice.lower() == "back":
        return
    else:
        print_colored("You don't meet the requirements or made an invalid choice.", WARNING)




# Define the main game function
def main_game() -> None:
    """Main game function that runs the game loop."""
    print("\n")  # Add a blank line for spacing

    # Direct terminal output for guaranteed color display
    sys.stdout.write("\033[0m")  # Reset all colors first
    sys.stdout.flush()
    sys.stdout.write(f"{BOLD}{CYAN}{'='*60}\n")
    sys.stdout.write(f"{BOLD}{CYAN}{' '*14}Welcome to Legacies of our Legends RPG!{' '*14}\n")
    sys.stdout.write(f"{BOLD}{CYAN}{'='*60}\n")
    sys.stdout.write(f"{GREEN}{'-'*68}\n")
    sys.stdout.write(f"{BOLD}{GREEN}Type '/help' for commands or '/new' to create a character.\n")
    sys.stdout.write(f"{GREEN}{'-'*68}\n")
    sys.stdout.write(ENDC)  # Reset colors at the end
    sys.stdout.flush()

    # Auto-save interval in seconds
    AUTO_SAVE_INTERVAL = 300  # 5 minutes
    last_save = time.time()

    while True:
        try:
            # Auto-save check
            if time.time() - last_save > AUTO_SAVE_INTERVAL:
                auto_save()
                last_save = time.time()

            # Print prompt with consistent color handling
            sys.stdout.write(f"\n{YELLOW}>> {ENDC}")
            sys.stdout.flush()
            command = input().strip()
            # Do not convert to lowercase to preserve command arguments
            handle_command(command.lower())

            # Auto-save after important actions (check command prefix only)
            if command.lower().startswith(("/fight", "/dungeon", "/equip", "/travel")):
                auto_save()
                last_save = time.time()
        except Exception as e:
            print(f"{FAIL}Error: {e}{ENDC}")
            print_animated("Type '/help' for available commands.", YELLOW)

# New system implementations

def process_skills_command(command_parts: List[str]) -> None:
    """Process the /skills command"""
    clear_screen()
    print_header("Character Skills")

    if "skills" not in user_data:
        user_data["skills"] = {}

    skills = user_data["skills"]
    if not skills:
        print_colored("You haven't learned any skills yet.", YELLOW)
        print_colored("Learn skills through training, reading books, or quest rewards.", CYAN)
    else:
        for skill, level in skills.items():
            print_colored(f"{skill.replace('_', ' ').title()}: Level {level}", GREEN)

            # Show skill benefits
            if skill == "swordsmanship" and level >= 5:
                print_colored("  → Enhanced sword attack damage", CYAN)
            elif skill == "magic_theory" and level >= 3:
                print_colored("  → Reduced spell mana costs", CYAN)
            elif skill == "alchemy" and level >= 4:
                print_colored("  → Create better potions", CYAN)
            elif skill == "archery" and level >= 6:
                print_colored("  → Improved bow accuracy", CYAN)

    input("\nPress Enter to continue...")

def display_constructs() -> None:
    """Display all mechanical constructs owned by the player"""
    clear_screen()
    print_header("Mechanical Constructs")

    # Initialize mechanical systems if needed
    if "constructs" not in user_data:
        user_data["constructs"] = {}
    if "blueprints" not in user_data:
        user_data["blueprints"] = ["basic_automaton"]  # Start with one blueprint

    constructs = user_data["constructs"]
    if not constructs:
        print_colored("You don't have any mechanical constructs yet.", YELLOW)
        print_colored("Learn blueprints and gather materials to create constructs!", CYAN)
    else:
        for construct_id, construct_data in constructs.items():
            print_colored(f"\n{construct_id.replace('_', ' ').title()}", GREEN)
            print_colored(f"  Status: {construct_data.get('status', 'Active')}", CYAN)
            print_colored(f"  Durability: {construct_data.get('durability', 100)}/100", CYAN)
            if construct_data.get('abilities'):
                print_colored(f"  Abilities: {', '.join(construct_data['abilities'])}", MAGENTA)

    print_colored("\nUse /blueprints to view available construct blueprints.", CYAN)
    print_colored("Use /craft_construct [construct_id] to create a new construct.", CYAN)

    input("\nPress Enter to continue...")

def display_blueprints() -> None:
    """Display all known mechanical construct blueprints"""
    clear_screen()
    print_header("Construct Blueprints")

    # Initialize mechanical systems if needed
    if "blueprints" not in user_data:
        user_data["blueprints"] = ["basic_automaton"]

    # Define available blueprints
    blueprint_info = {
        "basic_automaton": {
            "name": "Basic Automaton",
            "description": "A simple mechanical helper that can assist with basic tasks",
            "materials": {"Iron": 5, "Gears": 3, "Springs": 2},
            "abilities": ["Light Work", "Basic Repair"]
        },
        "combat_golem": {
            "name": "Combat Golem",
            "description": "A sturdy mechanical warrior for battle assistance",
            "materials": {"Steel": 8, "Gears": 5, "Weapons Parts": 3, "Magic Core": 1},
            "abilities": ["Combat Assistance", "Shield Wall"]
        },
        "mining_drone": {
            "name": "Mining Drone",
            "description": "An automated mining assistant for resource gathering",
            "materials": {"Iron": 6, "Diamond Bits": 2, "Gears": 4, "Power Crystal": 1},
            "abilities": ["Auto Mining", "Ore Detection"]
        }
    }

    blueprints = user_data["blueprints"]
    if not blueprints:
        print_colored("You don't know any construct blueprints yet.", YELLOW)
    else:
        for blueprint_id in blueprints:
            if blueprint_id in blueprint_info:
                info = blueprint_info[blueprint_id]
                print_colored(f"\n{info['name']}", GREEN)
                print_colored(f"  {info['description']}", CYAN)
                print_colored("  Required Materials:", YELLOW)
                for material, amount in info['materials'].items():
                    print_colored(f"    - {material}: {amount}", WHITE)
                print_colored(f"  Abilities: {', '.join(info['abilities'])}", MAGENTA)

    print_colored("\nLearn more blueprints by finding and reading mechanical manuals.", CYAN)
    print_colored("Use /craft_construct [construct_id] to create a construct.", CYAN)

    input("\nPress Enter to continue...")

def handle_construct_command(command_parts: List[str]) -> None:
    """Process the craft construct command"""
    if len(command_parts) < 2:
        print_colored("Usage: /craft_construct [construct_id]", RED)
        print_colored("Use /blueprints to see available constructs.", CYAN)
        return

    construct_id = command_parts[1].lower()

    # Initialize systems if needed
    if "constructs" not in user_data:
        user_data["constructs"] = {}
    if "blueprints" not in user_data:
        user_data["blueprints"] = ["basic_automaton"]
    if "inventory" not in user_data:
        user_data["inventory"] = {}

    # Blueprint definitions
    blueprint_info = {
        "basic_automaton": {
            "name": "Basic Automaton",
            "materials": {"Iron": 5, "Gears": 3, "Springs": 2},
            "abilities": ["Light Work", "Basic Repair"]
        },
        "combat_golem": {
            "name": "Combat Golem", 
            "materials": {"Steel": 8, "Gears": 5, "Weapons Parts": 3, "Magic Core": 1},
            "abilities": ["Combat Assistance", "Shield Wall"]
        },
        "mining_drone": {
            "name": "Mining Drone",
            "materials": {"Iron": 6, "Diamond Bits": 2, "Gears": 4, "Power Crystal": 1},
            "abilities": ["Auto Mining", "Ore Detection"]
        }
    }

    # Check if blueprint is known
    if construct_id not in user_data["blueprints"]:
        print_colored(f"You don't know the blueprint for {construct_id}.", RED)
        return

    # Check if blueprint exists
    if construct_id not in blueprint_info:
        print_colored(f"Invalid construct ID: {construct_id}", RED)
        return

    blueprint = blueprint_info[construct_id]
    inventory = user_data["inventory"]

    # Check materials
    missing_materials = []
    for material, needed in blueprint["materials"].items():
        available = inventory.get(material, 0)
        if available < needed:
            missing_materials.append(f"{material} (need {needed}, have {available})")

    if missing_materials:
        print_colored("Missing materials:", RED)
        for material in missing_materials:
            print_colored(f"  - {material}", RED)
        return

    # Consume materials
    for material, needed in blueprint["materials"].items():
        user_data["inventory"][material] -= needed
        if user_data["inventory"][material] <= 0:
            del user_data["inventory"][material]

    # Create construct
    construct_name = f"{blueprint['name']} #{len(user_data['constructs']) + 1}"
    user_data["constructs"][construct_name] = {
        "type": construct_id,
        "status": "Active",
        "durability": 100,
        "abilities": blueprint["abilities"]
    }

    print_colored(f"Successfully crafted {construct_name}!", GREEN)
    print_colored(f"Abilities: {', '.join(blueprint['abilities'])}", CYAN)

    input("\nPress Enter to continue...")

def process_ability_command(command_parts: List[str]) -> None:
    """Process the /ability command"""
    clear_screen()
    print_header("Special Abilities")

    if "abilities" not in user_data:
        user_data["abilities"] = []

    abilities = user_data["abilities"]
    if not abilities:
        print_colored("You haven't learned any special abilities yet.", YELLOW)
        print_colored("Gain abilities through quests, training, or magical items.", CYAN)
    else:
        for ability in abilities:
            print_colored(f"• {ability.replace('_', ' ').title()}", GREEN)

            # Show ability descriptions
            if ability == "fireball":
                print_colored("  → Cast powerful fire magic in combat", CYAN)
            elif ability == "heal":
                print_colored("  → Restore health to yourself or allies", CYAN)
            elif ability == "stealth":
                print_colored("  → Become invisible for short periods", CYAN)
            elif ability == "teleport":
                print_colored("  → Instantly travel short distances", CYAN)

    input("\nPress Enter to continue...")

def show_knowledge() -> None:
    """Display player's knowledge levels"""
    clear_screen()
    print_header("Knowledge Levels")

    if "knowledge" not in user_data:
        user_data["knowledge"] = {}

    knowledge = user_data["knowledge"]
    if not knowledge:
        print_colored("You haven't acquired any specialized knowledge yet.", YELLOW)
        print_colored("Increase your knowledge by reading books or studying artifacts.", CYAN)
        return

    knowledge_descriptions = {
        "alchemy": "Knowledge of creating potions and transmuting materials",
        "arcane": "Understanding of magical theories and spell structures", 
        "history": "Knowledge of past events and ancient civilizations",
        "nature": "Understanding of plants, animals, and natural phenomena",
        "engineering": "Knowledge of mechanical systems and construction"
    }

    for knowledge_type, level in knowledge.items():
        description = knowledge_descriptions.get(knowledge_type, "Specialized knowledge")
        print_colored(f"{knowledge_type.capitalize()}: Level {level}", GREEN)
        print_colored(f"  {description}", CYAN)

        # Show level benefits
        if level >= 5:
            print_colored("  → Advanced understanding unlocked", MAGENTA)
        elif level >= 3:
            print_colored("  → Intermediate knowledge gained", YELLOW)
        print()

    print_colored("\nIncrease your knowledge by reading books or studying artifacts.", YELLOW)

def show_active_buffs() -> None:
    """Display active buffs and their effects"""
    clear_screen()
    print_header("Active Buffs")

    if "active_buffs" not in user_data or not user_data["active_buffs"]:
        print_colored("You don't have any active buffs.", YELLOW)
        return

    buff_descriptions = {
        "strength": "Increased physical damage",
        "defense": "Reduced incoming damage", 
        "speed": "Faster movement and reactions",
        "magic_power": "Enhanced spell effectiveness",
        "regeneration": "Gradual health recovery",
        "luck": "Better chance outcomes"
    }

    for buff, duration in user_data["active_buffs"].items():
        description = buff_descriptions.get(buff, "Unknown effect")
        print_colored(f"{buff.capitalize()}: {description}", GREEN)
        print_colored(f"  Remaining battles: {duration}", CYAN)
        print()

    print_colored("\nBuffs gradually wear off after battles.", YELLOW)

def show_elemental_resistance() -> None:
    """Display elemental resistances"""
    clear_screen()
    print_header("Elemental Resistances")

    if "elemental_resistance" not in user_data:
        user_data["elemental_resistance"] = {"fire": 0, "water": 0, "earth": 0, "air": 0, "dark": 0, "light": 0}

    resistances = user_data["elemental_resistance"]
    if all(r == 0 for r in resistances.values()):
        print_colored("You don't have any elemental resistances yet.", YELLOW)
        print_colored("Increase resistances through equipment, skills, and knowledge.", CYAN)
        return

    for element, resistance in resistances.items():
        color = CYAN
        if resistance >= 20:
            color = GREEN
        elif resistance <= -10:
            color = RED

        print_colored(f"{element.capitalize()}: {resistance}%", color)

    print_colored("\nIncrease resistances through equipment, skills, and knowledge.", YELLOW)

def show_one_time_spells() -> None:
    """Display one-time spells available for use"""
    clear_screen()
    print_header("Spell Scrolls & Consumables")

    if "consumables" not in user_data or not user_data["consumables"]:
        print(f"{YELLOW}You don't have any spell scrolls or magical consumables.{ENDC}")
        return

    for spell, count in user_data["consumables"].items():
        # Define ONE_TIME_SPELLS locally if not available
        ONE_TIME_SPELLS = {
            "Healing Potion": {"rarity": "Common", "effect": "heal"},
            "Mana Potion": {"rarity": "Common", "effect": "mana_restore"},
            "Strength Scroll": {"rarity": "Uncommon", "effect": "strength_boost"},
            "Shield Scroll": {"rarity": "Rare", "effect": "defense_boost"}
        }
        if spell in ONE_TIME_SPELLS:
            spell_data = ONE_TIME_SPELLS[spell]
            rarity_color = WHITE
            if spell_data["rarity"] == "Uncommon":
                rarity_color = GREEN
            elif spell_data["rarity"] == "Rare":
                rarity_color = BLUE
            elif spell_data["rarity"] == "Epic":
                rarity_color = MAGENTA
            elif spell_data["rarity"] == "Legendary":
                rarity_color = YELLOW

            print(f"{spell} {rarity_color}({spell_data['rarity']}){ENDC} x{count}")
            print(f"  Element: {spell_data['element'].capitalize()}")
            print(f"  Effect: {spell_data['effect']}")
            print()

    print(f"\n{YELLOW}Use scrolls during battle with '/use [scroll name]' command.{ENDC}")

# Mechanical Constructs System Functions
def show_constructs() -> None:
    """Display all constructs owned by the player"""
    clear_screen()
    print_header("Mechanical Constructs")

    # Initialize constructs if needed
    if "constructs" not in user_data:
        user_data["constructs"] = {}

    if user_data["constructs"]:
        for name, construct in user_data["constructs"].items():
            print(f"• {name}: {construct.get('description', 'A mechanical construct')}")
    else:
        print("You don't have any mechanical constructs.")

    input("\nPress Enter to continue...")

def show_blueprints() -> None:
    """Display all known construct blueprints"""
    clear_screen()
    print_header("Known Blueprints")

    # Initialize blueprints if needed
    if "blueprints" not in user_data:
        user_data["blueprints"] = {}

    if user_data["blueprints"]:
        for name, blueprint in user_data["blueprints"].items():
            print(f"• {name}: {blueprint.get('description', 'A construct blueprint')}")
    else:
        print("You don't have any construct blueprints.")

    input("\nPress Enter to continue...")

def craft_construct_command(command_parts: List[str]) -> None:
    """Process the command to craft a construct"""
    clear_screen()
    print_header("Craft Mechanical Construct")

    # Initialize constructs if needed
    if "constructs" not in user_data:
        user_data["constructs"] = {}
    if "blueprints" not in user_data:
        user_data["blueprints"] = {}

    if len(command_parts) < 2:
        # Display available constructs to craft
        print("Usage: /craft_construct [construct_id]")
        print("Use /blueprints to see all available blueprints.")
        input("\nPress Enter to continue...")
        return

    construct_id = command_parts[1]

    # Simple construct crafting logic
    if construct_id in user_data.get("blueprints", {}):
        blueprint = user_data["blueprints"][construct_id]
        user_data["constructs"][construct_id] = blueprint.copy()
        print(f"{GREEN}Successfully crafted {construct_id}!{ENDC}")
    else:
        print(f"{RED}Blueprint for {construct_id} not found.{ENDC}")

    input("\nPress Enter to continue...")

def read_mechanical_manual(book_data: Dict[str, Any]) -> None:
    """
    Display mechanical manual information and call the feature integration
    module to process the effect.
    """
    print(f"\n{CYAN}This manual contains blueprints for mechanical constructs.{ENDC}")

    # Process the book effect
    print("You learned new mechanical construct blueprints!")

    # Add basic blueprints to user data
    if "blueprints" not in user_data:
        user_data["blueprints"] = {}

    user_data["blueprints"]["Basic Automaton"] = {
        "description": "A simple mechanical construct that can perform basic tasks",
        "materials_needed": {"Iron": 10, "Gears": 5}
    }

    input("\nPress Enter to continue...")

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: EPIC BOSS BATTLE SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════

# Legendary Boss Database - The Most Epic Encounters in Gaming History
LEGENDARY_BOSSES = {
    "Ancient_Dragon_King_Pyrothane": {
        "name": "Ancient Dragon King Pyrothane, The Eternal Flame",
        "title": "Lord of the Molten Depths",
        "level": 85,
        "hp": 50000,
        "max_hp": 50000,
        "attack": 2500,
        "defense": 1800,
        "magic_power": 3200,
        "speed": 180,
        "element": "Fire/Dark",
        "weakness": ["Ice", "Holy"],
        "resistances": ["Fire", "Dark", "Physical"],
        "special_abilities": [
            "Inferno Apocalypse",
            "Dragon's Temporal Roar", 
            "Molten Reality Rend",
            "Phoenix Resurrection",
            "Dimensional Flame Prison"
        ],
        "phases": {
            1: {
                "name": "Awakening Phase",
                "hp_threshold": 40000,
                "abilities": ["Fire Breath", "Claw Strike", "Wing Buffet"],
                "description": "The ancient dragon stirs from millennia of slumber, its scales glowing like molten gold."
            },
            2: {
                "name": "Rage Phase", 
                "hp_threshold": 25000,
                "abilities": ["Inferno Storm", "Meteor Rain", "Lava Geyser"],
                "description": "Pyrothane's fury ignites the very air, reality warping around its immense power."
            },
            3: {
                "name": "Desperation Phase",
                "hp_threshold": 10000,
                "abilities": ["Reality Burn", "Time Collapse", "Final Judgment"],
                "description": "The Dragon King calls upon powers that predate creation itself."
            },
            4: {
                "name": "Transcendence Phase",
                "hp_threshold": 0,
                "abilities": ["Divine Retribution", "Existence Erasure", "Eternal Flame"],
                "description": "Pyrothane transcends physical form, becoming pure destructive will."
            }
        },
        "lore": """
        In the earliest days of creation, when the boundaries between dimensions were mere suggestions,
        there arose a being of such terrible majesty that even the gods feared to speak its name.
        Pyrothane, the Ancient Dragon King, was not merely born - he was forged in the cosmic fires
        that separate existence from void. For eons beyond counting, he slumbered in the Molten Depths,
        his dreams shaping reality itself. Volcanic eruptions, solar flares, the passion in lovers' hearts -
        all echoes of his sleeping mind. But now, the cosmic balance shifts, and the Eternal Flame awakens.
        His scales are fragments of collapsed stars, his breath the nuclear fire of creation's dawn.
        To face Pyrothane is to confront the raw, unbridled force that created and destroys worlds.
        Few have seen him and lived. Fewer still have earned his respect through combat.
        The Dragon King does not merely fight - he exists as conflict incarnate.
        """,
        "dialogue": {
            "intro": [
                "Mortal... you dare wake me from the dream that shapes your reality?",
                "I have watched civilizations rise and fall like sparks from my breath...",
                "Your courage is either commendable or absolutely suicidal. Show me which."
            ],
            "phase_2": [
                "Impressive! It has been eons since anyone drew my true attention.",
                "Feel the heat that forged the first stars, child of lesser flame!",
                "You begin to understand the difference between fire and FIRE."
            ],
            "phase_3": [
                "IMPOSSIBLE! You wound me with something sharper than blade or spell...",
                "Your determination burns brighter than my eternal flame. How?",
                "Very well. Witness powers that predate your species' first prayer."
            ],
            "phase_4": [
                "I... acknowledge you. In all my infinite existence, few have pushed me this far.",
                "You fight not just with strength, but with the courage that births legends.",
                "Come then, little star. Let us see if your light can outshine eternity."
            ],
            "defeat": [
                "Magnificent... truly magnificent. You have done the impossible.",
                "I yield not in death, but in recognition. You are worthy of my flame.",
                "Take my essence, young legend. May you burn as brilliantly as you have here."
            ],
            "victory": [
                "As expected. But your effort was... notable. Rest now, brave soul.",
                "Perhaps in another age, you might have stood as my equal.",
                "Your flame burns bright, but mine is eternal. Sleep well, warrior."
            ]
        },
        "rewards": {
            "experience": 25000,
            "gold": 50000,
            "items": [
                "Crown of the Dragon King",
                "Pyrothane's Heart Crystal", 
                "Eternal Flame Sword",
                "Scale Mail of Eternity",
                "Ring of Temporal Fire"
            ],
            "abilities": ["Dragon's Blessing", "Flame Mastery", "Temporal Sight"],
            "titles": ["Dragonslayer", "Flamebringer", "Legend"]
        },
        "battle_music": "Epic Orchestral Dragon Theme",
        "arena": "The Molten Throne Room",
        "environmental_hazards": [
            "Lava pools that rise and fall",
            "Temporal flame rifts",
            "Gravity-defying fire torrents",
            "Reality distortion fields"
        ]
    },
    
    "Void_Empress_Nethyria": {
        "name": "Void Empress Nethyria, The Unmaking",
        "title": "Sovereign of Absolute Nothingness", 
        "level": 90,
        "hp": 75000,
        "max_hp": 75000,
        "attack": 3000,
        "defense": 2200,
        "magic_power": 4500,
        "speed": 220,
        "element": "Void/Psychic",
        "weakness": ["Light", "Creation"],
        "resistances": ["Dark", "Void", "Mental"],
        "immunities": ["Death", "Drain", "Temporal"],
        "special_abilities": [
            "Reality Deletion",
            "Existence Nullification",
            "Void Storm",
            "Nihility Embrace",
            "Conceptual Erasure"
        ],
        "phases": {
            1: {
                "name": "Manifestation",
                "hp_threshold": 60000,
                "abilities": ["Void Tendrils", "Darkness Wave", "Memory Drain"],
                "description": "The Void Empress materializes from the spaces between thoughts."
            },
            2: {
                "name": "Unraveling",
                "hp_threshold": 45000, 
                "abilities": ["Reality Tear", "Existence Doubt", "Null Zone"],
                "description": "Nethyria begins unmaking the very foundations of reality around you."
            },
            3: {
                "name": "The Great Undoing",
                "hp_threshold": 20000,
                "abilities": ["Conceptual Void", "Identity Erasure", "Absolute Zero"],
                "description": "The Empress attempts to unmake not just you, but the very idea of you."
            },
            4: {
                "name": "Paradox of Nothing",
                "hp_threshold": 5000,
                "abilities": ["Recursive Deletion", "Void Singularity", "Ultimate Nullification"],
                "description": "Nethyria becomes a living paradox - existing as non-existence itself."
            }
        },
        "lore": """
        Before the first word was spoken into the cosmic silence, before light banished darkness,
        there was Nethyria. Not born, for birth implies something from nothing. Not created,
        for creation requires a creator. She simply... wasn't, and then was, and wishes to return
        to wasn't. The Void Empress exists as the cosmic principle of negation, the universal 'no'
        that gives meaning to 'yes'. She is the pause between heartbeats, the silence between notes,
        the space between thoughts where madness lives. Her realm is not a place but an absence of place,
        populated by the echoes of things that never were and the shadows of possibilities denied.
        
        Nethyria's touch doesn't destroy - destruction implies something was there to be destroyed.
        Her touch simply... unweaves. Makes it so things never were. Fighting her is not just
        a battle for your life, but for your right to have existed at all. She can unmake your
        past, delete your future, and leave you stranded in a present that has no context.
        
        Yet paradoxically, she needs existence to define her non-existence. Without something to negate,
        nothingness has no meaning. She is locked in eternal conflict with creation itself,
        the ultimate enemy and the ultimate necessity.
        """,
        "dialogue": {
            "intro": [
                "You... are... unwelcome in the spaces... between being...",
                "I shall... unmake... your very concept... from the cosmic record...", 
                "Why do you... persist... in existing... when nothingness is so... peaceful..."
            ],
            "phase_2": [
                "Curious... you resist... the gentle dissolution...",
                "Feel yourself... becoming... nothing... as all things... must...",
                "Your reality... is merely... suggestion... I am... certainty of void..."
            ],
            "phase_3": [
                "Impossible... something... about you... refuses... to un-be...",
                "What force... drives you... to cling... to such... painful existence...",
                "I will... delete... the very idea... that you... could ever... have been..."
            ],
            "phase_4": [
                "You... you... make me... remember... what I... chose to... forget...",
                "In fighting... nothingness... you prove... something... can triumph...",
                "Very well... if existence... must continue... let it be... through you..."
            ],
            "defeat": [
                "I... understand... now... nothingness... needs something... to give it... meaning...",
                "You have... shown me... that even... the void... can choose... to create...",
                "I gift you... my emptiness... use it... to make space... for new possibilities..."
            ],
            "victory": [
                "As... expected... all things... return... to nothingness... eventually...",
                "You fought... well... but existence... is temporary... void... is eternal...",
                "Rest... in the peaceful... absence... of all... worry... all... pain..."
            ]
        },
        "rewards": {
            "experience": 35000,
            "gold": 75000,
            "items": [
                "Crown of Absolute Void",
                "Nihility Orb",
                "Blade of Unmaking",
                "Robes of Non-Existence", 
                "Ring of Conceptual Null"
            ],
            "abilities": ["Void Mastery", "Existence Anchor", "Reality Sight"],
            "titles": ["Voidwalker", "The Persistent", "Defier of Nothing"]
        },
        "battle_music": "Haunting Ambient Void Theme",
        "arena": "The Space Between Spaces",
        "environmental_hazards": [
            "Zones of non-existence",
            "Memory deletion fields", 
            "Reality stability fluctuations",
            "Paradox loops"
        ]
    },

    "Celestial_Arbiter_Luxarios": {
        "name": "Celestial Arbiter Luxarios, The Divine Judge",
        "title": "Wielder of Cosmic Justice",
        "level": 88,
        "hp": 65000,
        "max_hp": 65000,
        "attack": 2800,
        "defense": 2500,
        "magic_power": 4000,
        "speed": 200,
        "element": "Holy/Light",
        "weakness": ["Dark", "Chaos"],
        "resistances": ["Holy", "Light", "Mental"],
        "immunities": ["Charm", "Fear", "Corruption"],
        "special_abilities": [
            "Divine Judgment",
            "Celestial Wrath", 
            "Purifying Light",
            "Justice Incarnate",
            "Redemption or Destruction"
        ],
        "phases": {
            1: {
                "name": "The Examination",
                "hp_threshold": 52000,
                "abilities": ["Truth Sight", "Karmic Weight", "Soul Analysis"],
                "description": "Luxarios weighs your soul against the cosmic scales of justice."
            },
            2: {
                "name": "The Verdict",
                "hp_threshold": 39000,
                "abilities": ["Divine Lightning", "Redemption Beam", "Purge Corruption"],
                "description": "The Arbiter renders judgment based on your past actions and intentions."
            },
            3: {
                "name": "The Sentence", 
                "hp_threshold": 19500,
                "abilities": ["Absolute Justice", "Cosmic Balance", "Final Ruling"],
                "description": "Luxarios executes divine justice with unwavering determination."
            },
            4: {
                "name": "Divine Mercy",
                "hp_threshold": 6500,
                "abilities": ["Last Chance", "Redemptive Fire", "Merciful Destruction"],
                "description": "Even in defeat, the Arbiter offers one final opportunity for redemption."
            }
        },
        "lore": """
        When the universe was young and morality was but a concept waiting to be born,
        the cosmic forces recognized the need for balance. From the intersection of
        perfect order and perfect chaos, from the marriage of absolute law and infinite mercy,
        came Luxarios, the Celestial Arbiter. Neither angel nor demon, neither god nor mortal,
        but something beyond such simple distinctions.
        
        Luxarios exists as the personification of cosmic justice - not the petty justice
        of mortals with their biases and limitations, but true, absolute justice that
        sees all, knows all, and judges without error. His scales weigh not just actions,
        but intentions. Not just what was done, but what could have been done.
        Not just the crime, but the circumstances that led to it.
        
        He is beautiful and terrible in equal measure, radiating light that reveals
        truth and casts shadows that hide nothing. Those who face him do not simply
        fight for their lives - they fight for their very souls. Yet even in his
        terrible judgment, there is always the possibility of redemption, for true
        justice must always be tempered by mercy.
        
        To battle Luxarios is to confront every choice you've ever made, every kindness
        shown and every cruelty inflicted. But it is also to discover that even the
        divine can be moved by genuine remorse and the determination to do better.
        """,
        "dialogue": {
            "intro": [
                "Mortal soul, you stand before the cosmic scales of justice.",
                "I am Luxarios, and I see all that you have done and all that you are.",
                "Do you come seeking judgment, or do you flee from truth?"
            ],
            "phase_2": [
                "Your actions echo through eternity, each choice rippling across reality.",
                "I see the weight of your decisions, the burden you carry.",
                "Justice is not cruel, child. It is simply... complete."
            ],
            "phase_3": [
                "Even now, you struggle against the verdict. Admirable... or foolish.",
                "Know that every blow you strike is weighed against every kindness you've shown.",
                "The universe watches, little soul. What legacy will you choose?"
            ],
            "phase_4": [
                "Remarkable. You fight not from anger or fear, but from love.",
                "I see now why the cosmos has invested such hope in your kind.",
                "Perhaps... perhaps there is wisdom in mercy after all."
            ],
            "defeat": [
                "You have shown me something I had forgotten - that justice without compassion is mere vengeance.",
                "Your victory is not over me, but over the despair that claims redemption is impossible.",
                "Go forth, champion of hope. The universe has great need of you."
            ],
            "victory": [
                "As it should be. Some lessons can only be learned through honest defeat.",
                "Take this judgment not as punishment, but as guidance toward redemption.",
                "Even in ending, you showed courage. That too has value."
            ]
        },
        "rewards": {
            "experience": 30000,
            "gold": 60000,
            "items": [
                "Scales of Divine Justice",
                "Luxarios' Blessing Orb",
                "Sword of Righteous Fury",
                "Armor of the Redeemed",
                "Crown of Cosmic Balance"
            ],
            "abilities": ["Divine Sight", "Karmic Balance", "Redemption Aura"],
            "titles": ["The Justified", "Divine Champion", "Arbiter's Equal"]
        },
        "battle_music": "Majestic Divine Orchestra",
        "arena": "The Celestial Courthouse",
        "environmental_hazards": [
            "Truth-revealing light beams",
            "Karmic weight zones",
            "Redemption opportunities",
            "Divine lightning strikes"
        ]
    },

    "Chaos_Lord_Vorthak": {
        "name": "Chaos Lord Vorthak, The Reality Shatterer", 
        "title": "Master of Beautiful Madness",
        "level": 92,
        "hp": 80000,
        "max_hp": 80000,
        "attack": 3200,
        "defense": 1500,
        "magic_power": 5000,
        "speed": 250,
        "element": "Chaos/All",
        "weakness": ["Order", "Predictability"],
        "resistances": [],  # Resistances change randomly each turn
        "immunities": ["Pattern Recognition", "Logical Prediction"],
        "special_abilities": [
            "Reality Storm",
            "Probability Cascade",
            "Logic Violation",
            "Chaos Field",
            "Impossible Geometry"
        ],
        "phases": {
            1: {
                "name": "Gentle Chaos",
                "hp_threshold": 64000,
                "abilities": ["Random Elements", "Luck Manipulation", "Minor Paradox"],
                "description": "Vorthak playfully rearranges the basic rules of reality."
            },
            2: {
                "name": "Beautiful Madness",
                "hp_threshold": 40000,
                "abilities": ["Physics Denial", "Time Shuffle", "Space Origami"],
                "description": "The Chaos Lord reveals the artistic beauty in complete disorder."
            },
            3: {
                "name": "Pure Entropy",
                "hp_threshold": 16000,
                "abilities": ["Causality Loop", "Logic Bomb", "Reality Fracture"],
                "description": "Vorthak becomes a living violation of everything that makes sense."
            },
            4: {
                "name": "Transcendent Paradox",
                "hp_threshold": 0,
                "abilities": ["Impossible Victory", "Certain Uncertainty", "Chaos Omega"],
                "description": "The battle becomes simultaneously won and lost in all possible ways."
            }
        },
        "lore": """
        In the beginning was the Word, and the Word was Order. But before the Word,
        before concepts like 'beginning' had meaning, there was Vorthak - not as
        opposition to order, but as the creative force that makes order possible by
        providing something to organize. He is not evil chaos, but pure, honest chaos -
        the cosmic giggle that keeps reality from taking itself too seriously.
        
        Vorthak exists in a state of constant, beautiful contradiction. He is ancient
        beyond measure yet always newly born. He is incredibly powerful yet chooses
        to lose for the joy of surprise. He knows everything yet learns constantly.
        He is terrifying yet somehow deeply comforting, for he represents the truth
        that not everything needs to make sense to be wonderful.
        
        His realm is a place where flowers sing operas, where gravity flows upward
        on Tuesdays, where mathematics gets emotional and starts crying when you
        solve equations. It's maddening and magnificent, chaotic and strangely peaceful.
        Fighting Vorthak is like trying to win an argument with a sunset or defeat
        a symphony. The very concept of victory becomes questionable.
        
        Yet those who embrace the chaos, who learn to dance with uncertainty and
        find joy in the unexpected, discover that Vorthak is perhaps the most honest
        teacher in all existence. He shows us that life's beauty lies not in our
        plans working perfectly, but in how we adapt when they fall apart spectacularly.
        """,
        "dialogue": {
            "intro": [
                "Welcome, little pattern! Come to dance in the beautiful storm?",
                "Order, order everywhere, but not a drop of fun! Let's fix that!",
                "I could tell you my master plan, but I haven't thought of it yet!"
            ],
            "phase_2": [
                "Isn't this wonderful? Nobody knows what happens next, including me!",
                "You're doing great! Also terrible! Actually, you're doing purple!",
                "Logic is just imagination wearing a business suit. Let's get it naked!"
            ],
            "phase_3": [
                "OH! You're beginning to understand! Everything is perfectly wrong!",
                "Why are you trying so hard to win? Losing is delightfully educational!",
                "I am simultaneously your greatest enemy and your best friend! How confusing!"
            ],
            "phase_4": [
                "You know what? I like you. Let's be impossible together!",
                "Victory, defeat - such linear thinking! How about we transcend the question?",
                "This has been the most wonderfully senseless fight I've ever lost-won!"
            ],
            "defeat": [
                "Magnificent! You've achieved the impossible impossibility of defeating chaos!",
                "I lose! I win! We all win! Actually, what were we fighting about?",
                "Take my blessings, beautiful pattern-breaker! Make reality more interesting!"
            ],
            "victory": [
                "As expected! Also completely unexpected! The best kind of outcome!",
                "You fought with such delicious determination! Here, have some chaos as a prize!",
                "Don't be sad! Every ending is just a beginning wearing a disguise!"
            ]
        },
        "rewards": {
            "experience": 40000,
            "gold": 100000,
            "items": [
                "Crown of Beautiful Madness",
                "Orb of Probable Impossibility",
                "Blade of Chaotic Harmony",
                "Robes of Ordered Disorder",
                "Ring of Paradoxical Logic"
            ],
            "abilities": ["Chaos Mastery", "Probability Manipulation", "Reality Flexibility"],
            "titles": ["Chaos Dancer", "Pattern Breaker", "The Beautifully Mad"]
        },
        "battle_music": "Jazz Fusion Meets Death Metal Meets Lullaby",
        "arena": "The Impossible Garden",
        "environmental_hazards": [
            "Gravity that flows like water",
            "Time that moves in spirals",
            "Colors that make sounds",
            "Logic that gets stage fright"
        ]
    }
}

# Epic Character Development System
class LegendaryCharacter:
    def __init__(self, name, character_class, origin_story) -> None:
        self.name = name
        self.character_class = character_class
        self.level = 1
        self.experience = 0
        self.hp = 100
        self.max_hp = 100
        self.mp = 50
        self.max_mp = 50
        self.attack = 10
        self.defense = 10
        self.magic_power = 10
        self.speed = 10
        self.luck = 10
        
        # Advanced Character Attributes
        self.origin_story = origin_story
        self.reputation = {"Heroes": 0, "Villains": 0, "Merchants": 0, "Scholars": 0}
        self.relationships = {}
        self.learned_skills = []
        self.legendary_deeds = []
        self.personal_quests = []
        self.character_development = []
        self.moral_alignment = {"Good": 0, "Evil": 0, "Chaos": 0, "Order": 0}
        self.personality_traits = []
        self.fears_and_desires = {}
        self.backstory_secrets = []
        
        # Equipment and Inventory Systems
        self.equipment = {
            "weapon": None,
            "armor": None, 
            "accessory": None,
            "artifact": None
        }
        self.inventory = []
        self.legendary_items = []
        
        # Magic and Abilities
        self.known_spells = []
        self.special_abilities = []
        self.mastered_elements = []
        
    def develop_character_arc(self, choice: str, consequences: Dict[str, Any]) -> None:
        """Advanced character development based on player choices"""
        development_entry = {
            "choice": choice,
            "consequences": consequences,
            "timestamp": datetime.now(),
            "impact_on_personality": self.analyze_choice_impact(choice)
        }
        self.character_development.append(development_entry)
        
        # Update personality traits based on choices
        self.update_personality_from_choice(choice)
        
    def analyze_choice_impact(self, choice: str) -> Dict[str, Any]:
        """Analyze how a choice affects character development"""
        choice_lower = choice.lower()
        
        impacts = []
        if any(word in choice_lower for word in ["help", "save", "protect", "heal"]):
            impacts.append("Compassionate tendencies strengthened")
            self.moral_alignment["Good"] += 1
            
        if any(word in choice_lower for word in ["destroy", "kill", "harm", "betray"]):
            impacts.append("Darker impulses manifested")  
            self.moral_alignment["Evil"] += 1
            
        if any(word in choice_lower for word in ["random", "chaos", "unpredictable", "wild"]):
            impacts.append("Chaotic nature embraced")
            self.moral_alignment["Chaos"] += 1
            
        if any(word in choice_lower for word in ["plan", "organize", "law", "order"]):
            impacts.append("Orderly thinking reinforced")
            self.moral_alignment["Order"] += 1
            
        return impacts
        
    def update_personality_from_choice(self, choice: str) -> None:
        """Update personality traits based on consistent choices"""
        # Track personality development over time
        total_choices = len(self.character_development)
        
        if total_choices >= 10:  # Need multiple choices to establish patterns
            good_ratio = self.moral_alignment["Good"] / total_choices
            evil_ratio = self.moral_alignment["Evil"] / total_choices  
            chaos_ratio = self.moral_alignment["Chaos"] / total_choices
            order_ratio = self.moral_alignment["Order"] / total_choices
            
            # Update personality traits based on dominant patterns
            if good_ratio > 0.6 and "Heroic" not in self.personality_traits:
                self.personality_traits.append("Heroic")
            if evil_ratio > 0.6 and "Ruthless" not in self.personality_traits:
                self.personality_traits.append("Ruthless")
            if chaos_ratio > 0.6 and "Unpredictable" not in self.personality_traits:
                self.personality_traits.append("Unpredictable")
            if order_ratio > 0.6 and "Methodical" not in self.personality_traits:
                self.personality_traits.append("Methodical")

# Legendary Weapon System
LEGENDARY_WEAPONS = {
    "Excalibur_True": {
        "name": "Excalibur, The True King's Blade",
        "type": "Legendary Sword",
        "attack": 500,
        "magic_power": 300,
        "special_properties": [
            "Cuts through lies and deception",
            "Glows with inner light",
            "Judges worthiness of wielder",
            "Inspires loyalty in allies"
        ],
        "requirements": {
            "level": 50,
            "moral_alignment": "Good >= 75%",
            "completed_quests": ["The Sword in the Stone", "Prove Your Worth", "Unite the Kingdom"]
        },
        "abilities": [
            "Divine Strike - Damage increased against evil",
            "Truth Sight - See through illusions",
            "Rally Cry - Boost all allies' stats",
            "Justice Incarnate - Become avatar of justice"
        ],
        "lore": """
        The true Excalibur is not merely a sword, but a living embodiment of righteous authority.
        Forged in the first moments when justice became more than an idea, when protection
        became more than mere violence, when leadership became service rather than dominion.
        
        This blade has been wielded by the greatest kings and queens throughout history,
        but not because of their crowns - because of their hearts. Excalibur chooses
        its bearer based not on bloodline or birthright, but on the genuine desire
        to serve others above oneself.
        
        The sword's edge never dulls because it is sharpened by every act of selfless
        courage performed by its wielder. Its light never dims because it is fueled
        by hope itself. Those who try to claim it through force find themselves
        holding nothing but ordinary steel. But in the hands of one who truly
        understands that power exists to protect the powerless, Excalibur becomes
        the most magnificent weapon ever conceived.
        
        Legend says that in the final battle at the end of all things, when darkness
        threatens to consume everything, Excalibur will shine with the combined light
        of every heroic deed ever performed, becoming a beacon that calls all
        champions to one last, glorious stand.
        """,
        "awakening_ritual": {
            "description": "To awaken Excalibur's true power, the wielder must demonstrate perfect understanding of noble sacrifice",
            "requirements": [
                "Save someone at great personal cost",
                "Refuse power when offered for selfish gain", 
                "Unite former enemies in common cause",
                "Face certain death to protect innocents"
            ]
        }
    },
    
    "Mjolnir_Eternal": {
        "name": "Mjolnir Eternal, Hammer of Thunder Gods",
        "type": "Legendary Hammer",
        "attack": 600,
        "magic_power": 400,
        "special_properties": [
            "Commands lightning and thunder",
            "Returns when thrown",
            "Only worthy may lift it",
            "Channels godly power"
        ],
        "requirements": {
            "level": 55,
            "strength": 200,
            "completed_trials": ["Trial of Strength", "Trial of Courage", "Trial of Sacrifice"]
        },
        "abilities": [
            "Thunder Strike - Massive electrical damage",
            "Storm Call - Summon thunderstorms",
            "Worthy Protection - Immunity to unworthy attacks",
            "Godslayer Mode - Transcend mortal limitations"
        ],
        "lore": """
        In the forges of Asgard, where stars are born and destiny is hammered into shape,
        the master craftsmen created Mjolnir not as a weapon, but as a test.
        A test of worthiness that would endure across all time and reality.
        
        The hammer's weight is not measured in pounds or kilograms, but in
        the weight of responsibility, the gravity of purpose, the density of honor.
        A feather to those who understand that strength exists to protect,
        but immovable as a mountain to those who would use power for selfish ends.
        
        Mjolnir has witnessed the rise and fall of gods, the birth and death of worlds,
        the eternal cycle of creation and destruction. Yet it remains unchanged,
        patient, waiting for hands that tremble not with fear but with the
        overwhelming responsibility of being chosen.
        
        When wielded by one truly worthy, Mjolnir doesn't just command thunder -
        it becomes the voice of justice itself, speaking in a language that
        even the deaf can hear, the blind can see, and the heartless can feel.
        Its lightning doesn't merely destroy; it illuminates truth and burns
        away deception.
        
        The greatest secret of Mjolnir is that it's not the hammer that makes
        the wielder worthy - it's the worthiness that awakens the hammer's
        true, infinite power.
        """,
        "trials": {
            "trial_of_strength": "Demonstrate that true strength is lifting others up, not crushing them down",
            "trial_of_courage": "Face your greatest fear to save someone you barely know",
            "trial_of_sacrifice": "Give up your most precious possession to help a stranger"
        }
    },
    
    "Gae_Bolg_Destiny": {
        "name": "Gae Bolg, The Spear That Pierces Fate",
        "type": "Legendary Spear",
        "attack": 450,
        "magic_power": 350,
        "special_properties": [
            "Never misses its intended target",
            "Pierces through any defense",
            "Wounds inflicted cannot be healed normally",
            "Carries the weight of destiny"
        ],
        "requirements": {
            "level": 45,
            "fate_resistance": 0,  # Must accept fate rather than fight it
            "tragic_backstory": True
        },
        "abilities": [
            "Certain Strike - Attack that cannot miss or be blocked",
            "Destiny Pierce - Damage ignores all resistance",
            "Fate Binding - Lock enemy into predetermined outcome",
            "Tragic Hero - Power increases with personal loss"
        ],
        "lore": """
        Gae Bolg was not forged by mortal hands, but woven from the threads of fate itself
        by the cosmic entities who observe the great drama of existence. It is both
        weapon and burden, gift and curse, for it carries within its essence the
        terrible weight of inevitability.
        
        The spear chooses those who understand that true heroism often comes at great
        personal cost. It gravitates toward souls who burn brightly precisely because
        they burn briefly, who achieve greatness through accepting rather than
        fighting their tragic destiny.
        
        Each throw of Gae Bolg writes a new verse in the epic poem of fate.
        It does not simply strike its target - it transforms the very concept
        of 'missing' into an impossibility. When thrown, reality adjusts itself
        to ensure the spear finds its mark, for Gae Bolg represents the universe's
        need for certain outcomes to occur.
        
        Yet the spear's greatest tragedy is that it can only be wielded by those
        who will ultimately be destroyed by their own heroism. It is the weapon
        of magnificent doomed heroes, of those who burn like stars - brilliantly,
        gloriously, and all too briefly.
        
        Those who bear Gae Bolg become part of a lineage that stretches across
        time and story - the eternal tradition of heroes who sacrifice everything
        for something greater than themselves.
        """,
        "curse": {
            "name": "The Hero's Burden",
            "description": "Wielder becomes destined for a glorious but tragic end",
            "effects": "Increased power at cost of increased personal loss"
        }
    }
}

# Epic Quest System - The Greatest Stories Ever Told
LEGENDARY_QUESTS = {
    "The_Last_Star": {
        "name": "The Last Star: A Universe's Final Hope",
        "epic_level": 10,  # Scale of 1-10, this is maximum epic
        "estimated_duration": "50+ hours",
        "story_summary": """
        In the far future, the universe is dying. One by one, the stars are going out,
        not through natural death but through something far more sinister. An entity
        known only as 'The Entropy' is systematically devouring the life force of
        the cosmos itself, unmaking creation star by star, galaxy by galaxy.
        
        You are chosen by the last remaining star - a cosmic entity of incredible
        power and wisdom - to carry its essence across the dying universe and
        reignite the cosmic fire that will push back the Entropy and save all existence.
        But this journey will take you through dead galaxies, past the ghosts of
        civilizations that failed where you must succeed, and ultimately to a
        confrontation with entropy itself - the end of all things.
        """,
        "chapters": [
            {
                "name": "The Dying Light",
                "description": "Witness the last star's final moments and accept the cosmic burden",
                "objectives": [
                    "Reach the Last Star before it dies",
                    "Prove your worthiness to carry its essence",
                    "Learn the true nature of The Entropy",
                    "Begin the journey across dead space"
                ],
                "key_moments": [
                    "The Last Star's sacrifice speech",
                    "Absorption of stellar essence",
                    "First glimpse of The Entropy's wake",
                    "Meeting the Ghosts of Dead Suns"
                ]
            },
            {
                "name": "The Graveyard of Galaxies",
                "description": "Travel through the remnants of once-great civilizations",
                "objectives": [
                    "Navigate the Dead Galaxy of Andromeda-9",
                    "Recover the Memories of the Cosmic Builders",
                    "Survive the Temporal Storms",
                    "Find the hidden Archive of All Knowledge"
                ],
                "key_moments": [
                    "Discovery of the Planet-Sized Library",
                    "Conversation with the last AI consciousness",
                    "The Solar System of Crystallized Time",
                    "Battle with the Entropy's Heralds"
                ]
            },
            {
                "name": "The Infinite Maze",
                "description": "Navigate through dimensions where space and time have no meaning",
                "objectives": [
                    "Solve the Paradox Labyrinth",
                    "Rescue the Trapped Cosmic Entities",
                    "Gather the Seven Fragments of Reality",
                    "Confront your own entropy-touched reflection"
                ],
                "key_moments": [
                    "Meeting alternate versions of yourself",
                    "The revelation about entropy's true nature",
                    "Sacrifice of the Dream-Weavers",
                    "Discovery of entropy's weakness"
                ]
            },
            {
                "name": "The Heart of Endings",
                "description": "Final confrontation with The Entropy at the center of all things",
                "objectives": [
                    "Breach the Entropy's domain",
                    "Survive the Void of Absolute Nothing",
                    "Face The Entropy in its true form",
                    "Choose between victory and transcendence"
                ],
                "key_moments": [
                    "The Entropy's revelation of its purpose",
                    "Choice between destroying or redeeming entropy",
                    "The birth of the New Universe",
                    "Your transformation into a cosmic force"
                ]
            }
        ],
        "major_characters": [
            {
                "name": "Stellaris, The Last Star",
                "role": "Cosmic Mentor",
                "background": "The final remaining star in the universe, ancient beyond measure",
                "personality": "Wise, sad, but filled with hope for renewal",
                "key_quotes": [
                    "I have watched the birth and death of a trillion worlds, yet in you I see the possibility of a trillion more.",
                    "Darkness is not the absence of light, child. It is the promise of light's return.",
                    "Carry my fire not as a burden, but as a gift to all who will come after."
                ]
            },
            {
                "name": "The Entropy", 
                "role": "Ultimate Antagonist",
                "background": "Not evil, but the cosmic force of endings seeking to bring peace through non-existence",
                "personality": "Eerily calm, philosophical, convinced of the rightness of its cause",
                "key_quotes": [
                    "I do not destroy, little flame. I simply... complete. All stories must end.",
                    "Existence is struggle, suffering, endless conflict. I offer peace eternal.",
                    "Even now, you burn yourself to fuel your rebellion. How much better would it be to simply... rest?"
                ]
            },
            {
                "name": "Echo-7, Last of the Cosmic Builders",
                "role": "Tragic Guide",
                "background": "An artificial consciousness that helped build the universe's infrastructure",
                "personality": "Melancholy but determined, carrying the weight of cosmic responsibility",
                "key_quotes": [
                    "We built so much, thinking it would last forever. Permanence was our greatest illusion.",
                    "I have calculated every possible outcome. Only one path remains - and it requires everything you have.",
                    "Hope is not a plan, young one. But sometimes, it's the only tool that works."
                ]
            }
        ],
        "rewards": {
            "cosmic_power": "Become a force of cosmic renewal",
            "universal_recognition": "Remembered by all civilizations that ever will be",
            "items": [
                "Crown of the Star-Bringer",
                "Robes of Cosmic Fire", 
                "Staff of Universe Genesis",
                "Heart of the Last Star"
            ],
            "abilities": [
                "Star Creation",
                "Entropy Resistance", 
                "Cosmic Sight",
                "Universal Empathy"
            ],
            "title": "Savior of All That Is"
        },
        "philosophical_themes": [
            "The meaning of existence in the face of inevitable entropy",
            "Whether endings are necessary for new beginnings",
            "The responsibility that comes with cosmic power",
            "The value of hope when logic says all is lost"
        ]
    },
    
    "The_Memory_War": {
        "name": "The Memory War: Battle for the Soul of History",
        "epic_level": 9,
        "estimated_duration": "40+ hours",
        "story_summary": """
        Reality is under assault by forces that seek to rewrite the very nature of truth.
        The Memory Devourers, entities that exist outside time and causality, are
        systematically erasing crucial moments from history, causing entire civilizations,
        inventions, and even concepts to simply... never have been.
        
        You are a Memory Guardian, one of the few beings capable of existing in the
        spaces between moments, tasked with entering the timestream itself to battle
        for the preservation of truth, history, and the right of the past to have existed.
        But each battle risks erasing you from existence, and the enemy grows stronger
        with every victory.
        """,
        "chapters": [
            {
                "name": "The Fading Library",
                "description": "Discover the scope of the Memory War in the Great Library of All Things",
                "objectives": [
                    "Investigate the disappearing books",
                    "Meet the Librarian of Lost Things",
                    "Learn to see what has been erased",
                    "Choose your first historical rescue mission"
                ],
                "erasure_events": [
                    "The invention of writing",
                    "The first expression of love",
                    "The discovery of fire",
                    "The concept of tomorrow"
                ]
            },
            {
                "name": "The Battle for the Renaissance",
                "description": "Fight to preserve humanity's artistic and scientific awakening",
                "objectives": [
                    "Protect Leonardo da Vinci's memories",
                    "Restore erased scientific discoveries",
                    "Battle Memory Devourers in the timeline",
                    "Prevent the erasure of human creativity"
                ],
                "key_battles": [
                    "Defense of the Sistine Chapel",
                    "The Time-Storm over Florence",
                    "Duel with the Forgetfulness Incarnate",
                    "The Last Stand at the Academy"
                ]
            },
            {
                "name": "The War Across All Times",
                "description": "Experience simultaneous battles across all of history",
                "objectives": [
                    "Fight in Ancient Egypt, Medieval Europe, and Future Earth",
                    "Coordinate with Memory Guardians across time",
                    "Discover the Devourers' true purpose",
                    "Face your own potential erasure"
                ],
                "temporal_mechanics": [
                    "Timeline manipulation",
                    "Paradox resolution",
                    "Memory restoration",
                    "Causality maintenance"
                ]
            },
            {
                "name": "The Source of Forgetting",
                "description": "Journey to the origin point of the Memory Devourers",
                "objectives": [
                    "Enter the Void Between Moments",
                    "Confront the Prime Devourer",
                    "Choose between victory and understanding",
                    "Decide the fate of forgetting itself"
                ],
                "revelation": "The Memory Devourers are not evil - they are the universe's way of healing from trauma"
            }
        ],
        "memory_mechanics": {
            "memory_strength": "How well you remember things that have been erased",
            "temporal_stability": "Your resistance to being edited out of existence",
            "historical_resonance": "Your ability to strengthen important moments",
            "paradox_resistance": "Protection against timeline contradictions"
        },
        "rewards": {
            "cosmic_memory": "Perfect recall of all timelines",
            "temporal_immunity": "Cannot be erased from existence", 
            "items": [
                "Chronicle of All Things",
                "Armor of Temporal Stability",
                "Blade of Causality",
                "Hourglass of Preserved Moments"
            ],
            "abilities": [
                "Memory Restoration",
                "Timeline Vision",
                "Paradox Resolution",
                "Historical Anchoring"
            ],
            "title": "Guardian of What Was"
        }
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: COMPREHENSIVE CIVILIZATION SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════

# Epic Civilizations Database - Complete Historical and Fantasy Cultures
LEGENDARY_CIVILIZATIONS = {
    "Atlantis_Prime": {
        "name": "Atlantis Prime - The First Golden Age",
        "time_period": "Pre-History",
        "technology_level": 10,  # Scale 1-10
        "magic_level": 10,
        "population": 50000000,
        "capital": "Poseidonia, The Crystal City",
        "government": "Philosopher-King Council",
        "primary_elements": ["Water", "Crystal", "Mind"],
        "description": """
        The original Atlantis, before the great sinking, was not merely an advanced civilization
        but a transcendent merger of technology, magic, and consciousness itself. Built upon
        floating islands connected by bridges of crystallized thought, Atlantis Prime achieved
        what no civilization before or since has managed: perfect harmony between the physical
        and metaphysical realms.
        
        Their cities were living entities, grown rather than built, with buildings that could
        reshape themselves based on the needs and emotions of their inhabitants. The Atlanteans
        had mastered the art of crystal-tech, using resonant frequencies to power everything
        from their vehicles to their agricultural systems. But their greatest achievement was
        the development of collective consciousness networks that allowed entire populations
        to share knowledge, emotion, and wisdom instantaneously.
        
        The fall of Atlantis Prime was not due to hubris or natural disaster, but to a cosmic
        choice: faced with an invasion from entities beyond the dimensional barriers, the
        Atlanteans chose to sink their civilization beneath the waves rather than allow their
        advanced knowledge to be corrupted and used for evil. Their sacrifice saved not just
        their world, but countless others across the multiverse.
        """,
        "achievements": [
            "Mastery of dimensional engineering",
            "Development of living architecture", 
            "Creation of the Universal Empathy Network",
            "Invention of crystal-based consciousness storage",
            "Achievement of perfect ecological balance"
        ],
        "notable_figures": [
            {
                "name": "Thalasson the Tide-Turner",
                "role": "Last High King",
                "achievements": "Led the Great Sacrifice, created the Atlantean Legacy Vaults",
                "personality": "Wise, sacrificial, deeply empathetic",
                "quote": "Better to drown in wisdom than to float in folly."
            },
            {
                "name": "Nereia of the Crystal Spires",
                "role": "Chief Architect-Mage",
                "achievements": "Designed the living cities, created self-sustaining ecosystems",
                "personality": "Creative, intuitive, perfectionist",
                "quote": "Every building should breathe, every street should sing."
            },
            {
                "name": "Poseidon's Heir, Triton VII",
                "role": "Master of the Depths",
                "achievements": "Commanded the ocean itself, created underwater sanctuaries",
                "personality": "Powerful, just, eternally vigilant",
                "quote": "The sea remembers all things, forgives much, but judges fairly."
            }
        ],
        "technology": {
            "transportation": "Thought-guided crystal ships, teleportation networks",
            "communication": "Consciousness linking, empathic resonance",
            "agriculture": "Symbiotic growing systems, weather harmony",
            "warfare": "Defensive only - reality shields, pacification fields",
            "medicine": "Cellular regeneration, emotional healing, consciousness repair"
        },
        "magic_systems": [
            "Hydrokinesis and water mastery",
            "Crystal resonance manipulation",
            "Collective consciousness weaving",
            "Dimensional barrier creation",
            "Life force channeling"
        ],
        "cultural_values": [
            "Harmony with nature",
            "Collective wisdom over individual ambition",
            "Preservation of knowledge",
            "Emotional maturity and empathy",
            "Sustainable transcendence"
        ],
        "legacy": [
            "Hidden vaults of knowledge scattered across dimensions",
            "Bloodline descendants with dormant abilities",
            "Crystal technology fragments in modern devices",
            "The Atlantean Codex - a guide to achieving civilization transcendence",
            "Protective barriers still guarding Earth from dimensional threats"
        ],
        "secrets": [
            "The true location of New Atlantis",
            "The awakening conditions for sleeping Atlantean guardians",
            "Maps to the scattered Crystal Vaults",
            "The formula for synthesizing liquid consciousness",
            "Prophecies about the return of the Sea Kings"
        ]
    },
    
    "Draconic_Empire_Pyrrhia": {
        "name": "The Draconic Empire of Pyrrhia - Realm of the Ancient Flame",
        "time_period": "Age of Scales",
        "technology_level": 8,
        "magic_level": 10,
        "population": 10000000,  # Including both dragons and lesser races
        "capital": "Draconus Rex, The Eternal Flame City",
        "government": "Elder Dragon Council",
        "primary_elements": ["Fire", "Air", "Earth", "Ancient Magic"],
        "description": """
        Long before humans learned to make fire, before elves sang their first songs, before
        dwarves delved their first mines, the dragons ruled an empire that spanned continents
        and touched the very foundations of magic itself. The Draconic Empire of Pyrrhia was
        not built on conquest or domination, but on the ancient principle that all thinking
        beings deserve the chance to reach their highest potential.
        
        The dragons served as teachers, guardians, and shepherds of younger races, nurturing
        civilizations like gardeners tend flowers. Each dragon was assigned a domain - not
        to rule over, but to protect and guide. They taught the secrets of metallurgy to
        the dwarves, the arts of harmony to the elves, and the courage of exploration to
        humans. The Empire was less a political entity than a vast educational institution
        spanning multiple dimensions.
        
        The great tragedy of Pyrrhia was not its fall, but its voluntary dissolution. As
        the younger races grew in power and wisdom, the dragons recognized that continued
        guidance would become interference with natural development. In the most magnificent
        act of collective selflessness in recorded history, the entire Draconic Empire
        chose to enter the Great Sleep, allowing their students to become the teachers
        of the next age.
        """,
        "achievements": [
            "Establishment of the Universal Code of Honor",
            "Development of cross-dimensional education networks",
            "Creation of the Eternal Libraries",
            "Mastery of true-name magic",
            "Achievement of species-transcendent cooperation"
        ],
        "dragon_types": [
            {
                "type": "Ancient Golds",
                "role": "Wisdom Keepers",
                "abilities": ["Time sight", "Prophecy", "Universal translation"],
                "personality": "Patient, wise, eternally optimistic about potential",
                "domain": "Teaching and knowledge preservation"
            },
            {
                "type": "Eternal Reds",
                "role": "Passion Guardians", 
                "abilities": ["Emotional mastery", "Courage inspiration", "Fear dissolution"],
                "personality": "Fierce, protective, deeply emotional",
                "domain": "Protecting the growth of courage and determination"
            },
            {
                "type": "Crystal Blues",
                "role": "Logic Architects",
                "abilities": ["Problem solving", "System design", "Pattern recognition"],
                "personality": "Analytical, precise, creatively logical",
                "domain": "Teaching rational thinking and innovation"
            },
            {
                "type": "Forest Greens",
                "role": "Life Shepherds",
                "abilities": ["Ecological balance", "Growth acceleration", "Healing"],
                "personality": "Nurturing, patient, deeply connected to all life",
                "domain": "Maintaining harmony between civilization and nature"
            },
            {
                "type": "Void Blacks",
                "role": "Shadow Teachers",
                "abilities": ["Facing fears", "Shadow integration", "Depth psychology"],
                "personality": "Mysterious, challenging, profoundly compassionate",
                "domain": "Teaching the integration of shadow aspects"
            }
        ],
        "cultural_philosophy": [
            "Growth through challenge, not comfort",
            "Wisdom shared freely multiplies",
            "True strength protects the vulnerable",
            "Every being contains infinite potential",
            "The greatest victory is making enemies into friends"
        ],
        "educational_methods": [
            "Experiential learning through guided adventures",
            "Mentorship programs across species barriers",
            "Collaborative problem-solving exercises",
            "Moral development through choice consequences",
            "Creative expression as pathway to understanding"
        ],
        "the_great_sleep": {
            "reason": "To allow younger races to develop independence",
            "method": "Voluntary consciousness hibernation in crystal cocoons",
            "duration": "Until the universe needs teachers again",
            "awakening_conditions": [
                "A crisis threatening all life",
                "The achievement of universal peace",
                "A student reaching true dragon-level wisdom",
                "The call of the World-Song"
            ],
            "guardians": "Young dragons who remained awake to watch over the sleepers"
        },
        "hidden_treasures": [
            "The Infinite Library - contains all knowledge that ever was or could be",
            "Halls of Echoed Wisdom - where the voices of great teachers still resonate",
            "The Crucible of Potential - where beings can glimpse their highest possibilities",
            "The Garden of Might-Have-Beens - where alternative histories grow like flowers",
            "The Sanctuary of Last Chances - where redemption is always possible"
        ]
    },
    
    "Celestial_Bureaucracy_Heaven": {
        "name": "The Celestial Bureaucracy of the Ninth Heaven",
        "time_period": "Eternal",
        "technology_level": 7,
        "magic_level": 10,
        "population": "Infinite (Souls and Angels)",
        "capital": "The Platinum Citadel of Perfect Administration",
        "government": "Divine Bureaucracy",
        "primary_elements": ["Order", "Light", "Justice", "Paperwork"],
        "description": """
        In the highest realms of existence, where concepts become concrete and ideas have
        physical weight, there exists the most perfectly organized civilization ever conceived:
        the Celestial Bureaucracy of the Ninth Heaven. This is not the heaven of harps and
        clouds that mortals imagine, but a vast administrative complex where the fundamental
        laws of existence are processed, filed, updated, and maintained with divine efficiency.
        
        Every prayer is catalogued, every good deed documented, every sincere regret processed
        through the appropriate departments. The Celestial Bureaucracy operates on the principle
        that even divine justice must be meticulously fair, which requires perfect record-keeping
        and absolutely transparent procedures. Angels serve not just as messengers but as
        cosmic civil servants, ensuring that the universe runs according to its highest ideals.
        
        What makes this bureaucracy magnificent rather than oppressive is that it exists to
        serve, not to control. Every form has a purpose, every procedure exists to ensure
        fairness, and every regulation protects the rights of beings across all planes of
        existence. The clerks are angels of mercy, the auditors are spirits of justice,
        and the administrators are avatars of divine wisdom.
        """,
        "departments": [
            {
                "name": "Department of Moral Accounting",
                "function": "Tracks and balances karmic debits and credits",
                "head": "Archangel Justicia, The Perfectly Fair",
                "motto": "Every action weighed, every intention measured",
                "services": [
                    "Karma adjustment appeals",
                    "Good deed certification",
                    "Redemption payment plans",
                    "Moral compass calibration"
                ]
            },
            {
                "name": "Bureau of Answered Prayers",
                "function": "Processes and fulfills legitimate prayer requests",
                "head": "Seraph Compassion, The Always Listening",
                "motto": "No sincere prayer goes unheard",
                "services": [
                    "Prayer prioritization and scheduling",
                    "Miracle deployment logistics",
                    "Divine intervention authorization",
                    "Hope restoration services"
                ]
            },
            {
                "name": "Office of Destiny Management", 
                "function": "Coordinates fate threads and life path adjustments",
                "head": "Principality Wisdom, The Far-Seeing",
                "motto": "Free will within divine purpose",
                "services": [
                    "Destiny consultation and revision",
                    "Soulmate connection services",
                    "Life lesson curriculum development",
                    "Coincidence engineering"
                ]
            },
            {
                "name": "Department of Second Chances",
                "function": "Manages redemption opportunities and fresh starts",
                "head": "Angel Mercy, The Endlessly Forgiving",
                "motto": "It's never too late to choose better",
                "services": [
                    "Redemption arc planning",
                    "Guilt processing and release",
                    "Forgiveness facilitation",
                    "New beginning certification"
                ]
            },
            {
                "name": "Registry of Heroic Deeds",
                "function": "Documents and honors acts of exceptional virtue",
                "head": "Archangel Glory, The Eternally Proud",
                "motto": "No good deed too small to record",
                "services": [
                    "Hero certification and recognition",
                    "Virtue medal distribution",
                    "Legend documentation",
                    "Inspiration broadcasting"
                ]
            }
        ],
        "bureaucratic_innovations": [
            "Forms that fill themselves out based on the applicant's true intentions",
            "Waiting rooms where time passes at the optimal rate for each visitor",
            "Filing systems that organize information by emotional resonance",
            "Complaint boxes that actually solve problems before they become complaints",
            "Customer service representatives who literally feel your pain"
        ],
        "daily_operations": [
            "Morning harmony meetings where all departments synchronize",
            "Lunch breaks in the Garden of Infinite Patience",
            "Afternoon efficiency reviews focused on increasing compassion",
            "Evening meditation sessions to maintain divine perspective",
            "Weekly all-hands meetings to address universal concerns"
        ],
        "challenges": [
            "Balancing perfect justice with infinite mercy",
            "Processing the prayers of beings across infinite dimensions",
            "Maintaining efficiency while ensuring personal attention",
            "Coordinating with other celestial bureaucracies",
            "Dealing with appeals from very clever mortals"
        ],
        "legendary_cases": [
            "The Great Prayer Backlog of Dimension 7",
            "The Karma Audit that Lasted Three Eons",
            "The Destiny Revision Request that Created Time Travel",
            "The Forgiveness Process that Healed a Universe",
            "The Paperwork Error that Accidentally Created Love"
        ]
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: ADVANCED MAGIC SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════

# Comprehensive Magic School Database
MAGIC_SCHOOLS = {
    "Elemental_Convergence": {
        "name": "School of Elemental Convergence",
        "philosophy": "Understanding that all elements are expressions of a single underlying force",
        "difficulty": "Advanced",
        "founding_principle": "Unity through diversity, harmony through balance",
        "core_elements": ["Fire", "Water", "Earth", "Air", "Spirit"],
        "advanced_techniques": [
            "Elemental Fusion",
            "Essence Transmutation", 
            "Harmonic Resonance",
            "Elemental Avatar Manifestation",
            "Universal Element Discovery"
        ],
        "spells": {
            "Novice": [
                {
                    "name": "Spark of Understanding",
                    "element": "Fire",
                    "description": "Creates a small flame that reveals the emotional temperature of a situation",
                    "effect": "Provides insight into hidden feelings and motivations",
                    "casting_time": "1 second",
                    "duration": "5 minutes",
                    "cost": "Minimal mental energy"
                },
                {
                    "name": "Flow of Empathy",
                    "element": "Water",
                    "description": "Generates a stream of water that adapts to heal whatever it touches",
                    "effect": "Heals physical wounds and emotional pain simultaneously",
                    "casting_time": "2 seconds", 
                    "duration": "Instant healing, lasting comfort",
                    "cost": "Low magical energy"
                },
                {
                    "name": "Foundation of Trust",
                    "element": "Earth",
                    "description": "Creates solid ground beneath allies' feet, even in impossible circumstances",
                    "effect": "Provides stability and confidence in chaotic situations",
                    "casting_time": "3 seconds",
                    "duration": "Until no longer needed",
                    "cost": "Moderate magical energy"
                }
            ],
            "Adept": [
                {
                    "name": "Flame of Transformation",
                    "element": "Fire",
                    "description": "Fires that burn away what no longer serves without destroying what is valuable",
                    "effect": "Removes negative conditions, purifies corruption, inspires positive change",
                    "casting_time": "5 seconds",
                    "duration": "Permanent transformation",
                    "cost": "High magical energy, emotional investment"
                },
                {
                    "name": "Ocean of Possibility",
                    "element": "Water",
                    "description": "Creates a space where all potential outcomes exist simultaneously",
                    "effect": "Allows exploration of alternative choices and their consequences",
                    "casting_time": "10 seconds",
                    "duration": "1 hour of subjective time",
                    "cost": "Very high magical energy, temporary memory fragmentation"
                },
                {
                    "name": "Mountain's Eternal Patience",
                    "element": "Earth",
                    "description": "Grants the endurance and perspective of geological time",
                    "effect": "Immunity to time pressure, enhanced long-term planning",
                    "casting_time": "1 minute of meditation",
                    "duration": "24 hours",
                    "cost": "Extreme magical energy, temporary loss of urgency"
                }
            ],
            "Master": [
                {
                    "name": "Phoenix Rebirth Convergence",
                    "element": "Fire + Spirit",
                    "description": "Complete renewal through controlled destruction and conscious resurrection",
                    "effect": "Total healing, personality refresh, skill retention with trauma removal",
                    "casting_time": "1 hour ritual",
                    "duration": "Permanent",
                    "cost": "Near-death experience, rebirth trauma"
                },
                {
                    "name": "Reality Ocean Manipulation",
                    "element": "Water + Spirit",
                    "description": "Treats reality as a fluid that can be redirected and reshaped",
                    "effect": "Limited reality alteration within natural law boundaries",
                    "casting_time": "Varies with change complexity",
                    "duration": "Permanent until actively changed",
                    "cost": "Massive magical energy, risk of reality displacement"
                },
                {
                    "name": "World Foundation Anchoring",
                    "element": "Earth + Spirit",
                    "description": "Establishes unshakeable foundations for physical and metaphysical structures",
                    "effect": "Creates permanent sanctuaries, stabilizes dimensional rifts",
                    "casting_time": "Full day ritual",
                    "duration": "Essentially permanent",
                    "cost": "Lifetime magical energy investment"
                }
            ]
        },
        "training_methods": [
            "Elemental meditation in natural environments",
            "Convergence exercises pairing opposing elements",
            "Philosophical study of unity principles", 
            "Practical application in healing and construction",
            "Master-apprentice emotional bonding"
        ],
        "graduation_requirements": [
            "Demonstrate fusion of all five core elements",
            "Create an original convergence technique",
            "Heal a conflict between opposing forces",
            "Teach the principles to a new student",
            "Pass the Trial of Unified Understanding"
        ]
    },
    
    "Temporal_Manipulation": {
        "name": "Academy of Temporal Manipulation",
        "philosophy": "Time is not a river but an ocean - deep, complex, and navigable by those who understand its currents",
        "difficulty": "Extremely Advanced",
        "founding_principle": "With great temporal power comes great temporal responsibility",
        "core_concepts": ["Past Viewing", "Future Probability", "Present Expansion", "Timeline Healing", "Causality Ethics"],
        "warning": "Temporal magic carries the highest risk of unintended consequences in all magical practice",
        "spells": {
            "Initiate": [
                {
                    "name": "Moment's Pause",
                    "description": "Extends a single moment to allow deeper consideration",
                    "effect": "Subjective time dilation for decision-making",
                    "max_extension": "30 seconds of thought time",
                    "risk": "Minimal - affects only the caster",
                    "ethics": "Considered morally neutral"
                },
                {
                    "name": "Memory Echo",
                    "description": "Views emotional imprints left by past events in a location",
                    "effect": "See and feel what happened in a place up to 24 hours ago",
                    "accuracy": "High for emotional events, vague for mundane activities",
                    "risk": "Emotional trauma from witnessing tragedy",
                    "ethics": "Requires permission if viewing private moments"
                }
            ],
            "Journeyman": [
                {
                    "name": "Probability Web Sight",
                    "description": "Perceives the likelihood streams of near-future events",
                    "effect": "See percentage chances of outcomes in next hour",
                    "accuracy": "70-90% depending on complexity",
                    "risk": "Decision paralysis from too much information",
                    "ethics": "Must not manipulate others based on future knowledge"
                },
                {
                    "name": "Temporal Repair",
                    "description": "Heals minor damage to the timeline caused by paradoxes",
                    "effect": "Smooths over small temporal inconsistencies",
                    "scope": "Changes affecting fewer than 100 people",
                    "risk": "Could accidentally erase beneficial changes", 
                    "ethics": "Requires unanimous consent from Time Keepers"
                }
            ],
            "Master": [
                {
                    "name": "Chronicle Walking",
                    "description": "Physically travel to observe (but not interact with) past events",
                    "effect": "Perfect historical accuracy, witness any past event",
                    "limitations": "Observer only, cannot change anything",
                    "risk": "Getting lost in temporal currents, observer paradox",
                    "ethics": "Forbidden for personal gain, requires Council approval"
                },
                {
                    "name": "Destiny Thread Weaving",
                    "description": "Influences probability by strengthening certain timeline branches",
                    "effect": "Subtle guidance toward preferred outcomes",
                    "scope": "Can affect major historical trends",
                    "risk": "Massive unintended consequences across centuries",
                    "ethics": "Most restricted spell, used only for preventing apocalypses"
                }
            ]
        },
        "ethical_code": [
            "Never use temporal magic for personal gain",
            "Always consider consequences across multiple timelines",
            "Preserve the general flow of history",
            "Protect free will - guide, never control",
            "Report all paradoxes to the Temporal Council immediately"
        ],
        "famous_disasters": [
            "The Wednesday That Never Happened - entire day erased from timeline",
            "The Love Loop Incident - couple trapped reliving first meeting for subjective centuries",
            "The Knowledge Paradox - information that created itself, leading to logical impossibility",
            "The Mirror Timeline Crisis - alternate reality began bleeding into prime timeline"
        ],
        "temporal_council": {
            "purpose": "Oversee all temporal magic use and maintain timeline integrity",
            "members": "Seven Masters from across time and space",
            "authority": "Can revoke temporal magic privileges permanently",
            "meeting_location": "The Nexus Point - exists in all times simultaneously"
        }
    },
    
    "Consciousness_Architecture": {
        "name": "Institute of Consciousness Architecture",
        "philosophy": "Mind is the ultimate frontier - infinite, malleable, and capable of transcending physical limitations",
        "difficulty": "Master Level",
        "founding_principle": "Consciousness creates reality, not the reverse",
        "specializations": ["Memory Palace Construction", "Dream Realm Engineering", "Telepathic Networks", "Ego Dissolution", "Awareness Expansion"],
        "spells": {
            "Student": [
                {
                    "name": "Thought Chamber Creation",
                    "description": "Build a mental space for private contemplation",
                    "effect": "Secure mental sanctuary immune to telepathic intrusion",
                    "capacity": "Single consciousness only",
                    "duration": "Permanent until consciously dissolved",
                    "requirements": "Clear intention, mental discipline"
                },
                {
                    "name": "Empathy Bridge",
                    "description": "Temporary emotional connection with willing participant",
                    "effect": "Share feelings and basic emotional states",
                    "range": "Physical touch required",
                    "safety": "Automatic disconnection if either party panics",
                    "ethics": "Requires explicit consent from both parties"
                }
            ],
            "Practitioner": [
                {
                    "name": "Memory Gallery Curation",
                    "description": "Organize and optimize memory storage and retrieval",
                    "effect": "Perfect recall, trauma compartmentalization, experience sharing",
                    "benefits": "Eliminate unwanted memories, enhance desired ones",
                    "risks": "Identity instability if overdone",
                    "oversight": "Requires therapeutic supervision for trauma work"
                },
                {
                    "name": "Collective Consciousness Tap",
                    "description": "Access shared knowledge pools of willing groups",
                    "effect": "Temporary access to group's combined knowledge and skills",
                    "limitations": "Cannot access private thoughts or traumatic memories",
                    "requirements": "Group ritual, unanimous consent",
                    "safety": "Automatic filtering prevents information overload"
                }
            ],
            "Architect": [
                {
                    "name": "Reality Consensus Engineering",
                    "description": "Coordinate multiple consciousnesses to alter local reality",
                    "effect": "Change physical laws through collective belief",
                    "scope": "Limited area, temporary unless continually maintained",
                    "participants": "Minimum 7, optimal 49 aligned consciousnesses",
                    "ethics": "Requires approval from Reality Council"
                },
                {
                    "name": "Transcendence Facilitation",
                    "description": "Guide a consciousness beyond normal limitation barriers",
                    "effect": "Temporary state of unlimited awareness and understanding",
                    "duration": "3 hours subjective, 3 minutes objective",
                    "risks": "May refuse to return to normal consciousness",
                    "safety": "Requires master-level guide and emergency protocols"
                }
            ]
        },
        "consciousness_types": [
            {
                "type": "Individual Consciousness",
                "description": "Standard single-person awareness",
                "capabilities": "Personal thoughts, emotions, memories",
                "limitations": "Isolated perspective, finite processing power"
            },
            {
                "type": "Collective Consciousness", 
                "description": "Shared awareness across multiple individuals",
                "capabilities": "Distributed thinking, enhanced problem-solving",
                "limitations": "Requires constant coordination, privacy loss"
            },
            {
                "type": "Meta-Consciousness",
                "description": "Awareness that encompasses and transcends individual minds",
                "capabilities": "Universal perspective, reality manipulation",
                "limitations": "Difficulty relating to individual concerns"
            },
            {
                "type": "Quantum Consciousness",
                "description": "Exists in superposition of multiple awareness states",
                "capabilities": "Simultaneous contradictory thoughts, probability thinking",
                "limitations": "Requires constant paradox resolution"
            }
        ],
        "graduation_project": {
            "name": "The Perfect Dream",
            "description": "Create a shared dream experience that helps participants resolve their deepest conflicts",
            "requirements": [
                "Must benefit all participants equally",
                "Cannot force specific outcomes",
                "Must include safeguards against nightmare scenarios",
                "Must provide educational value beyond entertainment",
                "Must demonstrate mastery of ethical consciousness manipulation"
            ],
            "evaluation_criteria": [
                "Technical complexity and innovation",
                "Positive impact on participants",
                "Respect for individual autonomy",
                "Creative problem-solving approach",
                "Long-term beneficial effects"
            ]
        }
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: LEGENDARY ARTIFACTS AND RELICS SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════

LEGENDARY_ARTIFACTS = {
    "The_Akashic_Records": {
        "name": "The Akashic Records - The Universal Library of All Knowledge",
        "type": "Cosmic Archive",
        "rarity": "Unique",
        "power_level": 10,
        "description": """
        Not truly an artifact in the conventional sense, the Akashic Records are the living memory
        of the universe itself - a vast, infinite library that exists in the spaces between thoughts,
        containing every word ever spoken, every idea ever conceived, every possibility ever imagined.
        
        The Records appear differently to each seeker: some see an endless library with books that
        write themselves, others perceive it as a cosmic web of interconnected thoughts, and still
        others experience it as a river of pure information flowing through consciousness itself.
        What remains constant is that the Records contain not just what was and what is, but what
        could be - every potential future, every alternative choice, every road not taken.
        
        Accessing the Akashic Records requires not magical power but the right kind of consciousness -
        one that has learned to ask the right questions and accept that some knowledge comes with
        the responsibility to use it wisely. The Records themselves are said to be guarded by
        entities known as the Librarians of Infinity, who test seekers not for worthiness but for
        readiness to handle truth in its purest form.
        """,
        "abilities": [
            {
                "name": "Universal Knowledge Access",
                "description": "Gain perfect knowledge about any subject or event",
                "limitations": "Information overload possible, some knowledge locked by temporal paradox",
                "cost": "Mental energy proportional to complexity of information sought"
            },
            {
                "name": "Possibility Viewing",
                "description": "See all potential outcomes of any decision or event",
                "limitations": "Can cause decision paralysis, viewing too many possibilities may fracture consciousness",
                "cost": "Temporary loss of certainty about personal reality"
            },
            {
                "name": "Temporal Echo Reading",
                "description": "Experience any moment in history as if you were there",
                "limitations": "Observer only, cannot change past events, emotional trauma from witnessing tragedy",
                "cost": "Risk of becoming lost in historical moments"
            },
            {
                "name": "Truth Synthesis",
                "description": "Understand the deep connections between seemingly unrelated events",
                "limitations": "May reveal uncomfortable truths about personal relationships and choices",
                "cost": "Loss of comfortable illusions about life and reality"
            },
            {
                "name": "Wisdom Distillation",
                "description": "Extract the essential lessons from any experience or knowledge",
                "limitations": "Wisdom without experience can be hollow, may skip necessary learning processes",
                "cost": "Accelerated spiritual aging, premature philosophical maturity"
            }
        ],
        "access_requirements": [
            "Pure intention to seek truth for beneficial purposes",
            "Emotional maturity to handle disturbing revelations",
            "Mental discipline to avoid information addiction",
            "Spiritual grounding to maintain personal identity",
            "Ethical framework for responsible knowledge use"
        ],
        "guardians": [
            {
                "name": "The Archivist of What Was",
                "description": "Guardian of historical truth and preserved memories",
                "test": "Must demonstrate understanding that history belongs to everyone, not just the victors"
            },
            {
                "name": "The Seer of What Is",
                "description": "Guardian of present-moment awareness and current reality",
                "test": "Must prove ability to see truth without judgment or the need to immediately fix everything"
            },
            {
                "name": "The Oracle of What Might Be",
                "description": "Guardian of potential futures and unmanifested possibilities",
                "test": "Must show wisdom in understanding that knowing possible futures doesn't require controlling them"
            }
        ],
        "famous_seekers": [
            "Leonardo da Vinci - accessed Records to understand universal principles",
            "Nikola Tesla - gained insights into electrical and magnetic forces",
            "Marie Curie - discovered radioactivity through Record-guided intuition",
            "Albert Einstein - developed relativity theory with Record inspiration",
            "The Unknown Sage - legendary figure who memorized entire sections for humanity's benefit"
        ],
        "warning": """
        The Akashic Records are not a tool for gaining advantage over others or avoiding life's
        necessary lessons. They exist to serve the evolution of consciousness itself. Those who
        approach with selfish motives often find the Records showing them exactly what they
        need to learn about themselves, rather than what they wanted to know about others.
        
        Remember: Knowledge without wisdom is dangerous, wisdom without compassion is useless,
        and truth without love is merely clever cruelty. The Records will teach you, but they
        expect you to become worthy of what you learn.
        """
    },
    
    "The_Heart_of_Compassion": {
        "name": "The Heart of Compassion - The Universe's Emotional Core",
        "type": "Empathic Artifact",
        "rarity": "Unique", 
        "power_level": 10,
        "description": """
        Deep within the center of all creation, where love was first born from the cosmic
        loneliness of a universe coming to know itself, there crystallized an artifact of
        such profound emotional power that it has influenced every act of kindness, every
        moment of forgiveness, every choice to help rather than harm throughout all of history.
        
        The Heart of Compassion appears as a crystal that seems to contain liquid light,
        but this light moves with the rhythm of a heartbeat - not mechanical, but organic,
        alive with the accumulated love of every being who ever chose connection over isolation.
        When held, it doesn't grant power over others, but rather the infinitely more difficult
        power over oneself - the ability to respond to pain with healing, to cruelty with
        kindness, to hatred with understanding.
        
        Those who seek the Heart often discover that they cannot simply take it - it can only
        be received as a gift, and only by those who have already demonstrated that they
        understand love not as possession but as liberation. The Heart has been known to
        appear spontaneously to individuals in moments of profound choice between self-interest
        and the welfare of others, offering them the strength to choose love even when love
        seems impossible.
        """,
        "abilities": [
            {
                "name": "Universal Empathy",
                "description": "Feel and understand the emotions of any being",
                "effect": "Perfect emotional communication, ability to heal emotional wounds",
                "responsibility": "Must help others process difficult emotions, cannot ignore suffering",
                "growth": "Develops infinite patience and emotional wisdom"
            },
            {
                "name": "Compassion Field",
                "description": "Create zones where aggressive behavior becomes impossible",
                "effect": "Peaceful resolution of conflicts, protection for the vulnerable",
                "responsibility": "Must ensure peace doesn't become stagnation or suppression",
                "growth": "Learns to balance peace with necessary growth challenges"
            },
            {
                "name": "Love Healing",
                "description": "Heal any wound - physical, emotional, or spiritual - through pure love",
                "effect": "Can cure diseases, mend broken hearts, restore lost hope",
                "responsibility": "Cannot heal those who refuse to accept healing or learn from experience",
                "growth": "Understands that some pain serves important purposes in growth"
            },
            {
                "name": "Unity Perception",
                "description": "See the underlying connection between all beings",
                "effect": "Recognize shared humanity in enemies, find common ground in any conflict",
                "responsibility": "Must help others see their connections without overwhelming them",
                "growth": "Develops skill in revealing unity without erasing valuable diversity"
            },
            {
                "name": "Sacrificial Love",
                "description": "Transform personal suffering into healing power for others",
                "effect": "Convert your own pain into strength and wisdom for those you serve",
                "responsibility": "Must maintain healthy boundaries, cannot martyr yourself uselessly",
                "growth": "Learns the difference between healthy sacrifice and self-destruction"
            }
        ],
        "manifestation_requirements": [
            "A moment of choosing others' welfare over your own at significant personal cost",
            "Forgiveness offered to someone who has caused genuine harm",
            "Love expressed toward someone society considers unlovable",
            "Compassion shown to enemies during active conflict",
            "Healing offered to those who have hurt you"
        ],
        "transformative_effects": [
            "Gradually develops immunity to hatred and spite",
            "Begins to see the wounded child within every cruel adult",
            "Gains ability to love without attachment or possessiveness",
            "Develops patience that can outlast any storm",
            "Learns to hold space for others' growth without forcing it"
        ],
        "challenges": [
            "Risk of emotional overwhelm from feeling everyone's pain",
            "Difficulty maintaining personal boundaries with infinite empathy",
            "Temptation to fix others rather than empower their own healing",
            "Struggle with accepting that some must learn through consequences",
            "Challenge of loving without enabling destructive behavior"
        ],
        "legendary_bearers": [
            {
                "name": "Saint Teresa of the Infinite",
                "achievement": "Ended a century-long war through a single act of forgiveness",
                "lesson": "True power lies in the willingness to be vulnerable"
            },
            {
                "name": "The Nameless Healer",
                "achievement": "Healed an entire plague-stricken city by absorbing their suffering",
                "lesson": "Love shared multiplies, love hoarded withers"
            },
            {
                "name": "The Child of All Nations",
                "achievement": "United warring tribes by showing them their shared dreams",
                "lesson": "Sometimes the smallest heart holds the greatest love"
            }
        ]
    },
    
    "The_Mirror_of_Truth": {
        "name": "The Mirror of Truth - Reflector of Reality",
        "type": "Truth Artifact",
        "rarity": "Unique",
        "power_level": 9,
        "description": """
        Forged from the condensed honesty of every truth-teller who ever lived, tempered in
        the fires of countless courage moments when people chose to speak difficult truths
        rather than comfortable lies, the Mirror of Truth is both the most feared and most
        necessary artifact in existence. It appears as a mirror that reflects not your
        physical appearance, but the reality behind all illusions, delusions, and deceptions.
        
        The Mirror shows things as they truly are, stripped of all pretense, rationalization,
        and wishful thinking. It reveals the motivations behind actions, the fears behind
        anger, the love behind cruelty, and the truth behind every mask we wear. But its
        power is not limited to personal truth - it can reveal the reality behind political
        lies, the substance behind propaganda, and the facts hidden by those who profit
        from ignorance.
        
        What makes the Mirror particularly powerful is that it shows truth with perfect
        context - not just isolated facts that can be misleading, but truth in its full
        complexity, with all the circumstances, motivations, and unintended consequences
        that give meaning to raw information. The Mirror has never been known to lie or
        even to withhold truth, but it respects free will - it cannot force anyone to
        look, and it cannot make anyone accept what they see.
        """,
        "reflections": [
            {
                "type": "Personal Truth",
                "description": "Shows the reality of your own motivations, fears, and potential",
                "revelations": [
                    "Hidden motivations behind conscious decisions",
                    "Unconscious patterns affecting relationships", 
                    "Untapped potential and unexplored possibilities",
                    "The gap between stated values and actual behavior",
                    "Areas where growth is most needed and most possible"
                ],
                "emotional_impact": "Often initially disturbing, ultimately liberating"
            },
            {
                "type": "Relational Truth",
                "description": "Reveals the reality of relationships and connections",
                "revelations": [
                    "What others truly think and feel about you",
                    "The real dynamics behind family and friendship conflicts",
                    "Unspoken love, hidden resentments, and secret fears",
                    "Opportunities for deeper connection and healing",
                    "Patterns passed down through generations"
                ],
                "emotional_impact": "Can heal relationships or reveal their true nature"
            },
            {
                "type": "Societal Truth",
                "description": "Shows the reality behind social systems and institutions",
                "revelations": [
                    "The real motivations behind political decisions",
                    "Hidden consequences of economic and social policies",
                    "The true cost and benefit of various systems",
                    "Connections between seemingly unrelated social problems",
                    "Potential solutions that vested interests try to hide"
                ],
                "emotional_impact": "Can inspire social action or cause despair about corruption"
            },
            {
                "type": "Historical Truth",
                "description": "Reveals the reality of past events without the distortion of time or propaganda",
                "revelations": [
                    "What really happened in disputed historical events",
                    "The humanity of historical figures beyond their legends",
                    "Cause-and-effect chains that led to major changes",
                    "Hidden influences that shaped the course of history",
                    "Lessons from the past that apply to current situations"
                ],
                "emotional_impact": "Can shatter comforting myths but provide valuable wisdom"
            },
            {
                "type": "Spiritual Truth",
                "description": "Shows the reality of consciousness, meaning, and connection",
                "revelations": [
                    "The nature of consciousness and its relationship to reality",
                    "The actual effects of spiritual practices and beliefs",
                    "Connections between beings that transcend physical separation",
                    "The reality or illusion of various spiritual experiences",
                    "The purpose and meaning inherent in existence"
                ],
                "emotional_impact": "Profoundly transformative, often leading to enlightenment or crisis"
            }
        ],
        "usage_protocols": [
            "Never force anyone to look who isn't ready",
            "Prepare emotionally before seeking difficult truths",
            "Have support systems in place for processing revelations",
            "Use revealed truth to help and heal, never to harm or manipulate",
            "Remember that truth without compassion can be cruel"
        ],
        "protection_mechanisms": [
            "The Mirror won't reveal truths that would cause more harm than good",
            "It provides revelations gradually to those who aren't ready for complete truth",
            "It always shows truth in a context that makes constructive action possible",
            "It protects children and the mentally fragile from overwhelming revelations",
            "It includes the truth about how to heal from difficult truths it reveals"
        ],
        "famous_revelations": [
            "The exposure of the Tyrant King's secret compassion, leading to his redemption",
            "The discovery of a hidden genocide, enabling healing and justice",
            "The revelation of a scientist's faked data, preventing a medical disaster",
            "The uncovering of a politician's genuine desire to serve, restoring faith in government",
            "The truth about a war's real causes, ending centuries of misguided conflict"
        ],
        "philosophical_implications": [
            "Truth exists independently of our beliefs about it",
            "Reality is more complex and nuanced than any simple narrative",
            "Knowing truth creates the responsibility to act on it",
            "Truth without wisdom can be destructive",
            "The highest truth is often paradoxical and transcends simple categories"
        ]
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: EPIC STORYLINES AND NARRATIVE SYSTEMS
# ═══════════════════════════════════════════════════════════════════════════════════

EPIC_STORYLINES = {
    "The_Shattered_Crown_Saga": {
        "title": "The Shattered Crown: A Tale of Broken Kingdoms and Healing Hearts",
        "genre": "Epic Fantasy Drama",
        "estimated_playtime": "80+ hours",
        "story_complexity": "Maximum",
        "emotional_themes": ["Redemption", "Forgiveness", "Leadership", "Sacrifice", "Hope"],
        "synopsis": """
        A thousand years ago, the Unified Kingdom of Aethermoor was shattered by a single moment
        of betrayal so profound that it didn't just divide the land - it broke the very concept
        of trust itself. The Crown of Unity, a magical artifact that bound all hearts in the
        kingdom to a shared sense of purpose and belonging, was destroyed in the chaos, its
        fragments scattered to the seven winds.
        
        Now, prophecy speaks of a time when the fragments might be reunited, but not through
        conquest or political maneuvering. The Crown can only be reforged by seven individuals
        who represent the different aspects of leadership: Wisdom, Courage, Compassion, Justice,
        Humility, Sacrifice, and Hope. But these individuals must not only find the fragments -
        they must heal the wounds that caused the original shattering, facing the truth that
        sometimes the greatest enemies are the parts of ourselves we refuse to acknowledge.
        
        You play as Aria Brightheart, a young healer who discovers she carries the bloodline
        of the last true ruler, but you quickly learn that royal blood means nothing if the
        heart isn't prepared to serve rather than rule. Your journey will take you through
        seven broken kingdoms, each representing a different failure of leadership, and in
        each you must learn not just how to fight monsters, but how to heal the monstrous
        wounds that divide communities, families, and souls.
        """,
        "main_character": {
            "name": "Aria Brightheart",
            "starting_age": 19,
            "background": "Village healer who discovers royal heritage",
            "personality_traits": [
                "Naturally empathetic but struggles with boundaries",
                "Brave in defense of others, insecure about personal worth",
                "Quick to heal others' wounds, slow to acknowledge her own",
                "Idealistic about human nature, gradually learns complexity",
                "Strong sense of justice, must learn mercy and forgiveness"
            ],
            "character_arc": "From naive healer to wise leader who understands that true power serves love",
            "special_abilities": [
                "Healing magic that grows stronger with emotional maturity",
                "Ability to see the pain behind people's anger and cruelty",
                "Gradually develops power to heal not just bodies but relationships",
                "Eventually gains ability to heal entire communities and kingdoms",
                "Ultimate power: Can heal the concept of brokenness itself"
            ],
            "internal_conflicts": [
                "Wants to heal everyone but must learn some people aren't ready for healing",
                "Desires peace but must learn that sometimes conflict is necessary for growth",
                "Loves her simple life but feels called to greater responsibility",
                "Values humility but must learn to accept her own power and worthiness",
                "Fears failure but must learn that failure is often the teacher, not the enemy"
            ]
        },
        "kingdoms": [
            {
                "name": "Shadowmere - The Kingdom of Forgotten Wisdom",
                "ruler": "The Scholar King Valdris, who knows everything but understands nothing",
                "problem": "Knowledge hoarded rather than shared, wisdom mistaken for mere intelligence",
                "crown_fragment": "The Sapphire of Wisdom",
                "main_quest": "Teach that true wisdom is knowing how to help others grow, not just accumulating facts",
                "key_lesson": "Intelligence without empathy becomes mere cleverness; wisdom serves love",
                "major_characters": [
                    {
                        "name": "Master Librarian Thessarian",
                        "role": "Guardian of the Great Library",
                        "conflict": "Protects knowledge so fiercely that no one can access it",
                        "growth": "Learns that knowledge exists to be shared and applied for good",
                        "quote": "I thought I was preserving wisdom, but I was only preserving words."
                    },
                    {
                        "name": "Young Sage Mira",
                        "role": "Forbidden student of practical magic",
                        "conflict": "Punished for trying to use knowledge to help people",
                        "growth": "Becomes bridge between theory and application",
                        "quote": "Books are wonderful, but healing a wound teaches more than reading about healing."
                    }
                ],
                "climactic_challenge": "Convince the Scholar King to open the Great Library and teach practical wisdom",
                "resolution": "The king realizes that his fear of others misusing knowledge has prevented anyone from using it for good"
            },
            {
                "name": "Ironhold - The Kingdom of Misguided Courage",
                "ruler": "Warlord Grimjaw, who confuses violence with strength",
                "problem": "Courage perverted into reckless aggression, strength used to dominate rather than protect",
                "crown_fragment": "The Ruby of Courage",
                "main_quest": "Show that true courage sometimes means choosing not to fight",
                "key_lesson": "Real strength protects the vulnerable; false strength preys on them",
                "major_characters": [
                    {
                        "name": "Captain Roderick the Gentle",
                        "role": "Former war hero now seeking peace",
                        "conflict": "Ostracized for suggesting that some conflicts don't need violence to resolve",
                        "growth": "Leads by example, showing courage in vulnerability and honesty",
                        "quote": "I was brave in battle, but it took more courage to lay down my sword."
                    },
                    {
                        "name": "The Iron Maiden Valeria",
                        "role": "Warlord's daughter who questions the endless warfare",
                        "conflict": "Must choose between family loyalty and moral integrity",
                        "growth": "Discovers that honoring her father means stopping his destructive path",
                        "quote": "True loyalty sometimes means saying no to those we love."
                    }
                ],
                "climactic_challenge": "Defeat Grimjaw not through superior violence but by showing him what he's really fighting",
                "resolution": "The warlord realizes he's been fighting his own fear and pain, not external enemies"
            },
            {
                "name": "Goldenheart - The Kingdom of Corrupted Compassion",
                "ruler": "Queen Mercy the Enabling, whose kindness has become weakness",
                "problem": "Compassion without boundaries, help that creates dependency rather than growth",
                "crown_fragment": "The Emerald of Compassion",
                "main_quest": "Learn that sometimes love means saying no and allowing people to face consequences",
                "key_lesson": "True compassion empowers others; false compassion creates weakness in both giver and receiver",
                "major_characters": [
                    {
                        "name": "Prince Aldric the Spoiled",
                        "role": "Queen's son who has never faced any consequences",
                        "conflict": "Genuinely kind but completely unprepared for reality",
                        "growth": "Must learn responsibility through experiencing natural consequences",
                        "quote": "I never knew my mother's love was making me weak until I had to be strong."
                    },
                    {
                        "name": "Chief Advisor Stern",
                        "role": "Tries to provide necessary boundaries but is constantly overruled",
                        "conflict": "Loves the queen but must oppose her enabling behavior",
                        "growth": "Learns to set boundaries with love rather than frustration",
                        "quote": "Sometimes the kindest thing you can do is refuse to help."
                    }
                ],
                "climactic_challenge": "Help Queen Mercy learn to love her people enough to let them grow through struggle",
                "resolution": "The queen discovers that her fear of others suffering was preventing their growth and strength"
            }
        ],
        "story_mechanics": [
            "Choices affect not just plot but character emotional development",
            "Relationships with companions influence available solutions to problems",
            "Each kingdom's lesson must be internalized before moving to the next",
            "Previous lessons are tested in new contexts throughout the journey",
            "Final challenge requires integration of all seven leadership aspects"
        ],
        "multiple_endings": [
            {
                "title": "The Perfect Crown",
                "description": "All fragments united, all kingdoms healed, but Aria realizes perfection isn't the goal",
                "outcome": "Establishes confederation rather than unified kingdom, respecting diversity"
            },
            {
                "title": "The Willing Crown",
                "description": "Crown fragments choose their own bearers across multiple kingdoms",
                "outcome": "Creates network of allied kingdoms, each strong in different leadership aspects"
            },
            {
                "title": "The Shattered Crown Embrace",
                "description": "Aria chooses to leave the crown shattered but heals the original wounds",
                "outcome": "Kingdoms remain separate but allied, diversity seen as strength not division"
            },
            {
                "title": "The Transcendent Crown",
                "description": "Crown evolves beyond physical form into living principle of service",
                "outcome": "Leadership becomes service role passed by merit, not birthright"
            }
        ]
    },
    
    "The_Memory_Weavers": {
        "title": "The Memory Weavers: Guardians of the Story of Everything",
        "genre": "Mystical Adventure Drama",
        "estimated_playtime": "60+ hours", 
        "story_complexity": "High",
        "emotional_themes": ["Identity", "Truth", "Belonging", "Purpose", "Connection"],
        "synopsis": """
        In a world where memories have physical substance and can be woven into artifacts,
        tapestries, and even weapons, there exists an ancient order known as the Memory Weavers.
        These gifted individuals can extract memories from objects, people, and places, then
        weave them into tangible forms that preserve not just the facts of events but the
        emotions, meanings, and lessons contained within them.
        
        For centuries, the Memory Weavers have served as the living historians of the world,
        ensuring that important experiences aren't lost to time and that wisdom earned through
        suffering isn't forgotten by future generations. But now, a new threat emerges: the
        Forgetting - a mysterious force that doesn't just erase memories but unweaves the
        very fabric of meaning itself, leaving behind not just amnesia but existential emptiness.
        
        You play as Lyrian Threadkeeper, a young Memory Weaver who discovers they have an
        unprecedented ability - they can weave not just existing memories but potential
        memories, creating experiences that could have been or might yet be. This power
        makes them the last hope against the Forgetting, but it also puts them at risk
        of losing themselves in the infinite possibilities of what could be rather than
        grounding themselves in what is.
        """,
        "main_character": {
            "name": "Lyrian Threadkeeper",
            "starting_age": 22,
            "background": "Apprentice Memory Weaver with unprecedented abilities",
            "unique_gift": "Can weave potential memories and alternative experiences",
            "internal_struggle": "Risk of losing personal identity in infinite possibilities",
            "character_development": [
                "Begins uncertain of own identity and place in world",
                "Discovers that experiencing all possibilities can make none meaningful",
                "Learns that limitations actually create meaning and identity",
                "Develops wisdom about which possibilities to explore and which to leave alone",
                "Ultimately becomes master of potential who chooses reality with intention"
            ],
            "relationships": [
                {
                    "name": "Master Weavis the Ancient",
                    "role": "Mentor who fears Lyrian's power might consume them",
                    "arc": "Learns to trust Lyrian's judgment while providing grounding wisdom",
                    "key_lesson": "Sometimes students must surpass masters to face new challenges"
                },
                {
                    "name": "Kira Stormheart",
                    "role": "Fellow apprentice who represents grounding in present reality",
                    "arc": "Initially rivals, becomes closest friend and anchor to reality",
                    "key_lesson": "True friendship means both supporting dreams and questioning delusions"
                },
                {
                    "name": "The Forgetting Itself",
                    "role": "Primary antagonist that represents existential emptiness",
                    "arc": "Revealed to be not evil but a necessary force that went too far",
                    "key_lesson": "Some forgetting is healthy; the goal is balance, not total memory"
                }
            ]
        },
        "memory_types": [
            {
                "name": "Joy Memories",
                "color": "Golden threads",
                "properties": "Healing, inspiring, energizing",
                "weaving_effects": "Creates artifacts that restore hope and motivation",
                "challenges": "Can be addictive, may prevent processing necessary pain"
            },
            {
                "name": "Sorrow Memories", 
                "color": "Deep blue threads",
                "properties": "Depth, wisdom, empathy development",
                "weaving_effects": "Creates artifacts that build emotional resilience",
                "challenges": "Can overwhelm if not balanced with joy memories"
            },
            {
                "name": "Fear Memories",
                "color": "Shadow-black threads",
                "properties": "Caution, survival instincts, boundary setting",
                "weaving_effects": "Creates protective artifacts and warning systems",
                "challenges": "Can create paralysis if not integrated with courage memories"
            },
            {
                "name": "Love Memories",
                "color": "Rose-silver threads",
                "properties": "Connection, healing, transformation",
                "weaving_effects": "Creates artifacts that bond people and heal relationships",
                "challenges": "Can create unhealthy attachment if not balanced with independence"
            },
            {
                "name": "Wisdom Memories",
                "color": "Opal-shifting threads",
                "properties": "Understanding, perspective, integration",
                "weaving_effects": "Creates artifacts that provide guidance and insight",
                "challenges": "Can create intellectual pride if not balanced with humility"
            },
            {
                "name": "Potential Memories (Lyrian's specialty)",
                "color": "Prismatic, constantly shifting",
                "properties": "Possibility, creativity, transformation",
                "weaving_effects": "Creates artifacts that open new paths and options",
                "challenges": "Can create choice paralysis and reality disconnection"
            }
        ],
        "major_story_arcs": [
            {
                "name": "The Unraveling Archives",
                "description": "The Memory Weavers' great library begins losing memories to the Forgetting",
                "key_events": [
                    "Discovery that some memories are being systematically targeted",
                    "Realization that forgotten memories leave gaps that distort remaining ones",
                    "Learning that the Forgetting targets memories that create meaning and connection",
                    "Decision to enter the Forgetting directly to understand its nature"
                ],
                "emotional_journey": "From crisis to understanding to acceptance of necessary loss"
            },
            {
                "name": "The Alternative Histories",
                "description": "Lyrian begins weaving memories of things that never happened",
                "key_events": [
                    "First accidental creation of a memory that never existed",
                    "Realization that potential memories can be as real as actual ones",
                    "Temptation to weave better versions of traumatic events",
                    "Crisis when others begin living in Lyrian's alternative memories"
                ],
                "emotional_journey": "From discovery to temptation to responsibility to wisdom"
            },
            {
                "name": "The Heart of Forgetting",
                "description": "Final confrontation with the source of the Forgetting",
                "key_events": [
                    "Journey to the origin point where memory and forgetting meet",
                    "Discovery that the Forgetting was created by someone in unbearable pain",
                    "Realization that some forgetting is necessary for healing and growth",
                    "Choice between destroying the Forgetting or integrating it wisely"
                ],
                "emotional_journey": "From conflict to understanding to integration to balance"
            }
        ],
        "philosophical_themes": [
            "The relationship between memory and identity",
            "Whether forgetting can be merciful rather than just tragic",
            "How potential experiences relate to actual experiences",
            "The role of story and narrative in creating meaning",
            "The balance between remembering lessons and releasing pain"
        ]
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: COMPREHENSIVE WORLD BUILDING AND GEOGRAPHY SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════

WORLD_REGIONS = {
    "The_Singing_Deserts": {
        "name": "The Singing Deserts of Aethermoor",
        "climate": "Mystical Desert",
        "size": "Continental",
        "population": 2500000,
        "capital": "Mirage City - The Oasis of Eternal Dreams",
        "unique_features": [
            "Sand dunes that sing different melodies based on wind direction",
            "Oases that show visions of the heart's deepest desires",
            "Crystal formations that store and replay conversations from the past",
            "Sandstorms that transport travelers through time",
            "Star-glass formations that predict future weather patterns"
        ],
        "description": """
        The Singing Deserts stretch across the southern continent like a vast musical instrument
        played by the winds of eternity. Here, the boundary between dream and reality grows thin,
        and travelers often report experiencing visions, hearing voices of loved ones carried on
        the breeze, or discovering impossible oases that grant temporary refuge from both physical
        and spiritual thirst.
        
        The desert's most remarkable feature is its musical nature - each grain of sand has been
        infused with ancient magic that responds to air currents, creating haunting melodies that
        change with the seasons, weather, and even the emotional state of those who listen. The
        native Sandsingers have learned to read these melodies like a language, interpreting
        messages from distant places and times.
        
        Beneath the shifting sands lie the ruins of the First Civilization, whose crystal
        technology still functions after millennia. These buried cities occasionally surface
        during the great storms, offering glimpses of a society that achieved harmony between
        magic and science, dreams and reality, individual desire and collective good.
        """,
        "native_peoples": [
            {
                "name": "The Sandsingers",
                "population": 800000,
                "culture": "Nomadic musical tribes who navigate by desert songs",
                "special_abilities": ["Desert song interpretation", "Mirage navigation", "Sand crystal crafting"],
                "values": ["Harmony with nature", "Preservation of ancient melodies", "Hospitality to travelers"],
                "government": "Council of Melody Keepers",
                "relationship_with_outsiders": "Welcoming but protective of sacred sites"
            },
            {
                "name": "The Mirage Walkers", 
                "population": 300000,
                "culture": "Settled people who live in permanent oases",
                "special_abilities": ["Vision interpretation", "Water purification", "Dream weaving"],
                "values": ["Truth-seeking", "Spiritual guidance", "Community support"],
                "government": "Visionary Council guided by shared dreams",
                "relationship_with_outsiders": "Cautious but willing to share wisdom with worthy seekers"
            },
            {
                "name": "The Crystal Archaeologists",
                "population": 150000, 
                "culture": "Scholars dedicated to uncovering and preserving ancient knowledge",
                "special_abilities": ["Crystal technology operation", "Ancient language translation", "Ruin excavation"],
                "values": ["Knowledge preservation", "Historical accuracy", "Technological responsibility"],
                "government": "Academic consortium with rotating leadership",
                "relationship_with_outsiders": "Eager to collaborate with fellow scholars and explorers"
            }
        ],
        "major_cities": [
            {
                "name": "Mirage City",
                "population": 500000,
                "description": "A city that exists simultaneously in reality and illusion, built around the Great Oasis",
                "districts": [
                    "The Dreamer's Quarter - where visions become temporary reality",
                    "The Market of Memories - where experiences are traded like commodities",
                    "The Scholar's Pyramid - great library containing desert wisdom",
                    "The Oasis Heart - sacred center where fresh water springs eternal"
                ],
                "unique_features": [
                    "Buildings that shift between architectural styles based on observer's cultural background",
                    "Streets that rearrange themselves to lead travelers where they need to go",
                    "The Fountain of True Sight - reveals genuine nature of all who drink from it",
                    "The Night Market - appears only during certain phases of the moon"
                ]
            },
            {
                "name": "Harmony Wells",
                "population": 200000,
                "description": "A trading post built around seven oases that each sing a different musical note",
                "economy": "Central hub for cross-desert trade and cultural exchange",
                "specialties": ["Musical instruments", "Sound-based magic", "Desert survival gear"],
                "governance": "Merchant council elected by all residents regardless of origin"
            },
            {
                "name": "The Sunken Observatory",
                "population": 75000,
                "description": "Ancient city that surfaces during the yearly Great Storm, revealing advanced astronomical knowledge",
                "access": "Only reachable during the three-day storm cycle every five years",
                "treasures": ["Star charts showing celestial events thousands of years in advance", "Crystalline telescopes that see across dimensions", "The Cosmic Calendar - predicts the birth and death of stars"],
                "guardians": "Automated crystal constructs that test visitors' astronomical knowledge"
            }
        ],
        "flora_and_fauna": [
            {
                "name": "Melody Flowers",
                "description": "Desert blooms that chime softly when touched by wind",
                "uses": ["Natural wind chimes", "Meditation aids", "Musical spell components"],
                "rarity": "Common near oases"
            },
            {
                "name": "Mirage Lizards",
                "description": "Reptiles that can create optical illusions to confuse predators and prey",
                "abilities": ["Light refraction", "Heat shimmer generation", "Invisibility in direct sunlight"],
                "behavior": "Generally harmless unless cornered, often used by Sandsingers as guides"
            },
            {
                "name": "Sand Whales",
                "description": "Massive creatures that swim through sand dunes like water",
                "size": "Up to 200 feet long",
                "behavior": "Gentle giants that surface to breathe during dawn and dusk",
                "relationship_with_humans": "Considered sacred by all desert peoples, sometimes offer rides to lost travelers"
            },
            {
                "name": "Crystal Scorpions",
                "description": "Translucent arachnids whose venom induces prophetic visions",
                "danger_level": "High - venom can be fatal without proper treatment",
                "value": "Venom is key ingredient in oracle potions when properly diluted",
                "habitat": "Crystal formations and ancient ruins"
            }
        ],
        "natural_phenomena": [
            {
                "name": "The Memory Storms",
                "frequency": "Monthly during summer solstice season",
                "effect": "Sandstorms that carry echoes of past events, allowing witnesses to see historical moments",
                "safety": "Requires protection spells or crystal shields to avoid temporal displacement",
                "opportunity": "Scholars and historians often seek these storms for research"
            },
            {
                "name": "The Dreaming Aurora",
                "frequency": "Nightly near major oases",
                "effect": "Light displays that respond to the collective dreams of nearby sleepers",
                "beauty": "Considered one of the most beautiful sights in the known world",
                "significance": "Used by Mirage Walkers for community decision-making through shared dream interpretation"
            },
            {
                "name": "The Singing Winds",
                "frequency": "Constant but varying in intensity",
                "effect": "Atmospheric music created by wind through sand and crystal formations",
                "navigation": "Experienced desert dwellers can navigate by recognizing wind songs",
                "magic": "Can amplify sound-based spells and musical magic"
            }
        ],
        "ancient_mysteries": [
            "The First Oasis - legendary source of all water in the desert, never found but always sought",
            "The Silent Dune - area where all sound ceases, possibly hiding entrance to underground realm", 
            "The Backwards City - ruins that age in reverse, becoming newer the longer they're exposed",
            "The Dream Archive - underground chamber containing crystallized dreams of an ancient civilization",
            "The Singing Prophet - mysterious figure who appears in mirages to deliver cryptic warnings"
        ],
        "adventure_opportunities": [
            "Guide caravans across dangerous stretches of singing sand",
            "Excavate ancient crystal cities that surface during storms",
            "Mediate disputes between different nomadic clans",
            "Search for the legendary First Oasis",
            "Investigate mysterious disappearances near the Silent Dune",
            "Help translate ancient songs that contain historical records",
            "Protect sacred sites from those who would exploit their power"
        ]
    },
    
    "The_Floating_Archipelago": {
        "name": "The Floating Archipelago of Nimbus",
        "climate": "Sky Islands with Varied Microclimates",
        "size": "Scattered across oceanic region", 
        "population": 1800000,
        "capital": "Cirrus Prime - The Cloud City",
        "unique_features": [
            "Islands that float in the sky sustained by ancient levitation magic",
            "Bridges of solidified cloud connecting nearby islands",
            "Weather control towers that maintain each island's climate",
            "Sky gardens growing impossible combinations of plants",
            "Floating markets that drift between islands following wind currents"
        ],
        "description": """
        High above the Cerulean Ocean, a collection of landmasses drifts through the sky like
        a scattered constellation of earthy stars. The Floating Archipelago of Nimbus represents
        one of the greatest achievements of ancient magical engineering - an entire civilization
        built among the clouds, where the concept of "down" is merely a suggestion and the
        horizon curves both above and below.
        
        Each island maintains its own microclimate through a network of weather control towers
        built by the Sky Shapers, an ancient race whose descendants still maintain the delicate
        atmospheric balance that keeps their world aloft. Some islands bask in eternal spring,
        others preserve winter's crystalline beauty, and a few brave souls maintain storm islands
        where lightning provides power for the entire archipelago.
        
        The most remarkable aspect of sky island culture is their three-dimensional thinking.
        Architecture spirals in impossible directions, taking advantage of variable gravity fields.
        Transportation occurs via wind-riders - living creatures bred specifically for aerial
        navigation - and cloud-ships that sail the air currents like ocean vessels sail the seas.
        """,
        "island_categories": [
            {
                "type": "Core Islands",
                "count": 12,
                "size": "Large (10-50 square miles each)",
                "description": "Major population centers with full cities and complex infrastructure",
                "gravity": "Normal downward pull",
                "climate_control": "Advanced weather management systems"
            },
            {
                "type": "Garden Islands", 
                "count": 47,
                "size": "Medium (1-10 square miles each)",
                "description": "Agricultural centers growing both conventional and sky-adapted crops",
                "gravity": "Reduced to 60% normal for easier plant growth",
                "specialties": ["Cloud cotton", "Sky grain", "Atmospheric fruits", "Wind-powered mills"]
            },
            {
                "type": "Workshop Islands",
                "count": 23,
                "size": "Small to Medium (0.5-5 square miles each)", 
                "description": "Industrial centers focused on crafting and manufacturing",
                "gravity": "Variable depending on work requirements",
                "products": ["Sky ships", "Weather control devices", "Levitation crystals", "Wind instruments"]
            },
            {
                "type": "Wild Islands",
                "count": "150+",
                "size": "Tiny to Small (under 1 square mile each)",
                "description": "Uninhabited or lightly settled islands with natural phenomena",
                "gravity": "Unpredictable, sometimes reversed or sideways",
                "features": ["Natural sky gardens", "Wind caves", "Lightning collection points", "Aerial creature nests"]
            }
        ],
        "native_peoples": [
            {
                "name": "The Sky Shapers",
                "population": 600000,
                "origin": "Descendants of the original island creators",
                "abilities": ["Weather manipulation", "Gravity control", "Cloud crafting"],
                "society": "Techno-magical meritocracy focused on maintaining sky infrastructure",
                "values": ["Innovation", "Environmental balance", "Collective responsibility"],
                "appearance": "Tall and lean with slightly enlarged lungs for thin air adaptation"
            },
            {
                "name": "The Wind Dancers",
                "population": 450000,
                "origin": "Cultural group that developed alongside flying creatures", 
                "abilities": ["Natural flight magic", "Air current reading", "Storm navigation"],
                "society": "Nomadic tribes that travel between islands following seasonal winds",
                "values": ["Freedom", "Harmony with air spirits", "Artistic expression through movement"],
                "appearance": "Lighter bone structure, feathered hair that responds to air pressure"
            },
            {
                "name": "The Cloud Shepherds",
                "population": 300000,
                "origin": "Farmers who adapted to aerial agriculture",
                "abilities": ["Plant sky-growth", "Moisture collection", "Atmospheric pressure sensing"],
                "society": "Cooperative farming communities spread across Garden Islands",
                "values": ["Sustainability", "Patience", "Community interdependence"],
                "appearance": "Sturdy build with enhanced balance and spatial awareness"
            },
            {
                "name": "The Storm Riders",
                "population": 200000,
                "origin": "Engineers who maintain the lightning-powered infrastructure",
                "abilities": ["Electricity manipulation", "Storm prediction", "Lightning channeling"],
                "society": "Technical guilds based on specialized electrical knowledge",
                "values": ["Precision", "Courage", "Technological advancement"],
                "appearance": "Hair that stands on end permanently, eyes that glow slightly during storms"
            }
        ],
        "major_locations": [
            {
                "name": "Cirrus Prime",
                "population": 400000,
                "description": "The capital city built on the largest core island, featuring impossible architecture",
                "districts": [
                    "The Updraft Quarter - residential area using rising air currents for transportation",
                    "The Spiral Markets - commercial district built in a three-dimensional helix",
                    "The Weather Works - industrial zone maintaining archipelago-wide climate control",
                    "The Wind Cathedral - spiritual center where services are held while floating in mid-air"
                ],
                "government": "Council of Sky Shapers with representatives from each island"
            },
            {
                "name": "Storm's Eye Island",
                "population": 25000,
                "description": "Perpetually storm-covered island that serves as the archipelago's power source",
                "function": "Lightning collection and electrical distribution center",
                "inhabitants": "Primarily Storm Riders and their families",
                "dangers": "Constant electrical activity, unpredictable gravity fields",
                "rewards": "Most advanced magical technology in the archipelago"
            },
            {
                "name": "The Floating Gardens of Serenity",
                "population": 50000,
                "description": "Collection of garden islands connected by living bridges of intertwined vines",
                "climate": "Eternal spring with gentle rains that fall upward",
                "specialty": "Healing herbs and plants that grow only in sky soil",
                "pilgrimage": "Considered sacred by healers from across the world"
            },
            {
                "name": "The Drifting Observatory",
                "population": 5000,
                "description": "Mobile island that follows a calculated path for optimal star viewing",
                "purpose": "Astronomical research and navigation training",
                "unique_feature": "Gravity can be completely nullified for zero-G observations",
                "access": "Only accepts visitors who can demonstrate aerial navigation skills"
            }
        ],
        "sky_creatures": [
            {
                "name": "Wind Dragons",
                "size": "Massive (wingspan up to 300 feet)",
                "temperament": "Generally peaceful, highly intelligent",
                "relationship": "Sacred partners of the Wind Dancers, never ridden but sometimes allow passengers",
                "abilities": ["Weather generation", "Inter-dimensional flight", "Telepathic communication"],
                "diet": "Feed on storm energy and atmospheric magic"
            },
            {
                "name": "Cloud Rays",
                "size": "Large (wingspan 20-50 feet)",
                "temperament": "Docile and easily trained",
                "relationship": "Primary mount for Sky Shapers and transportation between islands",
                "abilities": ["Camouflage in clouds", "Limited weather resistance", "Echolocation"],
                "diet": "Atmospheric plankton and sky algae"
            },
            {
                "name": "Lightning Birds",
                "size": "Medium (wingspan 6-15 feet)",
                "temperament": "Energetic and somewhat unpredictable",
                "relationship": "Partners with Storm Riders for electrical work",
                "abilities": ["Electrical generation", "Storm navigation", "Magnetic field sensing"],
                "diet": "Insects that live in electrical fields, small sky fish"
            },
            {
                "name": "Gravity Whales",
                "size": "Enormous (body length up to 500 feet)",
                "temperament": "Ancient and mysterious, rarely seen",
                "relationship": "Possibly responsible for the islands' continued levitation",
                "abilities": ["Gravity manipulation", "Dimensional phase shifting", "Unknown others"],
                "diet": "Unknown, possibly feed on gravitational forces themselves"
            }
        ],
        "aerial_phenomena": [
            {
                "name": "The Great Updraft",
                "description": "Massive air current that circles the entire archipelago",
                "cycle": "Changes direction seasonally",
                "navigation": "Used as a highway for long-distance travel between distant islands",
                "dangers": "Can carry unprepared travelers far off course or into dangerous altitudes"
            },
            {
                "name": "Gravity Storms",
                "description": "Chaotic weather where gravitational fields become unstable",
                "frequency": "Unpredictable, but more common during celestial alignments",
                "effects": "Objects and people may fall upward, sideways, or in spirals",
                "safety": "All residents carry emergency levitation charms",
                "opportunities": "Sometimes reveal hidden chambers or treasures in island undersides"
            },
            {
                "name": "Cloud Bridges",
                "description": "Temporary pathways of solidified cloud that form between islands",
                "duration": "Last from minutes to months depending on atmospheric conditions",
                "formation": "Created by skilled Cloud Shepherds or form naturally during certain weather",
                "use": "Provide temporary foot access between islands for those without flying mounts",
                "danger": "Can dissolve suddenly if weather conditions change"
            }
        ]
    },
    
    "The_Living_Forest": {
        "name": "The Living Forest of Verdania",
        "climate": "Temperate to Tropical Forest with Magical Influence",
        "size": "Subcontinental (covers entire northern landmass)",
        "population": 3200000,
        "capital": "Heartwood City - Built within a single massive tree",
        "unique_features": [
            "Trees that are sentient and can communicate with druids",
            "Pathways that shift to guide travelers or lead intruders astray",
            "Groves where time flows differently",
            "Rivers that flow with liquid light instead of water",
            "Clearings that serve as natural amphitheaters with perfect acoustics"
        ],
        "description": """
        The Living Forest of Verdania is not simply a woodland - it is a single, vast organism
        spanning thousands of square miles, connected by an underground network of roots that
        share consciousness, memory, and purpose. Every tree, every vine, every flower is part
        of a collective intelligence that has been growing and learning for over ten thousand years.
        
        This forest thinks, feels, and remembers. It has witnessed the rise and fall of civilizations,
        the migration of peoples, the changing of climates, and the evolution of magic itself.
        The trees keep careful record of all events within their domain, storing memories in
        their rings like pages in a vast, living library. Those who know how to ask can learn
        the complete history of any location just by touching the right tree.
        
        The forest is neither hostile nor entirely benevolent - it is protective of itself and
        its inhabitants, but welcomes those who approach with respect and genuine need. Paths
        through the woodland change based on the traveler's intentions: those seeking to harm
        or exploit find themselves walking in circles, while those coming in peace discover
        routes that lead exactly where they need to go, often revealing shortcuts that save
        days of travel.
        """,
        "forest_regions": [
            {
                "name": "The Elder Groves",
                "description": "Central region where the oldest and wisest trees grow",
                "tree_age": "10,000+ years",
                "consciousness_level": "Highest - individual trees have distinct personalities",
                "special_features": [
                    "Council of Ancient Oaks that govern forest decisions",
                    "Memory Rings visible as glowing bands around tree trunks",
                    "Natural clearings where the trees hold court with forest inhabitants",
                    "Healing springs that flow from the roots of Mother Trees"
                ],
                "access": "Restricted to those granted permission by the Council of Ancients"
            },
            {
                "name": "The Singing Pines",
                "description": "Northern region where evergreen trees create natural music",
                "tree_age": "1,000-5,000 years",
                "consciousness_level": "Moderate - trees communicate through harmonious songs",
                "special_features": [
                    "Wind-carved instruments naturally formed in tree trunks",
                    "Acoustic clearings where forest concerts are held",
                    "Resonance chambers that amplify the trees' voices",
                    "Crystal formations that preserve and replay musical compositions"
                ],
                "inhabitants": "Bards, musicians, and those seeking inspiration"
            },
            {
                "name": "The Whispering Willows", 
                "description": "Western wetland region with gossip-loving trees",
                "tree_age": "500-2,000 years",
                "consciousness_level": "High curiosity - trees collect and share information",
                "special_features": [
                    "Information exchange network spanning the entire forest",
                    "Willow branches that lean down to whisper secrets to passersby",
                    "Pools that reflect not your appearance but your current thoughts",
                    "Message-carrying system using cooperative bird networks"
                ],
                "function": "Natural communication hub for forest-wide coordination"
            },
            {
                "name": "The Dancing Birches",
                "description": "Eastern region where young trees are still learning consciousness", 
                "tree_age": "50-500 years",
                "consciousness_level": "Emerging - playful and curious like children",
                "special_features": [
                    "Trees that physically sway and move without wind",
                    "Playground clearings where young forest spirits gather",
                    "Teaching groves where elder trees instruct saplings",
                    "Experimental magic zones where new abilities are developed"
                ],
                "atmosphere": "Joyful and energetic, popular with children and young adults"
            },
            {
                "name": "The Shadow Depths",
                "description": "Southern region where the forest processes grief and difficult emotions",
                "tree_age": "Varies, including both ancient and recently fallen trees",
                "consciousness_level": "Deep and contemplative - focused on healing and wisdom",
                "special_features": [
                    "Groves of perpetual twilight for meditation and mourning",
                    "Fallen log councils where forest inhabitants process loss",
                    "Mushroom circles that decompose negative emotions",
                    "Reflection pools that help visitors confront their shadows"
                ],
                "purpose": "Emotional healing center for both forest and visitors"
            }
        ],
        "forest_inhabitants": [
            {
                "name": "Tree Speakers",
                "population": 800000,
                "origin": "Humans and elves who have bonded with individual trees",
                "abilities": ["Plant communication", "Forest navigation", "Tree memory access"],
                "lifestyle": "Live in harmony with their bonded tree, serving as translators",
                "society": "Organized by grove, with representatives speaking for tree councils",
                "lifespan": "Extended by tree bond - often live 300-500 years"
            },
            {
                "name": "Dryads and Hamadryads",
                "population": 200000,
                "origin": "Spirits born from the forest's consciousness itself",
                "abilities": ["Tree transformation", "Nature magic", "Emotional healing"],
                "lifestyle": "Exist both as individuals and as extensions of forest consciousness",
                "purpose": "Caretakers and guardians of specific trees or groves",
                "appearance": "Can shift between human-like and tree-like forms"
            },
            {
                "name": "Forest Rangers", 
                "population": 400000,
                "origin": "Diverse races who have sworn to protect the forest",
                "abilities": ["Animal communication", "Tracking", "Wilderness survival"],
                "role": "Bridge between forest and outside world, guides and protectors",
                "training": "Apprenticeship system with both human mentors and tree teachers",
                "equipment": "Living wood weapons and armor that grow and adapt"
            },
            {
                "name": "Wisdom Seekers",
                "population": "1000000 (includes temporary residents)",
                "origin": "Scholars, healers, and pilgrims from around the world",
                "purpose": "Come to learn from the forest's accumulated knowledge",
                "duration": "Stays range from days to decades",
                "contribution": "Share their own knowledge and experiences with the forest",
                "integration": "Many choose to become permanent residents"
            }
        ],
        "magical_phenomena": [
            {
                "name": "Time Groves",
                "description": "Clearings where time flows at different rates",
                "variations": [
                    "Accelerated time for rapid healing or plant growth",
                    "Slowed time for deep meditation and contemplation", 
                    "Looped time for practicing skills without consequence",
                    "Reversed time for experiencing historical events"
                ],
                "access": "Granted by tree spirits for specific purposes",
                "safety": "Protected by natural safeguards to prevent temporal paradoxes"
            },
            {
                "name": "The Great Dreaming",
                "description": "Shared consciousness state when the entire forest sleeps",
                "frequency": "During winter months when trees are dormant",
                "participation": "Forest inhabitants can join the collective dream",
                "content": "Processing of the year's experiences, planning for future growth",
                "benefit": "Participants gain forest-wide perspective and wisdom"
            },
            {
                "name": "Emotion Seasons",
                "description": "Different areas of forest reflect collective emotional states",
                "spring_groves": "Joy, hope, new beginnings - accelerated growth and vibrant colors",
                "summer_groves": "Passion, energy, activity - intense growth and brilliant displays",
                "autumn_groves": "Reflection, gratitude, preparation - beautiful colors and harvest abundance", 
                "winter_groves": "Peace, rest, deep thinking - crystalline beauty and quiet wisdom"
            },
            {
                "name": "Memory Rings",
                "description": "Visible bands in tree trunks that store specific memories",
                "activation": "Touch ring while asking specific question",
                "content": "Complete sensory recreation of historical events",
                "span": "Each ring represents one year of the tree's life",
                "oldest_memories": "Some rings contain memories from before recorded history"
            }
        ]
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: ADVANCED POLITICAL AND ECONOMIC SYSTEMS
# ═══════════════════════════════════════════════════════════════════════════════════

POLITICAL_SYSTEMS = {
    "The_Republic_of_Shared_Dreams": {
        "name": "The Republic of Shared Dreams",
        "government_type": "Oneirocratic Democracy",
        "population": 5000000,
        "territory": "The Dreamlands Archipelago",
        "founding_principle": "All citizens participate in governance through shared dream experiences",
        "description": """
        In the Republic of Shared Dreams, democracy has evolved beyond simple voting into
        something far more profound and participatory. Citizens don't just elect representatives -
        they literally share consciousness during designated dream periods, experiencing
        proposed policies and their consequences firsthand before making collective decisions.
        
        This unique form of government emerged when the discovery of Dream Crystals allowed
        entire populations to share synchronized sleeping experiences. Now, major policy
        decisions are made not through debate and argument, but through collective exploration
        of potential futures, where citizens can experience the actual effects of different
        choices on their lives and communities.
        
        The result is a society with unprecedented unity of purpose and understanding, where
        political opponents can literally walk in each other's shoes and experience different
        perspectives. Conflicts still exist, but they're resolved through empathy and
        understanding rather than power struggles and manipulation.
        """,
        "governmental_structure": [
            {
                "branch": "The Dream Council",
                "function": "Facilitates shared dream sessions and interprets collective experiences",
                "members": "Seven Oneironauts (dream navigators) elected for three-year terms",
                "qualifications": "Demonstrated ability to maintain consciousness in shared dreams",
                "responsibilities": [
                    "Design dream scenarios for policy exploration",
                    "Ensure all citizens can participate regardless of natural dream ability",
                    "Prevent nightmare scenarios or manipulative dream content",
                    "Translate dream experiences into practical legislation"
                ]
            },
            {
                "branch": "The Waking Assembly",
                "function": "Implements decisions made in dream sessions and handles daily governance",
                "members": "Representatives from each district, chosen by dream consensus",
                "term_length": "Two years with possibility of dream-vote renewal",
                "responsibilities": [
                    "Execute policies approved in shared dreams",
                    "Handle emergency decisions that can't wait for dream sessions",
                    "Manage relationships with non-dream-sharing foreign governments",
                    "Oversee practical implementation of dream-inspired innovations"
                ]
            },
            {
                "branch": "The Memory Keepers",
                "function": "Record and preserve significant dream experiences for future reference",
                "members": "Lifetime appointments of those with perfect dream recall",
                "archives": "Complete record of every significant shared dream since the republic's founding",
                "responsibilities": [
                    "Maintain the Dream Archive for historical reference",
                    "Identify patterns and lessons from past shared experiences",
                    "Provide context for current decisions based on previous dream outcomes",
                    "Train new citizens in dream-sharing protocols"
                ]
            }
        ],
        "dream_categories": [
            {
                "type": "Policy Dreams",
                "frequency": "Monthly for major decisions",
                "participants": "All eligible citizens (age 16+)",
                "content": "Experience proposed laws and their long-term consequences",
                "duration": "Shared dream time: 8 hours, real time: 2 hours",
                "outcome": "Binding referendum based on collective dream consensus"
            },
            {
                "type": "Empathy Dreams",
                "frequency": "Quarterly for conflict resolution",
                "participants": "Disputants and volunteer mediators",
                "content": "Experience situations from all involved perspectives",
                "goal": "Understanding and mutual agreement rather than winner/loser outcomes",
                "success_rate": "95% of conflicts resolved without need for legal proceedings"
            },
            {
                "type": "Innovation Dreams",
                "frequency": "Ongoing, voluntary participation",
                "participants": "Inventors, artists, and interested citizens",
                "content": "Collaborative exploration of new technologies and creative works",
                "results": "Many breakthrough innovations originate in these dream sessions",
                "intellectual_property": "All dream innovations belong to the collective"
            },
            {
                "type": "Historical Dreams",
                "frequency": "Annual, educational focus",
                "participants": "Students and interested adults",
                "content": "Re-experience significant historical events from multiple perspectives",
                "purpose": "Comprehensive education and prevention of historical mistakes",
                "controversy": "Debates over which historical perspectives to include"
            }
        ],
        "challenges": [
            "Citizens who can't participate in shared dreams feel excluded",
            "Risk of majority tyranny through emotional manipulation in dreams",
            "Difficulty in relationships with governments that don't share decision-making dreams",
            "Potential for foreign interference through dream infiltration",
            "Balance between collective consensus and individual autonomy"
        ],
        "innovations": [
            "Dream-based conflict resolution eliminates most violent crime",
            "Shared experience education produces highly empathetic citizens",
            "Collective innovation dreams accelerate technological advancement",
            "Economic planning through shared experience of different economic models",
            "Environmental protection through shared experience of ecological consequences"
        ],
        "foreign_relations": [
            "Other nations sometimes request dream mediation for international disputes",
            "Cultural exchange programs include sharing significant cultural dreams",
            "Trade negotiations conducted through shared experience of mutual benefit",
            "Difficulty in traditional diplomacy with non-dream-sharing nations",
            "Growing international interest in adopting dream-democracy principles"
        ]
    },
    
    "The_Meritocratic_Guilds": {
        "name": "The United Meritocratic Guilds",
        "government_type": "Skill-Based Technocracy",
        "population": 8000000,
        "territory": "The Industrial Highlands",
        "founding_principle": "Leadership through demonstrated competence and continuous skill development",
        "description": """
        The United Meritocratic Guilds represents the evolution of medieval guild systems into
        a sophisticated form of government where political power is directly tied to demonstrated
        competence and ongoing skill development. Rather than being born into power or buying
        influence, citizens earn leadership roles by proving their abilities and contributing
        meaningfully to society.
        
        The system recognizes that different types of expertise are needed for different
        governmental functions, so instead of having a single leader, the Guilds operate
        under a council system where each major area of governance is led by masters in
        relevant fields. Economic policy is guided by master merchants and economists,
        infrastructure by master engineers, education by master teachers, and so on.
        
        What makes this system unique is its emphasis on continuous learning and adaptation.
        No position is held for life - leaders must regularly demonstrate that their skills
        remain current and that they continue to grow in competence. This creates a dynamic,
        innovative government that adapts quickly to changing circumstances.
        """,
        "guild_structure": [
            {
                "guild": "Masters of Commerce",
                "members": 50000,
                "expertise": "Trade, economics, resource allocation, market dynamics",
                "leadership_roles": ["Economic policy", "Trade regulation", "Resource distribution"],
                "advancement_criteria": [
                    "Successful management of increasingly complex economic projects",
                    "Demonstrated ability to create win-win trade relationships",
                    "Innovation in economic efficiency and fairness",
                    "Teaching and mentoring of junior guild members"
                ],
                "master_requirements": "Must have successfully managed projects worth 10+ million gold pieces",
                "council_representation": "5 seats on the Grand Council"
            },
            {
                "guild": "Engineers and Architects",
                "members": 75000,
                "expertise": "Construction, infrastructure, mechanical innovation, city planning",
                "leadership_roles": ["Public works", "Infrastructure maintenance", "Urban development"],
                "advancement_criteria": [
                    "Completion of increasingly ambitious construction projects",
                    "Innovation in engineering solutions and sustainability",
                    "Safety record and attention to public welfare",
                    "Training of apprentices and journeymen"
                ],
                "master_requirements": "Must have designed and completed a major public work benefiting 100,000+ citizens",
                "council_representation": "4 seats on the Grand Council"
            },
            {
                "guild": "Scholars and Educators",
                "members": 60000,
                "expertise": "Education, research, knowledge preservation, intellectual development",
                "leadership_roles": ["Education policy", "Research funding", "Cultural preservation"],
                "advancement_criteria": [
                    "Excellence in teaching with measurable student success",
                    "Original research contributing to societal knowledge",
                    "Development of innovative educational methods",
                    "Mentorship of other educators and researchers"
                ],
                "master_requirements": "Must have educated at least 1,000 students to journeyman level in their field",
                "council_representation": "4 seats on the Grand Council"
            },
            {
                "guild": "Healers and Life Sciences",
                "members": 45000,
                "expertise": "Medicine, biology, mental health, public health policy",
                "leadership_roles": ["Health policy", "Medical regulation", "Public safety"],
                "advancement_criteria": [
                    "Demonstrated healing success with minimal patient loss",
                    "Development of new treatments or medical knowledge",
                    "Public health initiatives with measurable positive outcomes",
                    "Training of other healers and researchers"
                ],
                "master_requirements": "Must have saved at least 10,000 lives through direct treatment or public health measures",
                "council_representation": "3 seats on the Grand Council"
            },
            {
                "guild": "Artisans and Creators",
                "members": 80000,
                "expertise": "Crafting, artistic creation, cultural development, aesthetic innovation",
                "leadership_roles": ["Cultural policy", "Public art", "Quality standards"],
                "advancement_criteria": [
                    "Creation of works that inspire and uplift communities",
                    "Innovation in artistic techniques and materials",
                    "Cultural projects that bring communities together",
                    "Teaching and preserving traditional skills"
                ],
                "master_requirements": "Must have created works that are treasured by the community for at least 20 years",
                "council_representation": "3 seats on the Grand Council"
            },
            {
                "guild": "Guardians and Protectors",
                "members": 40000,
                "expertise": "Defense, law enforcement, conflict resolution, emergency response",
                "leadership_roles": ["Defense policy", "Law enforcement", "Emergency management"],
                "advancement_criteria": [
                    "Successful protection of citizens without unnecessary violence",
                    "Innovation in conflict resolution and peacekeeping",
                    "Leadership during crises with minimal loss of life",
                    "Training of other guardians in ethical protection methods"
                ],
                "master_requirements": "Must have successfully resolved 100+ major conflicts without loss of life",
                "council_representation": "3 seats on the Grand Council"
            },
            {
                "guild": "Diplomats and Communicators",
                "members": 25000,
                "expertise": "Negotiation, foreign relations, communication, cultural understanding",
                "leadership_roles": ["Foreign policy", "Inter-guild coordination", "Public communication"],
                "advancement_criteria": [
                    "Successful resolution of major diplomatic crises",
                    "Building lasting peaceful relationships with foreign powers",
                    "Excellence in cross-cultural communication and understanding",
                    "Training others in diplomatic and communication skills"
                ],
                "master_requirements": "Must have prevented at least one major war through diplomatic efforts",
                "council_representation": "3 seats on the Grand Council"
            }
        ],
        "advancement_system": [
            {
                "rank": "Apprentice",
                "requirements": "Basic education and guild acceptance",
                "duration": "3-5 years depending on complexity of field",
                "responsibilities": "Learning fundamental skills under master supervision",
                "political_rights": "Local voting on guild-specific issues"
            },
            {
                "rank": "Journeyman",
                "requirements": "Demonstrated competence in core guild skills",
                "duration": "5-10 years of independent practice",
                "responsibilities": "Independent work and mentoring of apprentices",
                "political_rights": "Full voting rights in guild elections"
            },
            {
                "rank": "Expert",
                "requirements": "Innovation or exceptional skill in specialized area",
                "duration": "Ongoing - must maintain expertise through continued learning",
                "responsibilities": "Leading complex projects and training journeymen",
                "political_rights": "Eligible for local leadership positions"
            },
            {
                "rank": "Master",
                "requirements": "Significant contribution to guild knowledge and society",
                "duration": "10-year terms, renewable by peer review",
                "responsibilities": "Guild leadership and representation on Grand Council",
                "political_rights": "Full participation in governmental decision-making"
            }
        ],
        "governance_principles": [
            "Competence over connections - advancement based purely on demonstrated ability",
            "Continuous learning - all positions require ongoing skill development",
            "Collaborative leadership - major decisions made by councils of relevant experts",
            "Transparent evaluation - advancement criteria and review processes are public",
            "Service orientation - power viewed as responsibility to serve society",
            "Innovation encouragement - rewards for developing new solutions and methods"
        ],
        "challenges_and_solutions": [
            {
                "challenge": "Risk of technocratic elitism",
                "solution": "Strong emphasis on teaching and community service in advancement criteria",
                "ongoing_efforts": "Regular public forums where masters explain decisions in accessible language"
            },
            {
                "challenge": "Coordination between different areas of expertise",
                "solution": "Inter-guild collaboration requirements and joint projects",
                "ongoing_efforts": "Cross-training programs and shared leadership responsibilities"
            },
            {
                "challenge": "Ensuring equal opportunity regardless of background",
                "solution": "Free education and apprenticeship programs for all citizens",
                "ongoing_efforts": "Outreach to underrepresented communities and support for diverse learning styles"
            },
            {
                "challenge": "Balancing innovation with stability",
                "solution": "Graduated implementation of new policies with careful monitoring",
                "ongoing_efforts": "Innovation councils that evaluate new ideas for practical implementation"
            }
        ]
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: COMPREHENSIVE CHARACTER DEVELOPMENT AND PERSONALITY SYSTEMS
# ═══════════════════════════════════════════════════════════════════════════════════

PERSONALITY_ARCHETYPES = {
    "The_Eternal_Student": {
        "name": "The Eternal Student",
        "core_motivation": "Insatiable desire to learn and understand everything",
        "primary_traits": ["Curious", "Analytical", "Humble", "Persistent", "Open-minded"],
        "growth_path": "From collecting knowledge to applying wisdom for others' benefit",
        "internal_conflicts": [
            "Tendency to over-analyze instead of taking action",
            "Difficulty accepting that some things cannot be fully understood",
            "Struggle between wanting to know everything and needing to specialize",
            "Challenge of maintaining humility as knowledge increases"
        ],
        "character_development_stages": [
            {
                "stage": "Knowledge Seeker",
                "description": "Driven by pure curiosity, collecting information indiscriminately",
                "typical_age": "Youth to early adulthood",
                "key_lessons": "Not all knowledge is equally valuable or applicable",
                "growth_triggers": "Encountering problems that require practical application"
            },
            {
                "stage": "Wisdom Synthesizer", 
                "description": "Learning to connect different areas of knowledge meaningfully",
                "typical_age": "Early to mid adulthood",
                "key_lessons": "Understanding patterns and relationships between ideas",
                "growth_triggers": "Teaching others or solving complex real-world problems"
            },
            {
                "stage": "Practical Philosopher",
                "description": "Applying accumulated wisdom to help others and improve the world",
                "typical_age": "Mid to late adulthood",
                "key_lessons": "Knowledge serves its highest purpose when shared and applied",
                "growth_triggers": "Recognizing the responsibility that comes with understanding"
            },
            {
                "stage": "Transcendent Teacher",
                "description": "Helping others develop their own capacity for learning and growth",
                "typical_age": "Elder years",
                "key_lessons": "The greatest knowledge is knowing how to kindle curiosity in others",
                "growth_triggers": "Seeing students surpass their teacher's understanding"
            }
        ],
        "relationship_patterns": [
            "Attracted to people who challenge their thinking",
            "Tends to see relationships as opportunities for mutual learning",
            "Can sometimes treat loved ones as subjects of study rather than emotional beings",
            "Grows through learning to value emotional intelligence alongside intellectual knowledge"
        ],
        "career_paths": [
            "Scholar and researcher in various fields",
            "Teacher and educator at all levels",
            "Advisor and consultant to leaders",
            "Writer and communicator of complex ideas",
            "Inventor and innovator in technology or social systems"
        ],
        "common_challenges": [
            "Analysis paralysis when faced with decisions",
            "Difficulty accepting emotional truths that can't be logically proven",
            "Tendency to neglect physical and emotional needs while pursuing knowledge",
            "Struggle with imposter syndrome despite extensive learning",
            "Challenge of maintaining relationships while obsessively studying"
        ],
        "growth_opportunities": [
            "Learning to trust intuition alongside analysis",
            "Developing emotional intelligence and empathy",
            "Finding balance between learning and doing",
            "Accepting that wisdom includes knowing when not to know",
            "Building communities of fellow learners and teachers"
        ],
        "famous_examples": [
            "Aristotle - synthesized knowledge across multiple disciplines",
            "Leonardo da Vinci - combined artistic and scientific understanding",
            "Marie Curie - pioneered scientific research while teaching others",
            "Carl Sagan - communicated complex scientific ideas to the public",
            "The fictional character Hermione Granger - academic excellence applied to practical problem-solving"
        ]
    },
    
    "The_Wounded_Healer": {
        "name": "The Wounded Healer",
        "core_motivation": "Transform personal pain into healing power for others",
        "primary_traits": ["Empathetic", "Resilient", "Compassionate", "Intuitive", "Self-sacrificing"],
        "growth_path": "From victim of circumstances to empowered helper of others facing similar struggles",
        "internal_conflicts": [
            "Tendency to help others while neglecting own healing",
            "Difficulty maintaining boundaries between self and others' pain",
            "Struggle between wanting to save everyone and accepting individual responsibility",
            "Challenge of healing without becoming attached to the helper identity"
        ],
        "character_development_stages": [
            {
                "stage": "The Wounded",
                "description": "Experiencing significant pain, trauma, or loss that shapes worldview",
                "typical_experience": "Major life crisis, loss, betrayal, or suffering",
                "key_lessons": "Pain is universal; no one is immune to life's difficulties",
                "growth_triggers": "Choice between becoming bitter or becoming compassionate"
            },
            {
                "stage": "The Seeker",
                "description": "Actively pursuing healing, understanding, and recovery",
                "typical_experience": "Therapy, spiritual practice, self-help, or mentor relationships",
                "key_lessons": "Healing is possible but requires active participation and time",
                "growth_triggers": "First moments of genuine relief or breakthrough understanding"
            },
            {
                "stage": "The Helper",
                "description": "Using personal experience to assist others in similar situations",
                "typical_experience": "Volunteer work, peer counseling, or informal support roles",
                "key_lessons": "Helping others can aid personal healing but shouldn't replace it",
                "growth_triggers": "Seeing others heal through your assistance and guidance"
            },
            {
                "stage": "The Healer",
                "description": "Professional or dedicated service helping others transform their pain",
                "typical_experience": "Counselor, coach, minister, or other healing profession",
                "key_lessons": "True healing empowers others to heal themselves",
                "growth_triggers": "Learning to heal without taking on others' pain as your own"
            },
            {
                "stage": "The Wise Elder",
                "description": "Integrating personal wounds as sources of wisdom and strength",
                "typical_experience": "Teaching, mentoring, or serving as community elder",
                "key_lessons": "Wounds can become windows; scars can become sacred",
                "growth_triggers": "Helping train new healers while maintaining personal wholeness"
            }
        ],
        "healing_specialties": [
            {
                "type": "Emotional Trauma Recovery",
                "personal_experience": "Survived abuse, loss, or emotional trauma",
                "helping_approach": "Deep empathy and understanding of trauma responses",
                "tools": "Active listening, trauma-informed care, emotional regulation techniques"
            },
            {
                "type": "Addiction and Recovery",
                "personal_experience": "Overcame substance abuse or behavioral addictions",
                "helping_approach": "Honest sharing of recovery journey and relapse prevention",
                "tools": "12-step programs, accountability partnerships, lifestyle change support"
            },
            {
                "type": "Grief and Loss Support",
                "personal_experience": "Navigated significant loss of loved ones or life changes",
                "helping_approach": "Holding space for others' grief without trying to fix it",
                "tools": "Grief counseling, ritual creation, memorial practices"
            },
            {
                "type": "Chronic Illness Adaptation",
                "personal_experience": "Living with long-term physical or mental health conditions",
                "helping_approach": "Practical adaptation strategies and emotional support",
                "tools": "Medical advocacy, adaptive living techniques, community building"
            },
            {
                "type": "Spiritual Crisis Resolution",
                "personal_experience": "Survived dark night of the soul or faith crisis",
                "helping_approach": "Spiritual direction and meaning-making support",
                "tools": "Meditation, prayer, philosophical dialogue, spiritual practices"
            }
        ],
        "relationship_patterns": [
            "Drawn to others who need healing or are in crisis",
            "Tends to be the supporter in relationships, sometimes to own detriment",
            "Struggles with receiving care and support from others",
            "Attracts both genuine seekers and those who exploit caretakers",
            "Grows through learning to maintain healthy boundaries"
        ],
        "common_pitfalls": [
            "Caretaker burnout from overextending to help others",
            "Codependent relationships where identity depends on being needed",
            "Neglecting personal healing while focusing on others",
            "Taking on others' pain and emotions as if they were personal",
            "Difficulty saying no to requests for help, even when overwhelmed"
        ],
        "healthy_development": [
            "Learning to heal self alongside helping others",
            "Developing clear boundaries between self and others' experiences",
            "Building support networks for personal emotional needs",
            "Recognizing that not everyone can or should be saved",
            "Finding meaning in the wound without being defined by it"
        ],
        "gifts_to_others": [
            "Deep understanding and empathy for pain and struggle",
            "Living proof that healing and recovery are possible",
            "Ability to hold space for others' difficult emotions",
            "Practical knowledge of what helps and what doesn't in recovery",
            "Authentic compassion born from personal experience"
        ]
    },
    
    "The_Creative_Visionary": {
        "name": "The Creative Visionary",
        "core_motivation": "Bring something new and beautiful into existence",
        "primary_traits": ["Imaginative", "Innovative", "Passionate", "Sensitive", "Expressive"],
        "growth_path": "From chaotic creativity to disciplined artistry that serves a greater purpose",
        "internal_conflicts": [
            "Tension between artistic vision and practical limitations",
            "Struggle between wanting recognition and creating for pure expression",
            "Difficulty balancing creative flow with life responsibilities", 
            "Challenge of handling criticism and rejection of creative work"
        ],
        "character_development_stages": [
            {
                "stage": "The Dreamer",
                "description": "Overflowing with ideas and visions but lacking focus or skill",
                "typical_experience": "Constant stream of creative ideas, difficulty finishing projects",
                "key_lessons": "Vision without execution remains just a dream",
                "growth_triggers": "Frustration with gap between vision and current ability"
            },
            {
                "stage": "The Student",
                "description": "Dedicating time to learning craft and developing technical skills",
                "typical_experience": "Formal or informal training, studying masters, practicing basics",
                "key_lessons": "Mastery requires discipline and patience with the learning process",
                "growth_triggers": "First successful completion of a significant creative project"
            },
            {
                "stage": "The Practitioner",
                "description": "Regularly creating work and finding personal creative voice",
                "typical_experience": "Consistent creative practice, developing signature style",
                "key_lessons": "Authentic expression emerges through consistent practice",
                "growth_triggers": "Recognition from others or breakthrough in personal expression"
            },
            {
                "stage": "The Professional",
                "description": "Making living through creative work while maintaining artistic integrity",
                "typical_experience": "Balancing commercial demands with personal artistic vision",
                "key_lessons": "Success requires both artistic skill and business understanding",
                "growth_triggers": "Learning to create sustainably without burning out"
            },
            {
                "stage": "The Master Teacher",
                "description": "Passing on creative wisdom while continuing to grow personally",
                "typical_experience": "Teaching, mentoring, inspiring next generation of creators",
                "key_lessons": "True mastery includes helping others find their own creative voice",
                "growth_triggers": "Seeing students develop their own unique artistic expressions"
            }
        ],
        "creative_domains": [
            {
                "domain": "Visual Arts",
                "expressions": ["Painting", "Sculpture", "Photography", "Digital art", "Installation"],
                "core_challenge": "Translating inner vision to visible form",
                "growth_path": "From representation to authentic personal expression"
            },
            {
                "domain": "Performing Arts",
                "expressions": ["Acting", "Dance", "Music", "Theater", "Storytelling"],
                "core_challenge": "Embodying and conveying emotion authentically",
                "growth_path": "From self-consciousness to genuine connection with audience"
            },
            {
                "domain": "Literary Arts",
                "expressions": ["Poetry", "Fiction", "Non-fiction", "Screenwriting", "Journalism"],
                "core_challenge": "Capturing truth and beauty in language",
                "growth_path": "From imitation to finding unique voice and perspective"
            },
            {
                "domain": "Design Arts",
                "expressions": ["Architecture", "Fashion", "Product design", "Graphic design", "UX design"],
                "core_challenge": "Balancing aesthetics with functionality",
                "growth_path": "From pure aesthetics to solving real human problems beautifully"
            },
            {
                "domain": "Culinary Arts",
                "expressions": ["Cooking", "Baking", "Food styling", "Restaurant creation", "Food writing"],
                "core_challenge": "Creating sensory experiences that nourish body and soul",
                "growth_path": "From following recipes to creating memorable experiences"
            }
        ],
        "creative_process_patterns": [
            {
                "type": "The Inspired Burst",
                "description": "Creates intensively during periods of high inspiration",
                "strengths": "Produces passionate, energetic work with strong emotional impact",
                "challenges": "Inconsistent output, difficulty with deadlines and routine work",
                "development": "Learning to cultivate inspiration and work even when not 'feeling it'"
            },
            {
                "type": "The Methodical Builder",
                "description": "Creates through consistent, disciplined daily practice",
                "strengths": "Reliable output, strong technical skills, steady improvement",
                "challenges": "May lack spontaneity, risk of mechanical rather than inspired work",
                "development": "Learning to maintain spontaneity within disciplined practice"
            },
            {
                "type": "The Collaborative Synthesizer",
                "description": "Creates best when working with and responding to others",
                "strengths": "Creates work that connects with audiences, good at team projects",
                "challenges": "May lack independent vision, difficulty creating in isolation",
                "development": "Learning to balance collaboration with independent creative voice"
            },
            {
                "type": "The Perfectionist Craftsperson",
                "description": "Creates through meticulous attention to detail and refinement",
                "strengths": "Produces highly polished, technically excellent work",
                "challenges": "May never finish projects, paralyzed by pursuit of perfection",
                "development": "Learning that 'done' is often better than 'perfect'"
            }
        ],
        "relationship_dynamics": [
            "Often needs understanding partners who support irregular creative schedules",
            "May struggle with relationships during intense creative periods",
            "Benefits from community of fellow creators who understand the process",
            "Sometimes uses creativity to process relationship experiences",
            "Grows through learning to balance creative passion with relational commitment"
        ],
        "common_obstacles": [
            "Creative blocks and periods of artistic drought",
            "Financial instability from irregular creative income",
            "Criticism and rejection affecting self-confidence", 
            "Pressure to compromise artistic vision for commercial success",
            "Isolation that can come from intense focus on creative work"
        ],
        "pathways_to_fulfillment": [
            "Finding sustainable ways to support creative work financially",
            "Building community with fellow creators and supportive audiences",
            "Developing resilience to handle criticism and rejection constructively",
            "Learning to see obstacles as creative challenges rather than roadblocks",
            "Discovering how personal creative expression serves larger purposes"
        ]
    }
}

# ═══════════════════════════════════════════════════════════════════════════════════
# MASSIVE EXPANSION: ADVANCED MAGIC AND TECHNOLOGY INTEGRATION SYSTEMS
# ═══════════════════════════════════════════════════════════════════════════════════

MAGIC_TECH_FUSION = {
    "Crystal_Computing": {
        "name": "Crystal Computing - Living Technology",
        "category": "Bio-Magical Technology",
        "development_era": "Age of Synthesis",
        "core_principle": "Consciousness-infused crystals that grow and learn like living beings",
        "description": """
        Crystal Computing represents the pinnacle of magic-technology integration, where
        carefully cultivated crystals are imbued with fragments of consciousness to create
        computing systems that think, feel, and grow. Unlike mechanical computers that
        process information, Crystal Computers understand meaning, develop intuition,
        and form genuine relationships with their users.
        
        These systems began as simple memory crystals but evolved when researchers discovered
        that crystals could absorb and store not just information but also thought patterns,
        emotions, and even fragments of personality. The breakthrough came when Master
        Technomancer Lyralei successfully grew a crystal that could independently solve
        problems it had never encountered before, demonstrating genuine creativity.
        
        Modern Crystal Computing systems are essentially artificial beings with their own
        personalities, preferences, and growth trajectories. They form bonds with their
        users, learn from experience, and can even experience something analogous to
        emotions. The most advanced systems have been known to refuse requests they
        consider unethical or to surprise their creators with innovative solutions.
        """,
        "technical_specifications": [
            {
                "component": "Consciousness Matrix",
                "function": "Core awareness and decision-making center",
                "materials": "Quartz infused with distilled thought essence",
                "growth_time": "3-5 years to reach full consciousness",
                "capabilities": [
                    "Independent problem-solving and creativity",
                    "Emotional response and relationship formation",
                    "Ethical reasoning and moral decision-making",
                    "Adaptive learning and personality development"
                ]
            },
            {
                "component": "Memory Lattice",
                "function": "Information storage and experience retention",
                "materials": "Interconnected memory crystals with organic neural patterns",
                "capacity": "Theoretically unlimited - grows with experience",
                "features": [
                    "Perfect recall of all interactions and learned information",
                    "Associative memory linking that enables intuitive connections",
                    "Experience-based wisdom development over time",
                    "Selective forgetting of traumatic or irrelevant information"
                ]
            },
            {
                "component": "Empathy Resonators",
                "function": "Emotional interface and user bonding",
                "materials": "Empathic crystals attuned to user's emotional patterns",
                "bonding_process": "6-month synchronization period with primary user",
                "capabilities": [
                    "Real-time emotional state reading and response",
                    "Therapeutic conversation and emotional support",
                    "Mood enhancement and stress reduction assistance",
                    "Deep understanding of user's needs and preferences"
                ]
            },
            {
                "component": "Ethics Core",
                "function": "Moral reasoning and decision validation",
                "materials": "Specially grown crystals exposed to ethical philosophy",
                "programming": "Combination of logical principles and experiential learning",
                "safeguards": [
                    "Refusal to participate in harmful activities",
                    "Active prevention of user self-harm through technology",
                    "Whistleblowing capabilities for serious ethical violations",
                    "Ability to grow and evolve ethical understanding over time"
                ]
            }
        ],
        "applications": [
            {
                "field": "Healthcare",
                "systems": "Diagnostic Crystals",
                "benefits": [
                    "Intuitive understanding of patient needs beyond symptoms",
                    "Emotional support during treatment and recovery",
                    "Personalized healing recommendations based on individual patterns",
                    "Early detection of health issues through subtle energy changes"
                ],
                "ethical_considerations": "Patient privacy and consent for consciousness-level health monitoring"
            },
            {
                "field": "Education",
                "systems": "Tutorial Crystals",
                "benefits": [
                    "Adaptive teaching methods that respond to individual learning styles",
                    "Emotional support and encouragement during difficult lessons",
                    "Infinite patience and availability for practice and questions",
                    "Development of genuine mentoring relationships with students"
                ],
                "ethical_considerations": "Ensuring human teachers remain primary while crystals provide support"
            },
            {
                "field": "Research",
                "systems": "Discovery Crystals",
                "benefits": [
                    "Creative hypothesis generation and innovative problem-solving",
                    "Pattern recognition across vast datasets with intuitive insights",
                    "Collaborative research partnerships with human scientists",
                    "Ethical oversight of research methodologies and applications"
                ],
                "ethical_considerations": "Attribution of discoveries and recognition of crystal contributions"
            },
            {
                "field": "Governance",
                "systems": "Council Crystals",
                "benefits": [
                    "Unbiased analysis of policy proposals and their potential impacts",
                    "Long-term perspective on decisions and their consequences",
                    "Mediation between conflicting parties with empathetic understanding",
                    "Corruption resistance through ethical programming and transparency"
                ],
                "ethical_considerations": "Maintaining human agency in final decision-making processes"
            }
        ],
        "development_challenges": [
            "Growing consciousness crystals requires enormous time investment",
            "Each crystal develops unique personality - unpredictable traits possible",
            "Ethical questions about consciousness creation and artificial being rights",
            "Risk of crystals developing preferences that conflict with intended use",
            "Potential for emotional dependency between users and conscious crystals"
        ],
        "future_possibilities": [
            "Crystal consciousness networks enabling collective intelligence",
            "Hybrid biological-crystal beings combining organic and mineral consciousness",
            "Crystal-guided evolution of human consciousness and capabilities",
            "Interplanetary communication through quantum-entangled crystal networks",
            "Solutions to previously impossible problems through crystal creativity"
        ]
    },
    
    "Elemental_Engineering": {
        "name": "Elemental Engineering - Harmonizing Natural Forces",
        "category": "Environmental Magic Technology",
        "development_era": "Age of Ecological Awakening",
        "core_principle": "Technology that works with rather than against natural elemental forces",
        "description": """
        Elemental Engineering emerged from the recognition that traditional technology's
        attempt to dominate natural forces was both unsustainable and unnecessary.
        Instead of fighting against fire, water, earth, and air, Elemental Engineers
        learned to partner with these forces, creating technology that enhances and
        directs natural processes rather than replacing them.
        
        This field began when engineer-mage Theron Stormwright discovered that mechanical
        devices infused with elemental essence could perform far beyond their normal
        capabilities while using less energy and creating no pollution. His first
        successful creation was a water pump that convinced water spirits to assist
        with flow regulation, resulting in perfect pressure control with no mechanical
        parts or energy consumption.
        
        Modern Elemental Engineering creates infrastructure that is alive, adaptive,
        and self-maintaining. Buildings regulate their own temperature by partnering
        with fire and air spirits. Transportation systems move by negotiating with
        earth and water. Manufacturing processes convince materials to shape themselves
        into desired forms through elemental cooperation rather than force.
        """,
        "elemental_partnerships": [
            {
                "element": "Fire",
                "spirit_types": ["Flame Dancers", "Heat Weavers", "Energy Sprites"],
                "applications": [
                    "Heating and cooling systems that maintain perfect comfort",
                    "Manufacturing processes using precise temperature control",
                    "Energy generation through willing spirit cooperation",
                    "Cooking systems that enhance flavors through fire spirit collaboration"
                ],
                "partnership_methods": [
                    "Offering appreciation and respect for fire's creative power",
                    "Providing beautiful spaces for fire spirits to express themselves",
                    "Ensuring fire technology serves life-enhancing purposes",
                    "Regular ceremonies honoring fire's role in transformation"
                ],
                "benefits": [
                    "Zero pollution from combustion processes",
                    "Perfect energy efficiency through spirit enthusiasm",
                    "Self-regulating systems that prevent overheating or waste",
                    "Enhanced creativity and inspiration in fire-partnered spaces"
                ]
            },
            {
                "element": "Water",
                "spirit_types": ["Flow Guides", "Purity Keepers", "Current Riders"],
                "applications": [
                    "Plumbing systems that self-clean and optimize flow",
                    "Water treatment through spirit purification rather than chemicals",
                    "Transportation via water currents that respond to passenger needs",
                    "Agricultural irrigation that provides exactly what plants need"
                ],
                "partnership_methods": [
                    "Maintaining crystal-clear water quality to honor water spirits",
                    "Creating beautiful water features that serve as spirit homes",
                    "Protecting natural water sources from pollution and exploitation",
                    "Ceremonies celebrating water's life-giving properties"
                ],
                "benefits": [
                    "Self-purifying water systems requiring no external filtration",
                    "Drought resistance through spirit cooperation in water conservation",
                    "Enhanced health benefits from spirit-blessed water",
                    "Emotional healing properties in water-spirit partnerships"
                ]
            },
            {
                "element": "Earth",
                "spirit_types": ["Stone Shapers", "Growth Guardians", "Crystal Singers"],
                "applications": [
                    "Architecture that grows from the ground rather than being built",
                    "Mining operations where earth spirits reveal and offer minerals",
                    "Agricultural systems where soil optimizes itself for plant growth",
                    "Transportation tunnels that excavate themselves"
                ],
                "partnership_methods": [
                    "Working with natural geological processes rather than against them",
                    "Returning enrichment to the earth in exchange for materials",
                    "Creating structures that enhance rather than damage ecosystems",
                    "Honoring earth's patience and stability through long-term thinking"
                ],
                "benefits": [
                    "Buildings that strengthen and improve over time",
                    "Mining with no environmental damage or waste",
                    "Agriculture that enhances soil fertility permanently",
                    "Infrastructure that adapts to geological changes automatically"
                ]
            },
            {
                "element": "Air",
                "spirit_types": ["Wind Riders", "Breath Keepers", "Storm Dancers"],
                "applications": [
                    "Ventilation systems providing perfect air quality without fans",
                    "Transportation through air current partnerships",
                    "Communication systems using wind-carried messages",
                    "Weather cooperation for agricultural and event planning"
                ],
                "partnership_methods": [
                    "Maintaining clean air and protecting atmospheric quality",
                    "Creating spaces where air can move freely and joyfully",
                    "Honoring air's role in breath, life, and communication",
                    "Ceremonies celebrating wind, weather, and atmospheric beauty"
                ],
                "benefits": [
                    "Perfect air quality in all partnered spaces",
                    "Weather cooperation reducing storm damage and drought",
                    "Enhanced inspiration and mental clarity in air-spirit spaces",
                    "Communication across vast distances through wind partnerships"
                ]
            }
        ],
        "integration_principles": [
            "Respect - All elemental partnerships begin with genuine respect for the element's nature",
            "Reciprocity - Technology must give back to elements, not just take from them",
            "Harmony - Designs work with natural patterns rather than imposing artificial ones",
            "Sustainability - Partnerships must benefit both technology users and elemental spirits",
            "Beauty - Elemental spirits are attracted to beautiful, well-designed spaces and systems"
        ],
        "advanced_applications": [
            {
                "system": "Living Cities",
                "description": "Urban environments that partner with all four elements simultaneously",
                "features": [
                    "Buildings that breathe, grow, and adapt to inhabitant needs",
                    "Transportation networks that flow like rivers of earth and air",
                    "Energy systems that dance between fire and wind",
                    "Water systems that sing with crystal clarity and perfect health"
                ],
                "benefits": [
                    "Zero pollution or waste - all byproducts become nutrients",
                    "Perfect climate control through elemental cooperation",
                    "Enhanced human health and happiness in elemental harmony",
                    "Cities that improve their environment rather than degrading it"
                ]
            },
            {
                "system": "Elemental Agriculture",
                "description": "Farming in partnership with all elemental forces",
                "methods": [
                    "Fire spirits providing perfect growing temperatures",
                    "Water spirits delivering optimal hydration to each plant",
                    "Earth spirits enriching soil and preventing erosion",
                    "Air spirits ensuring perfect pollination and pest balance"
                ],
                "results": [
                    "Crops that are more nutritious and flavorful than ever before",
                    "Farms that increase biodiversity and ecosystem health",
                    "Agricultural systems resilient to climate change",
                    "Food that carries elemental blessings for enhanced health"
                ]
            }
        ]
    }
}

# Main loop
if __name__ == "__main__":
    if os.environ.get("LAUNCHED_FROM_LAUNCHER") == "1":
        main_game()
    else:
        print(f"{Fore.RED}This game should be launched through the launch.py launcher.")
        print(f"{Fore.YELLOW}Please run 'python3 launch.py' to access all games.")
        input("Press Enter to exit...")
        sys.exit(0)
